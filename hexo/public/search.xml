<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>vue 指令语法</title>
    <url>/2023/11/06/2-vue%E6%8C%87%E4%BB%A4%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>种类：v-html, v-bind, v-on, v-model, v-slot …</p>
<p>指令语法如下图所示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img20.360buyimg.com/img/jfs/t1/89597/35/41403/16292/65489fc5Fb2d8b302/d64ca449c9e1d57b.png"
                      alt="指令语法"
                ></p>
<h3 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h3><p>（1）动态参数的值应为字符串或 null（null 会移除该绑定）</p>
<p>（2）动态参数的名称避免使用大写字母，因为会被强制转为小写（someAttr -&gt; someattr）</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:</span>[<span class="attr">attributeName</span>]=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @[<span class="attr">eventName</span>]=<span class="string">&quot;doSomething&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>修饰符为以点开头的特殊后缀，比如：.prevent 修饰符会告知 v-on 指令对触发的事件调用 event.preventDefault()</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h2><p>span 的内容会被替换为 rawHtml 属性的值，其中的数据绑定会被忽略（注意：使用这种方法容易造成 XSS 漏洞）</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;rawHtml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;dynamicId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--简写--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:id</span>=<span class="string">&quot;dynamicId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="动态绑定多个值"><a href="#动态绑定多个值" class="headerlink" title="动态绑定多个值"></a>动态绑定多个值</h3><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> objOfAttrs = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;container&#x27;</span>,</span><br><span class="line">    <span class="attr">class</span>: <span class="string">&#x27;wrapper&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:objOfAttrs</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>比如：动态 style class</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;class1: isClass1, class2: isClass2&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--简写--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><p>v-if, v-else-if, v-else</p>
<p>注意：v-if 的优先级大于 v-for，二者不建议同时使用（详见 v-for）</p>
<h3 id="template-上的-v-if"><a href="#template-上的-v-if" class="headerlink" title="template 上的 v-if"></a>template 上的 v-if</h3><p>如果想要切换不止一个元素，可以在元素外包一个 <code>&lt;template&gt;</code>，并用 v-if 控制（v-show 不能在 template 上使用）</p>
<p>因为 <code>&lt;template&gt;</code> 是一个不可见的包装器元素，渲染的结果中不会包含该元素</p>
<h3 id="v-if-v-show"><a href="#v-if-v-show" class="headerlink" title="v-if &amp; v-show"></a>v-if &amp; v-show</h3><p>（1）原理：v-if 切换时，条件区块会被销毁与重建；v-show 切换时，只会切换 display 属性</p>
<p>（2）惰性：v-if 是惰性的，如果初始为 false 则不渲染；v-show 初始始终会渲染</p>
<p>（3）场景：v-if 初始渲染开销较好，不会频繁切换时使用；v-show 切换开销较小，频繁切换时使用</p>
]]></content>
      <categories>
        <category>vue - 文档</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3 应用的创建&amp;使用</title>
    <url>/2023/11/06/1-vue3%E5%BA%94%E7%94%A8%E7%9A%84%E5%88%9B%E5%BB%BA&amp;%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h2><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">npm create vue@latest</span><br></pre></td></tr></table></figure></div>

<h2 id="通过CDN使用vue"><a href="#通过CDN使用vue" class="headerlink" title="通过CDN使用vue"></a>通过CDN使用vue</h2><p>这里使用了提供 npm 包服务的 CDN —— unpkg</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="DOM-中的根组件模板"><a href="#DOM-中的根组件模板" class="headerlink" title="DOM 中的根组件模板"></a>DOM 中的根组件模板</h3><p>当根组件没有设置 template 选项时，Vue 将自动使用容器的 innerHTML 作为模板</p>
<p>这种方式通常用于此种“无构建步骤”（通过 CDN 使用 vue）的应用程序</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(&#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="全局构建"><a href="#全局构建" class="headerlink" title="全局构建"></a>全局构建</h3><p>上述链接使用 <em>全局构建</em> 版本的 Vue，所有顶层 API 都暴露为全局 Vue 对象的属性</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> &#123; createApp, ref &#125; = <span class="title class_">Vue</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="comment">/**  1. 创建应用并挂载 */</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">createApp</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> message = <span class="title function_">ref</span>(<span class="string">&#x27;Hello world!&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        message</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">  <span class="comment">/**  2. 分步骤 */</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// // a. 创建应用</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// const app = createApp(&#123;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//   setup() &#123;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//     const message = ref(&#x27;Hello world!&#x27;);</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//     return &#123;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//       message</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//     &#125;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//   &#125;;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// &#125;);</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// // b. 挂载</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// app.mount(&#x27;#app&#x27;);</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="导入映射表（Import-maps）"><a href="#导入映射表（Import-maps）" class="headerlink" title="导入映射表（Import maps）"></a>导入映射表（Import maps）</h3><p>不使用完整的 CDN URL 引入，而使用 es6 的导入映射表（import maps）</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;importmap&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&quot;imports&quot;</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="string">&quot;vue&quot;</span>: <span class="string">&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; createApp, ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">createApp</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> message = <span class="title function_">ref</span>(<span class="string">&quot;Hello world!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        message</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="拆分模块"><a href="#拆分模块" class="headerlink" title="拆分模块"></a>拆分模块</h3><p>将代码拆分为单独的 js 文件以便管理</p>
<p>出于安全原因，es 模块只能通过 http 协议工作，所以需要使用本地的 http 服务器，通过 http 协议提供 index.html。比如：安装 Node.js，在 html 文件所在的文件夹运行 <code>npx serve</code></p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> <span class="title class_">MyComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./my-component.js&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">createApp</span>(<span class="title class_">MyComponent</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// my-component.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123; count &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;count is &#123;&#123; count &#125;&#125;&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>vue3 - 文档</category>
      </categories>
      <tags>
        <tag>vue3</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3 响应式</title>
    <url>/2023/11/06/3-vue3%E5%93%8D%E5%BA%94%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="ref"><a href="#ref" class="headerlink" title="ref()"></a>ref()</h2><p>ref() 返回一个包含属性 value 的对象</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">            count.<span class="property">value</span>++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            count,</span><br><span class="line">            increment</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>ref 的 .value 属性使得 Vue 可以检测其何时被访问或修改</p>
<p>当一个组件首次渲染时，Vue 会<strong>追踪</strong>在渲染过程中使用的每一个 ref；当一个 ref 被修改时，它会<strong>触发</strong> 追踪它的组件 的重新渲染</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="keyword">const</span> myRef = &#123;</span><br><span class="line">    <span class="attr">_value</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">        <span class="title function_">track</span>(); <span class="comment">// 追踪渲染过程中使用的每一个 ref</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_value</span> = newValue;</span><br><span class="line">        <span class="title function_">trigger</span>(); <span class="comment">// 触发追踪它的组件的重新渲染</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id=""><a href="#" class="headerlink" title="&lt;script setup&gt;"></a><code>&lt;script setup&gt;</code></h3><p>使用 <code>&lt;script setup&gt;</code> 简化代码</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    count.<span class="property">value</span>++;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="DOM-更新时机"><a href="#DOM-更新时机" class="headerlink" title="DOM 更新时机"></a>DOM 更新时机</h2><p>DOM 更新后，立即执行回调函数</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; nextTick &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    count.<span class="property">value</span>++;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">nextTick</span>();</span><br><span class="line">    <span class="title function_">callback</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>或者</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; nextTick &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    count.<span class="property">value</span>++;</span><br><span class="line">    <span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> <span class="title function_">callback</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="reactive"><a href="#reactive" class="headerlink" title="reactive()"></a>reactive()</h2><p>reactive() 使对象本身具有响应性，当 ref 的值是一个对象时，会在内层调用 reactive</p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>reactive() 返回原始对象的 proxy，允许 Vue 拦截和定义基本操作的行为（如属性查找、赋值、删除等）</p>
<p>reactive() 的返回值和原始对象不相等</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> raw = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="title function_">reactive</span>(raw);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(raw === proxy); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>

<h3 id="reactive-的局限性"><a href="#reactive-的局限性" class="headerlink" title="reactive() 的局限性"></a>reactive() 的局限性</h3><p>（1）有限的值类型：只能用于对象类型（对象、数组、Map、Set），不能用于原始类型；</p>
<p>（2）不能替换整个对象：替换整个对象会导致响应式连接丢失；</p>
<p>（3）对解构操作不友好：解构后的变量会丢失响应式连接。</p>
<h2 id="ref-解包"><a href="#ref-解包" class="headerlink" title="ref 解包"></a>ref 解包</h2><h3 id="ref-作为-reactive-对象属性"><a href="#ref-作为-reactive-对象属性" class="headerlink" title="ref 作为 reactive 对象属性"></a>ref 作为 reactive 对象属性</h3><p>ref 作为响应式对象的属性时，就像一个普通的属性</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123; count &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(state.<span class="property">count</span>); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">state.<span class="property">count</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(state.<span class="property">count</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></div>

<h3 id="在模板中解包"><a href="#在模板中解包" class="headerlink" title="在模板中解包"></a>在模板中解包</h3><p>在模板渲染上下文中，只有顶级的 ref 才会被解包</p>
<p>第二个不符合预期是因为，obj.id 未被解包，仍是一个 ref 对象</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="title function_">ref</span>(<span class="number">1</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 符合预期 —— 2 --&gt;</span></span><br><span class="line">&#123;&#123; count + 1 &#125;&#125;</span><br><span class="line"><span class="comment">&lt;!-- 不符合预期 —— [object Object]1 --&gt;</span></span><br><span class="line">&#123;&#123; obj.id + 1 &#125;&#125;</span><br></pre></td></tr></table></figure></div>

<p>为了解决该问题，需要将 id 结构为顶级属性</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; id &#125; = obj;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 符合预期 —— 2 --&gt;</span></span><br><span class="line">&#123;&#123; id + 1 &#125;&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>vue3 - 文档</category>
      </categories>
      <tags>
        <tag>vue3</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3 计算属性</title>
    <url>/2023/11/07/4-vue3%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>computed() 方法接受一个 getter 函数，返回一个计算属性 ref</p>
<p>因为 ref 会在模板中自动解包，所以在表达式中引用无需 .value</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; reactive, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> author = <span class="title function_">reactive</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">name</span>: <span class="string">&quot;Zoella&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">books</span>: [<span class="string">&#x27;vue2&#x27;</span>, <span class="string">&#x27;vue3&#x27;</span>, <span class="string">&#x27;vue4&#x27;</span>]</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> hasBookPublished = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> author.<span class="property">books</span>.<span class="property">length</span> &gt; <span class="number">0</span> ? <span class="string">&#x27;yes&#x27;</span> : <span class="string">&#x27;no&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; author.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span> has published books: </span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; hasBookPublished &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="计算属性缓存-VS-方法"><a href="#计算属性缓存-VS-方法" class="headerlink" title="计算属性缓存 VS 方法"></a>计算属性缓存 VS 方法</h2><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; calculateBooksMessage() &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">calculateBooksMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> author.<span class="property">books</span>.<span class="property">length</span> &gt; <span class="number">0</span> ? <span class="string">&#x27;yes&#x27;</span> : <span class="string">&#x27;no&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>计算属性比方法节省性能。</p>
<p>将与上述相同的函数定义为方法，结果和计算属性相同，然而 <strong>计算属性值会基于其响应式依赖被缓存</strong>，只要<code>author.books</code>不变，就不会重复执行 getter 函数。但是方法总会在重渲染发生时再次执行函数。</p>
<h2 id="可写计算属性"><a href="#可写计算属性" class="headerlink" title="可写计算属性"></a>可写计算属性</h2><p>计算属性默认为只读。特殊场景下会用到“可写”的计算属性。</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> firstName = <span class="title function_">ref</span>(<span class="string">&#x27;John&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> lastName = <span class="title function_">ref</span>(<span class="string">&#x27;Doe&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> fullName = <span class="title function_">computed</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// getter</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> firstName.<span class="property">value</span> + <span class="string">&#x27; &#x27;</span> + lastName.<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// setter</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    [firstName.<span class="property">value</span>, lastName.<span class="property">value</span>] = newValue.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>当运行 <code>fullName.value = &#39;Zoella Wang&#39;</code> 时，setter会被调用，firstName 和 lastName 会随之更新。</p>
]]></content>
      <categories>
        <category>vue3 - 文档</category>
      </categories>
      <tags>
        <tag>vue3</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么 vue 组件添加 scoped 后，某些组件样式不生效</title>
    <url>/2023/11/14/5-%E4%B8%BA%E4%BB%80%E4%B9%88vue%E7%BB%84%E4%BB%B6%E6%B7%BB%E5%8A%A0scoped%E5%90%8E%E6%9F%90%E4%BA%9B%E7%BB%84%E4%BB%B6%E6%A0%B7%E5%BC%8F%E4%B8%8D%E7%94%9F%E6%95%88/</url>
    <content><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>在父组件中修改子组件的某些样式，发现不生效，删去<code>&lt;style scoped&gt;&lt;/style&gt;</code>中的 scoped 后生效。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>scoped 实现样式隔离的原理为：</p>
<p>编译时，父组件的所有标签、子组件的根标签、以及所有的样式 都会加上特殊的标识；</p>
<p>因为子组件内部的标签都没有此种标识，所以样式就不会生效。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="不添加-scoped"><a href="#不添加-scoped" class="headerlink" title="不添加 scoped"></a>不添加 scoped</h3><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here is parent component<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TestScoped</span> /&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.parent</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">color</span>: deepskyblue;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here is son component<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>编译后：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here is parent component<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here is son component<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: deepskyblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="添加-scoped"><a href="#添加-scoped" class="headerlink" title="添加 scoped"></a>添加 scoped</h3><p>编译后：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-v-7ba5bd90</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">data-v-7ba5bd90</span>&gt;</span>Here is parent component<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">data-v-7ba5bd90</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 没有标识，所以不生效 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here is son component<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[data-v-7ba5bd90]</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: deepskyblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="深度作用选择器"><a href="#深度作用选择器" class="headerlink" title="深度作用选择器"></a>深度作用选择器</h3><p>使用 &#x2F;deep&#x2F; 或者 ::v-deep</p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line">/deep/ <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: deepskyblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 或者 */</span></span><br><span class="line">::v-deep p &#123;</span><br><span class="line">  <span class="attribute">color</span>: deepskyblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>编译后：</p>
<p>html 结果不变，样式代码变化</p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[data-v-7ba5bd90]</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: deepskyblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="使用无-scoped-的-style"><a href="#使用无-scoped-的-style" class="headerlink" title="使用无 scoped 的 style"></a>使用无 scoped 的 style</h3><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">color</span>: deepskyblue;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="comment">/* 生效样式代码 */</span></span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>vue - 样式</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>实践问题</tag>
      </tags>
  </entry>
  <entry>
    <title>vue class 与 style 绑定</title>
    <url>/2023/11/28/6-vue%20class%E4%B8%8Estyle%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h2 id="绑定一个返回对象的计算属性"><a href="#绑定一个返回对象的计算属性" class="headerlink" title="绑定一个返回对象的计算属性"></a>绑定一个返回对象的计算属性</h2><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isActive = <span class="title function_">ref</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">const</span> error = <span class="title function_">ref</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> classObject = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">active</span>: isActive.<span class="property">value</span> &amp;&amp; !error.<span class="property">value</span>,</span><br><span class="line">    <span class="string">&#x27;text-danger&#x27;</span>: error.<span class="property">value</span> &amp;&amp; error.<span class="property">value</span>.<span class="property">type</span> === <span class="string">&#x27;fatal&#x27;</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;classObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="子组件继承父组件传入的class"><a href="#子组件继承父组件传入的class" class="headerlink" title="子组件继承父组件传入的class"></a>子组件继承父组件传入的class</h2><h3 id="有一个根元素的组件"><a href="#有一个根元素的组件" class="headerlink" title="有一个根元素的组件"></a>有一个根元素的组件</h3><p>子组件的根元素，在渲染时会添加父组件的 class。</p>
<h3 id="有多个根元素的组件"><a href="#有多个根元素的组件" class="headerlink" title="有多个根元素的组件"></a>有多个根元素的组件</h3><p>子组件中 <code>:class=&#39;$attrs.class&#39;</code> 的根元素，在渲染时会添加父组件的 class。</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件 MyComponent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">&quot;$attrs.class&quot;</span>&gt;</span>one root element<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>another root element<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">class</span>=<span class="string">&quot;fatherClass&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>渲染后结果：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;fatherClass&quot;</span>&gt;</span>one root element<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>another root element<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="內联样式"><a href="#內联样式" class="headerlink" title="內联样式"></a>內联样式</h2><h3 id="绑定对象"><a href="#绑定对象" class="headerlink" title="绑定对象"></a>绑定对象</h3><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> styleObject = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">    <span class="attr">fontSize</span>: <span class="string">&quot;13px&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;styleObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="绑定对象数组"><a href="#绑定对象数组" class="headerlink" title="绑定对象数组"></a>绑定对象数组</h3><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;[baseStyle, overriddingStyle]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> baseStyle = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> overriddingStyle = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&quot;black&quot;</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>vue - 样式</category>
        <category>vue3 - 文档</category>
      </categories>
      <tags>
        <tag>vue3</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>v-for</title>
    <url>/2023/11/29/7-v-for/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in items&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>可以使用 of 代替 in：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) of items&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>支持解构语法：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;&#123;message&#125; in items&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(&#123;message&#125;, index) in items&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="遍历对象属性"><a href="#遍历对象属性" class="headerlink" title="遍历对象属性"></a>遍历对象属性</h2><p>使用 v-for 遍历对象属性，遍历的顺序和 Object.keys() 返回值的顺序一致</p>
<p>三个参数依次为 索引、属性名、属性值：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myObject = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;How to do lists in Vue&#x27;</span>,</span><br><span class="line">  <span class="attr">author</span>: <span class="string">&#x27;Jane Doe&#x27;</span>,</span><br><span class="line">  <span class="attr">publishedAt</span>: <span class="string">&#x27;2016-04-10&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(index, key, value) in myObject&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>结果为：</p>
<div class="highlight-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">0. title: How to do lists in Vue</span><br><span class="line">1. author: Jane Doe</span><br><span class="line">2. publishedAt: 2016-04-10</span><br></pre></td></tr></table></figure></div>

<h2 id="v-for-与-v-if"><a href="#v-for-与-v-if" class="headerlink" title="v-for 与 v-if"></a>v-for 与 v-if</h2><p>v-if 比 v-for 优先级高</p>
<p>错误用法：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 此时 v-if 的 todo 还没有定义 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in todos&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;!todo.isComplete&quot;</span>&gt;</span></span><br><span class="line">&#123;&#123; todo.name &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>正确用法：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in todos&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-if</span>=<span class="string">&quot;!todo.isComplete&quot;</span>&gt;</span></span><br><span class="line">   &#123;&#123; todo.name &#125;&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="通过-key-管理状态"><a href="#通过-key-管理状态" class="headerlink" title="通过 key 管理状态"></a>通过 key 管理状态</h2><p>Vue 默认按照 “就地更新” 的策略更新通过 v-for 渲染的列表。当数据项的顺序改变时，Vue 不会随之移动 DOM 元素的顺序，而是就地更新每个元素，确保它们在原本指定的索引位置上渲染。</p>
<p>默认模式是高效的，但只适用于 <strong>列表渲染输出的结果不依赖子组件状态或者临时 DOM 状态 (例如表单输入值) 的情况</strong>。</p>
<p>推荐在任何时候为 v-for 提供一个 key attribute，除非所迭代的 DOM 内容非常简单。</p>
]]></content>
      <categories>
        <category>vue - 文档</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>js 事件</title>
    <url>/2023/11/29/8-js%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>事件捕获和事件冒泡 是浏览器处理DOM元素事件的两种方式（顺序：先捕获，再冒泡）。</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h2><p>事件捕获从文档根节点开始，逐级向下传播到目标元素。</p>
<p>点击 div，事件传播方向：document -&gt; html -&gt; body -&gt; div</p>
<h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>事件冒泡指当目标元素触发了某事件时，事件会从该元素开始逐级向上传播，直到文档根节点。</p>
<p>点击 div，事件传播方向：div -&gt; body -&gt; html -&gt; document</p>
<h2 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h2><h3 id="DOM0-事件模型"><a href="#DOM0-事件模型" class="headerlink" title="DOM0 事件模型"></a>DOM0 事件模型</h3><p>DOM0 只在冒泡阶段处理事件处理程序。</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span>click<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&#x27;clicked&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="DOM2-事件模型"><a href="#DOM2-事件模型" class="headerlink" title="DOM2 事件模型"></a>DOM2 事件模型</h3><p>DOM2 在捕获阶段和冒泡阶段都可以处理事件处理程序（更灵活可控）。</p>
<p>使用：addEventListener() 和 removeEventListener()</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myBtn&quot;</span>&gt;</span>click<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&#x27;clicked&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myBtn&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handleClick);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="IE-事件模型"><a href="#IE-事件模型" class="headerlink" title="IE 事件模型"></a>IE 事件模型</h3><p>功能类似于 DOM0，使用方式上类似于 DOM2。</p>
<p>使用 attachEvent() 和 detachEvent() 方法。</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myBtn&quot;</span>&gt;</span>click<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&#x27;clicked&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myBtn&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  btn.<span class="title function_">attachEvent</span>(<span class="string">&#x27;click&#x27;</span>, handleClick);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="js-实现事件修饰符"><a href="#js-实现事件修饰符" class="headerlink" title="js 实现事件修饰符"></a>js 实现事件修饰符</h2><h3 id="阻止默认行为-preventDefault"><a href="#阻止默认行为-preventDefault" class="headerlink" title="阻止默认行为 preventDefault"></a>阻止默认行为 preventDefault</h3><p>比如阻止链接的跳转或表单的提交</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<h3 id="阻止事件冒泡-stopPropagation"><a href="#阻止事件冒泡-stopPropagation" class="headerlink" title="阻止事件冒泡 stopPropagation()"></a>阻止事件冒泡 stopPropagation()</h3><p>阻止事件传到父元素</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  event.<span class="title function_">stopPropagation</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<h3 id="一次性事件处理"><a href="#一次性事件处理" class="headerlink" title="一次性事件处理"></a>一次性事件处理</h3><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handleClick); <span class="comment">// 点击一次移除监听器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handleClick);</span><br></pre></td></tr></table></figure></div>

<h3 id="获取键盘按键"><a href="#获取键盘按键" class="headerlink" title="获取键盘按键"></a>获取键盘按键</h3><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keydown&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">key</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<h3 id="获取鼠标按键"><a href="#获取鼠标按键" class="headerlink" title="获取鼠标按键"></a>获取鼠标按键</h3><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousedown&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">key</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>JavaScript - 事件</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>vue 事件处理</title>
    <url>/2023/11/30/9-vue%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>v-on:click&#x3D;”” 缩写为 @click</p>
<h2 id="在內联事件处理器中访问事件参数"><a href="#在內联事件处理器中访问事件参数" class="headerlink" title="在內联事件处理器中访问事件参数"></a>在內联事件处理器中访问事件参数</h2><p>在內联事件中访问原生 DOM 事件：</p>
<h3 id="向处理器中传入一个-event-变量"><a href="#向处理器中传入一个-event-变量" class="headerlink" title="向处理器中传入一个 $event 变量"></a>向处理器中传入一个 $event 变量</h3><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;warn(&#x27;message1&#x27;, $event)&quot;</span>&gt;</span></span><br><span class="line">Submit</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="使用内联箭头函数"><a href="#使用内联箭头函数" class="headerlink" title="使用内联箭头函数"></a>使用内联箭头函数</h3><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;(event) =&gt; warn(&#x27;message1&#x27;, event)&quot;</span>&gt;</span></span><br><span class="line">Submit</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">warn</span>(<span class="params">message, event</span>) &#123;</span><br><span class="line">  <span class="comment">// 在此处可以访问原生事件</span></span><br><span class="line">  <span class="keyword">if</span> (event) &#123;</span><br><span class="line">    event.<span class="title function_">preventDefault</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">alert</span>(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><ul>
<li>stop：调用 event.stopPropagation()，阻止事件继续传播。</li>
<li>prevent：调用 event.preventDefault()，阻止事件的默认行为。</li>
<li>self：只当事件是从原始目标元素本身触发时触发回调，如果事件是从内部元素冒泡上来的则不触发。</li>
<li>capture：添加事件监听器时使用 capture 模式，即在捕获阶段触发而不是冒泡阶段。</li>
<li>once：只触发一次事件，之后移除该监听器。</li>
<li>passive：提升页面滚动性能，告诉浏览器事件处理函数不会调用 event.preventDefault()。</li>
</ul>
<h3 id="（1）-stop"><a href="#（1）-stop" class="headerlink" title="（1）.stop"></a>（1）.stop</h3><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.stop</span>=<span class="string">&quot;handleOuterClick&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;handleInnerClick&quot;</span>&gt;</span>内部按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>当内部按钮被点击时，handleOuterClick 不会被触发，因为事件不会继续向外部元素传播。</p>
<h3 id="（2）-prevent"><a href="#（2）-prevent" class="headerlink" title="（2）.prevent"></a>（2）.prevent</h3><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> @<span class="attr">submit.prevent</span>=<span class="string">&quot;handleSubmit&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>handleSubmit 方法中的 event.preventDefault() 将会被调用，从而阻止表单的默认提交行为。</p>
<h3 id="（3）-self"><a href="#（3）-self" class="headerlink" title="（3）.self"></a>（3）.self</h3><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.self</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span>只有当点击该div本身时触发<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>只有当点击该 div 元素本身时，handleClick 方法才会被触发；div 内部其他元素冒泡上来的事件不会触发。</p>
<h3 id="（4）-once"><a href="#（4）-once" class="headerlink" title="（4）.once"></a>（4）.once</h3><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.once</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span>点击我，只触发一次<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>当按钮被点击后，handleClick 方法只会被触发一次，之后该事件监听器会被移除。</p>
<h3 id="（5）-capture"><a href="#（5）-capture" class="headerlink" title="（5）.capture"></a>（5）.capture</h3><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.capture</span>=<span class="string">&quot;handleCaptureClick&quot;</span>&gt;</span>捕获阶段触发<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>事件监听器将在捕获阶段（从外向内）触发，而不是在冒泡阶段触发。</p>
<h3 id="（6）-passive"><a href="#（6）-passive" class="headerlink" title="（6）.passive"></a>（6）.passive</h3><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">touchstart.passive</span>=<span class="string">&quot;handleTouchStart&quot;</span>&gt;</span>优化页面滚动性能<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>告诉浏览器 handleTouchStart 方法不会调用 event.preventDefault()，从而有助于提升页面滚动的性能。</p>
<h2 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><figcaption><span>中的 .enter 就是按键修饰符。</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 常规按键</span><br><span class="line"></span><br><span class="line">- enter</span><br><span class="line">- tab</span><br><span class="line">- delete (捕获“Delete”和“Backspace”两个按键)</span><br><span class="line">- esc</span><br><span class="line">- space</span><br><span class="line">- up</span><br><span class="line">- down</span><br><span class="line">- left</span><br><span class="line">- right</span><br><span class="line"></span><br><span class="line">### 系统按键</span><br><span class="line"></span><br><span class="line">系统按键和常规按键不同的是，与 keyup 一起使用时，只有当系统按键被 **按下** 并松开其他键才会触发。</span><br><span class="line"></span><br><span class="line">- ctrl</span><br><span class="line">- alt</span><br><span class="line">- shift</span><br><span class="line">- meta</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line"></span><br><span class="line">``` html</span><br><span class="line">&lt;!-- 常规按键 --&gt;</span><br><span class="line">&lt;!-- 当 Alt + Enter 抬起时，触发 submit 事件 --&gt;</span><br><span class="line">&lt;input @keyup.alt.enter=&quot;submit&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 系统按键 --&gt;</span><br><span class="line">&lt;!-- 当 按下 ctrl 时触发 --&gt;</span><br><span class="line">&lt;div @click.ctrl=&quot;doSth&quot;&gt;A&lt;/div&gt;</span><br><span class="line">&lt;!-- 当 按住 ctrl + 抬起其他键 时触发 --&gt;</span><br><span class="line">&lt;div @keyup.ctrl=&quot;doSth&quot;&gt;A&lt;/div&gt;</span><br></pre></td></tr></table></figure></div>

<h3 id="exact-修饰符"><a href="#exact-修饰符" class="headerlink" title=".exact 修饰符"></a>.exact 修饰符</h3><p>.exact 用于确定触发事件的确定组合。</p>
<p>举例：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当抬起 Ctrl 时，即使同时抬起其他系统按键也会触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">keyup.ctrl</span>=<span class="string">&quot;doSth&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 仅当抬起 Ctrl 且未抬起任何其他键时才会触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">keyup.ctrl.exact</span>=<span class="string">&quot;doSth&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 仅当没有抬起任何系统按键时触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">keyup.exact</span>=<span class="string">&quot;doSth&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>vue - 文档</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>v-model</title>
    <url>/2023/12/05/10-v-model/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:value</span>=<span class="string">&quot;text&quot;</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">input</span>=<span class="string">&quot;event =&gt; text = event.target.value&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>用 v-model 简化：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="单行"><a href="#单行" class="headerlink" title="单行"></a>单行</h3><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;edit&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="多行"><a href="#多行" class="headerlink" title="多行"></a>多行</h3><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;edit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><p>label 标签 for 属性的作用：用户点击 label 标签时，浏览器会将焦点转移到与 for 属性值相匹配的表单控件上，从而提高表单的可访问性和易用性。</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Checked names: &#123;&#123; checkedNames &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;jack&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Jack&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;jack&quot;</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;john&quot;</span> <span class="attr">value</span>=<span class="string">&quot;John&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;john&quot;</span>&gt;</span>John<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;mike&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Mike&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;mike&quot;</span>&gt;</span>Mike<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="单选"><a href="#单选" class="headerlink" title="单选"></a>单选</h3><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Picked: &#123;&#123; picked &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;one&quot;</span> <span class="attr">value</span>=<span class="string">&quot;One&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;picked&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;one&quot;</span>&gt;</span>One<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;two&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Two&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;picked&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;two&quot;</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>单个：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;selected&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">disabled</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>Please select one<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>多个（将值绑定到数组上）：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;selected&quot;</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><h3 id="lazy"><a href="#lazy" class="headerlink" title=".lazy"></a>.lazy</h3><p>.lazy 修饰符表示在 “change” 事件而不是 “input” 事件触发时更新：</p>
<p>这意味着数据将在失去焦点后才会同步到视图中，而不是每次输入时都同步。可以用于减少输入框频繁更新视图的情况，尤其是在处理大量输入时可以提高性能。</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.lazy</span>=<span class="string">&quot;msg&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="number"><a href="#number" class="headerlink" title=".number"></a>.number</h3><p>让用户输入自动转换为数字，如果该值无法被 parseFloat() 处理，则将返回原始值。</p>
<p>number 修饰符会在输入框有 type&#x3D;”number” 时自动启用。</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.lazy</span>=<span class="string">&quot;msg&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="trim"><a href="#trim" class="headerlink" title=".trim"></a>.trim</h3><p>默认自动去除用户输入内容中两端的空格：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.trim</span>=<span class="string">&quot;msg&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>vue - 文档</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3 生命周期</title>
    <url>/2023/12/05/11-vue3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="vue3-生命周期图示"><a href="#vue3-生命周期图示" class="headerlink" title="vue3 生命周期图示"></a>vue3 生命周期图示</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cn.vuejs.org/assets/lifecycle.16e4c08e.png"
                      
                >

<h2 id="注册生命钩子"><a href="#注册生命钩子" class="headerlink" title="注册生命钩子"></a>注册生命钩子</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;now mounted&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>调用 onMounted 时，Vue 会自动将回调函数注册到当前正被初始化的组件实例上，所以该钩子应当被同步注册。</p>
<p>这并不意味对 onMounted 的调用必须放在 setup() 或 <code>&lt;script setup&gt;</code> 内的词法上下文中。</p>
<p>onMounted() 也可以在一个外部函数中调用，只要调用栈是同步的，且最终起源自 setup() 就可以。</p>
]]></content>
      <categories>
        <category>vue3 - 文档</category>
      </categories>
      <tags>
        <tag>vue3</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3 侦听器</title>
    <url>/2023/12/07/12-vue3%E4%BE%A6%E5%90%AC%E5%99%A8/</url>
    <content><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> initVal = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">watch</span>(initVal, <span class="function">(<span class="params">newVal, oldVal</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    ...</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="侦听数据源类型"><a href="#侦听数据源类型" class="headerlink" title="侦听数据源类型"></a>侦听数据源类型</h2><p>ref（包括计算属性 computed）、响应式对象、getter 函数、多个数据源组成的数组</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="title function_">ref</span>(<span class="number">0</span>), y = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ref</span></span><br><span class="line"><span class="title function_">watch</span>(x, <span class="function">(<span class="params">newX</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`x is <span class="subst">$&#123;newX&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// getter 函数</span></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">    <span class="function">() =&gt;</span> x.<span class="property">value</span> + y.<span class="property">value</span>,</span><br><span class="line">    <span class="function">(<span class="params">sum</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`sum is <span class="subst">$&#123;sum&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个数据源组成的数组</span></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">    [x, <span class="function">() =&gt;</span> y.<span class="property">value</span>],</span><br><span class="line">    <span class="function">(<span class="params">[newX, newY], [oldX, oldY]</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`x is <span class="subst">$&#123;newX&#125;</span> y is <span class="subst">$&#123;newY&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<h2 id="侦听响应式对象的属性值"><a href="#侦听响应式对象的属性值" class="headerlink" title="侦听响应式对象的属性值"></a>侦听响应式对象的属性值</h2><p>不能直接监听响应式对象的属性值，而是使用返回该属性的 getter 函数</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，因为 obj.count 是一个 number</span></span><br><span class="line"><span class="title function_">watch</span>(obj.<span class="property">count</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    .<span class="property">console</span>.<span class="title function_">log</span>(<span class="string">`count is: <span class="subst">$&#123;count&#125;</span>`</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确，使用一个 getter 函数</span></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">    <span class="function">() =&gt;</span> obj.<span class="property">count</span>,</span><br><span class="line">    <span class="function">(<span class="params">count</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`count is: <span class="subst">$&#123;count&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<h2 id="深层侦听器"><a href="#深层侦听器" class="headerlink" title="深层侦听器"></a>深层侦听器</h2><p>给 watch 传响应式对象，会隐式创建深层监听器</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">watch</span>(obj, <span class="function">(<span class="params">newVal, oldVal</span>) =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.<span class="property">count</span>++; <span class="comment">// 属性变更时触发</span></span><br></pre></td></tr></table></figure></div>

<p>返回一个响应对象的 getter 函数，只在返回不同对象时才会触发回调</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">    <span class="function">() =&gt;</span> source.<span class="property">obj</span>,</span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        ... <span class="comment">// 仅当 test.obj 被替换时触发</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>可以显示添加 deep，转为深层侦听器</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">    <span class="function">() =&gt;</span> source.<span class="property">obj</span>,</span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        ... <span class="comment">// 仅当 test.obj 被替换时触发</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; <span class="attr">deep</span>: <span class="literal">true</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<h2 id="创建时立即执行的侦听器"><a href="#创建时立即执行的侦听器" class="headerlink" title="创建时立即执行的侦听器"></a>创建时立即执行的侦听器</h2><p>创建侦听器时，立即执行</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">watch</span>(source, </span><br><span class="line">    <span class="function">(<span class="params">newVal, oldVal</span>) =&gt;</span> &#123;&#125;, </span><br><span class="line">    &#123; <span class="attr">immediate</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>vue3 - 文档</category>
      </categories>
      <tags>
        <tag>vue3</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3 组件基础</title>
    <url>/2023/12/11/14-vue3%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h3><p>defineProps 是仅在 <code>&lt;script setup&gt;</code> 中可用的编译宏命令</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">defineProps</span>([<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;content&#x27;</span>]);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span>&#123;&#123; title &#125;&#125;&#123;&#123; content &#125;&#125;<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h3><p>defineEmits 是仅在 <code>&lt;script setup&gt;</code> 中可用的编译宏命令</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> emit = <span class="title function_">defineEmits</span>(<span class="string">&#x27;enlarge-text&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">emit</span>(<span class="string">&#x27;enlarg-text&#x27;</span>); <span class="comment">// 抛出事件</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="slot-插槽"><a href="#slot-插槽" class="headerlink" title="slot 插槽"></a>slot 插槽</h2><p>子组件：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>123<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>父组件：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child-component</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>hahaha<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>子组件渲染结果为：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>123<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>hahaha<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="子组件标签"><a href="#子组件标签" class="headerlink" title="子组件标签"></a>子组件标签</h2><h3 id="子组件有关闭标签"><a href="#子组件有关闭标签" class="headerlink" title="子组件有关闭标签"></a>子组件有关闭标签</h3><p>父组件可以子组件传递 slot 内容</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="子组件无关闭标签"><a href="#子组件无关闭标签" class="headerlink" title="子组件无关闭标签"></a>子组件无关闭标签</h3><p>父组件无法向子组件传递 slot 内容</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> /&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h2><p>通过 component 组件，和 :is 属性切换动态组件</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 点击切换 tab --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-for</span>=<span class="string">&quot;tab in tabs&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;curTab = tab&quot;</span>&gt;</span></span><br><span class="line">       &#123;&#123; tab &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 动态组件 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;tabs[curTab]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;./Home.vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">Posts</span> <span class="keyword">from</span> <span class="string">&#x27;./Posts.vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">Archive</span> <span class="keyword">from</span> <span class="string">&#x27;./Archive.vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> curTab = <span class="title function_">ref</span>(<span class="string">&#x27;Home&#x27;</span>); <span class="comment">// 初始展示 Home 组件</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> tabs = &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Home</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Posts</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Archive</span></span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="元素位置限制"><a href="#元素位置限制" class="headerlink" title="元素位置限制"></a>元素位置限制</h2><p>某些元素对于放在其中的元素类型有限制：<code>&lt;ul&gt;, &lt;ol&gt;, &lt;table&gt;, &lt;select&gt;</code></p>
<p>某些元素仅在特定元素中才会显示：<code>&lt;li&gt;, &lt;tr&gt;, &lt;option&gt;</code></p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自定组件在 &lt;table&gt; 中不生效 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">post-row</span>&gt;</span><span class="tag">&lt;/<span class="name">post-row</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>解决方案（使用 is 属性）：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span>=<span class="string">&quot;vue:post-row&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>vue3 - 文档</category>
      </categories>
      <tags>
        <tag>vue3</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3 模板引用</title>
    <url>/2023/12/08/13-vue3%E6%A8%A1%E6%9D%BF%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&quot;myInput&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; ref, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> myInput = <span class="title function_">ref</span>(<span class="literal">null</span>); <span class="comment">// 必须和模版中的 ref 同名</span></span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        myInput.<span class="property">value</span>.<span class="title function_">focus</span>(); <span class="comment">// 自动聚焦</span></span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>只能在组件挂载后访问模板引用，因为初次渲染时模板引用为 null</p>
<p>比如：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (input.<span class="property">value</span>) &#123;</span><br><span class="line">    input.<span class="property">value</span>.<span class="title function_">focus</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 此时还未挂载，或此元素已卸载（例如 v-if=false）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<h2 id="列表引用"><a href="#列表引用" class="headerlink" title="列表引用"></a>列表引用</h2><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> list = <span class="title function_">ref</span>([</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/* ... */</span></span></span><br><span class="line"><span class="language-javascript">]);</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> itemRefs = <span class="title function_">ref</span>([]);</span></span><br><span class="line"><span class="language-javascript"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(itemRefs.<span class="property">value</span>);</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;itemRefs&quot;</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="函数模板引用"><a href="#函数模板引用" class="headerlink" title="函数模板引用"></a>函数模板引用</h2><p>每次组件更新时会调用 handleRef：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:ref</span>=<span class="string">&quot;handleRef(el)&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title function_">handleRef</span> = (<span class="params">el</span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/*  将 el 赋给 ref 变量 */</span></span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="组件上的-ref"><a href="#组件上的-ref" class="headerlink" title="组件上的 ref"></a>组件上的 ref</h2><p>引用获得的值是组件实例：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./Child.vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> child = <span class="title function_">ref</span>(<span class="literal">null</span>);</span></span><br><span class="line"><span class="language-javascript"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// child.value 是 &lt;Child/&gt; 组件实例</span></span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Child</span> <span class="attr">ref</span>=<span class="string">&quot;child&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="父组件对子组件访问权"><a href="#父组件对子组件访问权" class="headerlink" title="父组件对子组件访问权"></a>父组件对子组件访问权</h3><h4 id="1-选项式-API-或-不使用"><a href="#1-选项式-API-或-不使用" class="headerlink" title="1. 选项式 API 或 不使用 &lt;script setup&gt;"></a>1. 选项式 API 或 不使用 <code>&lt;script setup&gt;</code></h4><p>父组件对子组件的所有属性和方法有完全的访问权（大多情况下应使用 props 和 emit）。</p>
<h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用 &lt;script setup&gt;"></a>2. 使用 <code>&lt;script setup&gt;</code></h4><p>子组件默认私有，除非子组件在其中通过 defineExpose 宏显示暴露。</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> a = <span class="number">1</span>, b = <span class="title function_">ref</span>(<span class="number">2</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 编译器宏无需导入</span></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">defineExpose</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    a,</span></span><br><span class="line"><span class="language-javascript">    b</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>vue3 - 文档</category>
      </categories>
      <tags>
        <tag>vue3</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3 组件注册</title>
    <url>/2023/12/13/15-vue3%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C/</url>
    <content><![CDATA[<h2 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h2><p>所有子组件可以使用全局注册的组件。</p>
<p>使用 vue 应用实例的 .component() 方法：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">component</span>(<span class="string">&#x27;myComponent&#x27;</span>,&#123;</span><br><span class="line">    <span class="comment">// 组件的实现</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>对于单文件组件：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">MyComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">component</span>(<span class="string">&#x27;MyComponent&#x27;</span>, <span class="title class_">MyComponent</span>);</span><br></pre></td></tr></table></figure></div>

<p>链式：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">app.</span><br><span class="line">    <span class="title function_">component</span>(<span class="string">&#x27;ComponentA&#x27;</span>, <span class="title class_">ComponentA</span>).</span><br><span class="line">    <span class="title function_">component</span>(<span class="string">&#x27;ComponentB&#x27;</span>, <span class="title class_">ComponentB</span>).</span><br><span class="line">    <span class="title function_">component</span>(<span class="string">&#x27;ComponentC&#x27;</span>, <span class="title class_">ComponentC</span>);</span><br></pre></td></tr></table></figure></div>

<h2 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>tree-shaking：全局注册的组件，即使不用，也会出现在打包后的 JS 文件中；而局部注册会移除未使用的组件。</li>
<li>依赖关系明确：全局注册使大型项目中组件的依赖关系不够明确；而局部组件使组件间的依赖关系更加明确。</li>
</ol>
]]></content>
      <categories>
        <category>vue3 - 文档</category>
      </categories>
      <tags>
        <tag>vue3</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3 props &amp; emits</title>
    <url>/2023/12/15/16-vue3%20props%20&amp;%20emits/</url>
    <content><![CDATA[<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>注意：props 为单向数据流，从父组件流子组件，所以不应该在子组件中修改 props。</p>
<p>如有需要：</p>
<ol>
<li>用另一个属性接收该 prop 的初始值；</li>
<li>基于该 prop 定义一个计算属性；</li>
<li>向父组件抛出一个事件。</li>
</ol>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>使用字符串数组：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> props = <span class="title function_">defineProps</span>([<span class="string">&#x27;foo&#x27;</span>]);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>使用对象：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> props = <span class="title function_">defineProps</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">title</span>: <span class="title class_">String</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">likes</span>: <span class="title class_">Number</span></span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="静态-prop"><a href="#静态-prop" class="headerlink" title="静态 prop"></a>静态 prop</h3><p>除了静态字符串，都应该使用变量进行传递。</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">BlogPost</span> <span class="attr">title</span>=<span class="string">&quot;this is a title&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;BlogPost :likes=&quot;42&quot; /&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BlogPost</span> <span class="attr">:likes</span>=<span class="string">&quot;post.likes&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;BlogPost is-published=&quot;true&quot; /&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BlogPost</span> <span class="attr">:is-published</span>=<span class="string">&quot;post.isPublished&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;BlogPost ids=&quot;[1, 2, 3]&quot; /&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BlogPost</span> <span class="attr">:ids</span>=<span class="string">&quot;post.ids&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;BlogPost author=&quot;&#123; name: &#x27;Zoella&#x27;, age: 22 &#125;&quot; /&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BlogPost</span> <span class="attr">:author</span>=<span class="string">&quot;post.author&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="一个对象绑定多个-prop"><a href="#一个对象绑定多个-prop" class="headerlink" title="一个对象绑定多个 prop"></a>一个对象绑定多个 prop</h3><p>使用无参数的 v-bind，而不是 :prop-name</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> post = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&quot;this is title&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">BlogPost</span> <span class="attr">v-bind</span>=<span class="string">&quot;post&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="prop-校验"><a href="#prop-校验" class="headerlink" title="prop 校验"></a>prop 校验</h3><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">defineProps</span>(&#123;</span><br><span class="line">  <span class="comment">// 多种可能的类型检查（给出 `null` 和 `undefined` 值则会跳过任何类型检查）</span></span><br><span class="line">  <span class="attr">propA</span>: [<span class="title class_">String</span>, <span class="title class_">Number</span>],</span><br><span class="line">  <span class="comment">// 必传，且为 String 类型，默认值为 &#x27;defualtVal&#x27;</span></span><br><span class="line">  <span class="attr">propB</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="string">&#x27;defaultVal&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 对象类型的默认值</span></span><br><span class="line">  <span class="attr">propC</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Object</span>,</span><br><span class="line">    <span class="comment">// 对象或数组的默认值，必须从一个工厂函数返回。</span></span><br><span class="line">    <span class="comment">// 该函数接收组件所接收的原始 prop 作为参数。</span></span><br><span class="line">    <span class="title function_">default</span>(<span class="params">rawProps</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">message</span>: <span class="string">&#x27;hello&#x27;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 自定义类型校验函数</span></span><br><span class="line">  <span class="attr">propD</span>: &#123;</span><br><span class="line">    <span class="title function_">validator</span>(<span class="params">value</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">&#x27;success&#x27;</span>, <span class="string">&#x27;warning&#x27;</span>, <span class="string">&#x27;danger&#x27;</span>].<span class="title function_">includes</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 函数类型的默认值</span></span><br><span class="line">  <span class="attr">propE</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Function</span>,</span><br><span class="line">    <span class="title function_">default</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;Default function&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<h3 id="Boolean-类型转换"><a href="#Boolean-类型转换" class="headerlink" title="Boolean 类型转换"></a>Boolean 类型转换</h3><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">defineProps</span>(&#123;</span><br><span class="line">  <span class="attr">disabled</span>: <span class="title class_">Boolean</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>使用时：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 等同于 &lt;MyComponent :disabled=&quot;true&quot;&gt;&lt;/MyComponent&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">disabled</span>&gt;</span><span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 等同于 &lt;MyComponent :disabled=&quot;false&quot;&gt;&lt;/MyComponent&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span>&gt;</span><span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="emit"><a href="#emit" class="headerlink" title="emit"></a>emit</h2><h3 id="事件校验"><a href="#事件校验" class="headerlink" title="事件校验"></a>事件校验</h3><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> emit = <span class="title function_">defineEmits</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 无校验</span></span></span><br><span class="line"><span class="language-javascript">  <span class="attr">click</span>: <span class="literal">null</span>,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 校验 submit 事件</span></span></span><br><span class="line"><span class="language-javascript">  <span class="attr">submit</span>: <span class="function">(<span class="params">&#123; email, password &#125;</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (email &amp;&amp; password) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;Invalid submit event payload!&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">submitForm</span>(<span class="params">email, password</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 抛出 submit 事件，携带 email, password 参数</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">emit</span>(<span class="string">&#x27;submit&#x27;</span>, &#123; email, password &#125;);</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>vue3 - 文档</category>
      </categories>
      <tags>
        <tag>vue3</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3 组件 v-model</title>
    <url>/2023/12/15/17-vue3%E7%BB%84%E4%BB%B6v-model/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>父组件：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">CustomInput</span> <span class="attr">v-model</span>=<span class="string">&quot;searchText&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 被展开为： --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;CustomInput</span></span><br><span class="line"><span class="comment">    :model-value=&quot;searchText&quot;</span></span><br><span class="line"><span class="comment">    @update:model-value=&quot;newValue =&gt; searchText = newValue&quot; /&gt; --&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>子组件：</p>
<p>在引用的子组件中使用 v-model 指令时，子组件的 modelValue prop 默认用于传递输入值，并且会触发名为 update:modelValue 的事件来更新该属性。</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 声明属性 modelValue，这是父组件通过 v-model 传给当前组件的 prop</span></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">defineProps</span>([<span class="string">&#x27;modelValue&#x27;</span>]);</span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 声明事件 update:modelValue，用于在当前组件中触发父组件的更新操作</span></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">defineEmits</span>([<span class="string">&#x27;update:modelValue&#x27;</span>]);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 将 modelValue 作为其值，并在输入时触发 update:modelValue 事件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:value</span>=<span class="string">&quot;modelValue&quot;</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">input</span>=<span class="string">&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="如何更改默认名-modelValue"><a href="#如何更改默认名-modelValue" class="headerlink" title="如何更改默认名 modelValue"></a>如何更改默认名 modelValue</h2><p>父组件：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">v-model:title</span>=<span class="string">&quot;bookTitle&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>子组件：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MyComponent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">defineProps</span>([<span class="string">&#x27;title&#x27;</span>]);</span></span><br><span class="line"><span class="language-javascript"><span class="title function_">defineEmits</span>([<span class="string">&#x27;update:title&#x27;</span>]);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:value</span>=<span class="string">&quot;title&quot;</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">input</span>=<span class="string">&quot;$emit(&#x27;update:title&#x27;, $event.target.value)&quot;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="自定义-v-model-修饰符"><a href="#自定义-v-model-修饰符" class="headerlink" title="自定义 v-model 修饰符"></a>自定义 v-model 修饰符</h2><p>创建一个自定义修饰符 capitalize，自动将 v-model 绑定输入字符串的第一个字母转为大写：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">v-model.capitalize</span>=<span class="string">&quot;myText&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// modelModifiers prop 包含了 capitalize 且其值为 true</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 因为它在模板中的 v-model 绑定 v-model.capitalize=&quot;myText&quot; 上被使用了</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> props = <span class="title function_">defineProps</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">modelValue</span>: <span class="title class_">String</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">modelModifiers</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">default</span>: <span class="function">() =&gt;</span> (&#123;&#125;) <span class="comment">// 默认值为空对象</span></span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">defineEmits</span>([<span class="string">&#x27;update:modelValue&#x27;</span>]);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 将首字母大写</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">emitValue</span>(<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> value = e.<span class="property">target</span>.<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span>(props.<span class="property">modelModifiers</span>.<span class="property">captialize</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        value = value.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + value.<span class="title function_">slice</span>(<span class="number">1</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">emit</span>(<span class="string">&#x27;update:modelValue&#x27;</span>, value);</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 每次 &lt;input /&gt; 元素触发 input 事件时触发 emitValue --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:value</span>=<span class="string">&quot;modelValue&quot;</span></span></span><br><span class="line"><span class="tag">        @<span class="attr">input</span>=<span class="string">&quot;emitValue&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="带多个不同参数的-v-model-修饰符"><a href="#带多个不同参数的-v-model-修饰符" class="headerlink" title="带多个不同参数的 v-model 修饰符"></a>带多个不同参数的 v-model 修饰符</h3><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">UserName</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-model:first-name.capitalize</span>=<span class="string">&quot;first&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-model:last-name.uppercase</span>=<span class="string">&quot;last&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> props = <span class="title function_">defineProps</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">firstName</span>: <span class="title class_">String</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">lastName</span>: <span class="title class_">String</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">firstNameModifiers</span>: &#123;  <span class="comment">// firstName + Modifiers</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">default</span>: <span class="function">() =&gt;</span> (&#123;&#125;) </span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">lastNameModifiers</span>: &#123;  <span class="comment">// lastName + Modifiers</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">default</span>: <span class="function">() =&gt;</span> (&#123;&#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">defineEmits</span>([<span class="string">&#x27;update:firstName&#x27;</span>, <span class="string">&#x27;update:lastName&#x27;</span>]);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(props.<span class="property">firstNameModifiers</span>); <span class="comment">// &#123; calitalize: true &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(props.<span class="property">lastNameModifiers</span>); <span class="comment">// &#123; uppercase: true &#125;</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>vue3 - 文档</category>
      </categories>
      <tags>
        <tag>vue3</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3 继承 attributes</title>
    <url>/2023/12/21/18-vue3%E7%BB%A7%E6%89%BFattributes/</url>
    <content><![CDATA[<h2 id="禁用-attributes-继承"><a href="#禁用-attributes-继承" class="headerlink" title="禁用 attributes 继承"></a>禁用 attributes 继承</h2><p>如果不想一个组件自动继承 attribute，可在组件选项中设置 <code>inheritAttrs: false</code></p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">defineOptions</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">inheritAttrs</span>: <span class="literal">false</span></span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>透传进来的 attribute 可在模版的表达式中用 $attrs 访问：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>attribute: &#123;&#123; $attrs &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>常见的需要禁用 attribute 继承的场景是：attribute 需要应用在根节点以外的其他元素。</p>
<p>比如：希望透传的 attribute 应用在内层的节点而非外层。</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;btn-wrapper&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&#x27;btn&#x27;</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">defineOptions</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">inheritAttrs</span>: <span class="literal">false</span></span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="多根节点的-attributes-继承"><a href="#多根节点的-attributes-继承" class="headerlink" title="多根节点的 attributes 继承"></a>多根节点的 attributes 继承</h2><p>需要显示绑定 $attrs，否则会有警告</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>...<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span>...<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="在-JS-中访问透传的-attributes"><a href="#在-JS-中访问透传的-attributes" class="headerlink" title="在 JS 中访问透传的 attributes"></a>在 JS 中访问透传的 attributes</h2><p>使用 useAttrs() API 访问组件的所有透传 attribute</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; useAttrs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> attrs = <span class="title function_">useAttrs</span>();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>但是这里的 attrs 对象不具有响应式，如有需要：</p>
<p>（1）可使用 prop；</p>
<p>（2）可使用 onUpdated() 在每次更新时获取最新的 attrs。</p>
]]></content>
      <categories>
        <category>vue3 - 文档</category>
      </categories>
      <tags>
        <tag>vue3</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue 插槽</title>
    <url>/2023/12/26/19-vue%E6%8F%92%E6%A7%BD/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>插槽内容可以为文本、模版、组件</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FancyButton</span>&gt;</span></span><br><span class="line">  Click me! <span class="comment">&lt;!-- 插槽内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">FancyButton</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;fancy-btn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span> <span class="comment">&lt;!-- 插槽出口 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>渲染结果：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;fancy-btn&quot;</span>&gt;</span>Click me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="默认内容"><a href="#默认内容" class="headerlink" title="默认内容"></a>默认内容</h2><p>子组件的 <code>&lt;slot&gt;&lt;/slot&gt;</code> 标签之间是默认值</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">slot</span>&gt;</span> <span class="comment">&lt;!-- 默认内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h2><p>当一个组件包含多个插槽出口时，需要使用 name 来给各个插槽分配唯一的 ID，没有提供 name 的插槽会隐式地命名为“default”。</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span> <span class="comment">&lt;!-- name 为 default --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;footer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>在父组件中，使用 v-slot 或者 # 加上插槽名，来指定插槽内容。</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BaseLayout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- header 插槽的内容 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">footer</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- footer 插槽的内容 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">BaseLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="动态插槽名"><a href="#动态插槽名" class="headerlink" title="动态插槽名"></a>动态插槽名</h2><p>可定义动态插槽名：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:</span>[<span class="attr">dynamicSlotName</span>]&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #[<span class="attr">dynamicSlotName</span>]&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h2><p>可以向插槽出口传递 attributes</p>
<h3 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h3><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:text</span>=<span class="string">&quot;message&quot;</span> <span class="attr">:count</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">v-slot</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; slotProps.text &#125;&#125; &#123;&#123; slotProps.count &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 或者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; text, count &#125;&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; text &#125;&#125; &#123;&#123; count &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="具名插槽-1"><a href="#具名插槽-1" class="headerlink" title="具名插槽"></a>具名插槽</h3><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">header</span>=<span class="string">&quot;headerProps&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; headerProps &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 不缩写 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;defaultProps&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; defaultProps &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">footer</span>=<span class="string">&quot;footerProps&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; footerProps &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;header&quot;</span> <span class="attr">:msg1</span>=<span class="string">&quot;hello1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">:msg2</span>=<span class="string">&quot;hello2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span> <span class="comment">&lt;!-- name 为 default --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;header&quot;</span> <span class="attr">:msg3</span>=<span class="string">&quot;hello3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>vue - 文档</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3 依赖注入</title>
    <url>/2023/12/28/20-vue3%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h2 id="props-逐级透传"><a href="#props-逐级透传" class="headerlink" title="props 逐级透传"></a>props 逐级透传</h2><p>深层子组件需要较远的祖先组件中的部分数据，使用 props 逐级传递很麻烦：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cn.vuejs.org/assets/prop-drilling.FyV2vFBP.png"
                      
                >


<h2 id="provide（提供）"><a href="#provide（提供）" class="headerlink" title="provide（提供）"></a>provide（提供）</h2><p>为组件后代提供数据，使用 provide() 函数：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; provide &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">provide</span>(<span class="comment">/* 注入名 */</span><span class="string">&#x27;message&#x27;</span>, <span class="comment">/* 注入值 */</span><span class="string">&#x27;value&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>vue3 - 文档</category>
      </categories>
      <tags>
        <tag>vue3</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器输入url后发生了什么</title>
    <url>/2024/10/10/21-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h2 id="1-URL解析"><a href="#1-URL解析" class="headerlink" title="1. URL解析"></a>1. URL解析</h2><p>用户输入的URL（例如 <code>https://www.example.com/index.html</code>）首先被浏览器解析，该过程包括：</p>
<ul>
<li>提取协议（如HTTP或HTTPS）</li>
<li>主机名（如<a class="link"   href="http://www.example.com)/" >www.example.com） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>端口</li>
<li>路径（如&#x2F;index.html）</li>
<li>查询参数</li>
<li>锚点</li>
</ul>
<p>详见：</p>
<ul>
<li><a href="./22-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90url%E8%BF%87%E7%A8%8B.md">浏览器解析url过程</a></li>
</ul>
<h2 id="2-DNS-查询"><a href="#2-DNS-查询" class="headerlink" title="2. DNS 查询"></a>2. DNS 查询</h2><p>浏览器需要将域名转换为IP地址，以便进行网络通信。<br>此时，浏览器会查找本地DNS缓存，如果没有找到，就会向系统的DNS服务器发送请求。DNS服务器将返回对应的IP地址。</p>
<p>详见：</p>
<ul>
<li><a href="./25-DNS.md">DNS</a></li>
<li><a href="./26-CDN.md">CDN</a></li>
</ul>
<h2 id="3-TCP连接"><a href="#3-TCP连接" class="headerlink" title="3. TCP连接"></a>3. TCP连接</h2><p>一旦获得了IP地址，浏览器通过TCP（传输控制协议）建立与目标服务器的连接。<br>对于HTTPS请求，还需要进行SSL&#x2F;TLS握手，以确保安全性。这一过程包括：</p>
<ul>
<li>客户端向服务器发送连接请求</li>
<li>服务器确认并建立连接</li>
<li>进行SSL&#x2F;TLS证书验证以及协商加密算法</li>
</ul>
<h2 id="4-发送HTTP请求"><a href="#4-发送HTTP请求" class="headerlink" title="4. 发送HTTP请求"></a>4. 发送HTTP请求</h2><p>连接建立后，浏览器构建一个HTTP请求并发送到服务器。这个请求包含：</p>
<ul>
<li>请求行（例如 GET &#x2F;index.html HTTP&#x2F;1.1）</li>
<li>请求头（例如用户代理、接受类型等信息）</li>
<li>请求体（对于POST请求，可能包含数据）</li>
</ul>
<h2 id="5-服务器处理请求"><a href="#5-服务器处理请求" class="headerlink" title="5. 服务器处理请求"></a>5. 服务器处理请求</h2><p>服务器接收到请求后，会根据请求的内容进行处理。它可能会查找文件、访问数据库或者执行其他逻辑，最终生成一个HTTP响应。</p>
<h2 id="6-接收HTTP响应"><a href="#6-接收HTTP响应" class="headerlink" title="6. 接收HTTP响应"></a>6. 接收HTTP响应</h2><p>服务器发送回HTTP响应，包含状态码（如200表示成功，404表示未找到），响应头（如内容类型、内容长度等）和响应体（实际请求资源的内容，如HTML文档）。</p>
<h2 id="7-渲染页面"><a href="#7-渲染页面" class="headerlink" title="7. 渲染页面"></a>7. 渲染页面</h2><p>浏览器接收响应后，进行以下步骤：</p>
<ul>
<li>解析HTML文档，构建DOM树</li>
<li>如果遇到CSS文件，发起请求以获取样式，并构建CSSOM树</li>
<li>合并DOM和CSSOM，生成渲染树</li>
<li>根据渲染树计算布局，决定每个元素的位置和大小</li>
<li>绘制页面，将内容绘制到屏幕上</li>
</ul>
<h2 id="8-处理JavaScript"><a href="#8-处理JavaScript" class="headerlink" title="8. 处理JavaScript"></a>8. 处理JavaScript</h2><p>如果HTML中包含JavaScript代码，浏览器会逐步执行这些脚本。<br>JavaScript可以操作DOM，改变页面内容，进行AJAX请求等。</p>
<h2 id="9-其它资源加载"><a href="#9-其它资源加载" class="headerlink" title="9. 其它资源加载"></a>9. 其它资源加载</h2><p>如果页面中包含其他资源（如图片、音频、视频），浏览器会并行请求这些资源，直至全部加载完成。</p>
<h2 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h2><p>假设用户在浏览器中输入<a class="link"   href="https://www.example.com/index.html%EF%BC%8C%E6%95%B4%E4%B8%AA%E8%BF%87%E7%A8%8B%E5%A6%82%E4%B8%8B%EF%BC%9A" >https://www.example.com/index.html，整个过程如下： <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<ol>
<li>浏览器解析出协议为HTTPS，域名为<a class="link"   href="http://www.example.com./" >www.example.com。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>发送DNS请求，获得IP地址93.184.216.34。</li>
<li>与该IP地址建立TCP连接，并进行TLS握手。</li>
<li>发送GET请求，请求&#x2F;index.html资源。</li>
<li>服务器处理请求，返回200状态及index.html内容。</li>
<li>浏览器解析HTML，构建DOM树，并抓取相关的CSS和JavaScript文件。</li>
<li>最终呈现完整的网页给用户。</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络 - 综合</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>计算机网络</tag>
        <tag>url</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器解析url过程</title>
    <url>/2024/10/14/22-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90url%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="1-URL的格式"><a href="#1-URL的格式" class="headerlink" title="1. URL的格式"></a>1. URL的格式</h2><p>协议表示浏览器应当使用的访问方法，包括：”http：””ftp：””file：””mailto：”。<br>比如访问Web服务器使用HTTP协议，访问本地服务器使用FILE协议，访问FTP服务器使用FTP协议。</p>
<p>图1 列举了常见的几种URL，访问自标不同，URL的写法也不同。<br>例如在访问Web服务器和FTP服务器时，URL中包含服务器的域名和要访问的文件的路径名等，而发邮件的URL则包含收件人的邮件地址。此外，URL还可能包含用户名、密码、服务器端口号等信息。</p>
<p>图1.1：URL的各种格式<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pica.zhimg.com/80/v2-e72ee2cb036bb9fa21e2817228a43e42_1440w.webp?source=2c26e567"
                      alt="图1.1"
                ></p>
<h2 id="2-URL的组成元素"><a href="#2-URL的组成元素" class="headerlink" title="2. URL的组成元素"></a>2. URL的组成元素</h2><p>图1.2：Web浏览器解析url的过程<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://picx.zhimg.com/80/v2-42f11c5b60c90af055cc232d71d15fd0_1440w.webp?source=2c26e567"
                      alt="图1.2"
                ></p>
<p>图1.3：路径名为&#x2F;dir&#x2F;file1.html的文件<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic1.zhimg.com/80/v2-204e5983725b0bf4ea61bef9c66d8d99_1440w.webp?source=2c26e567"
                      alt="图1.3"
                ></p>
<h2 id="3-省略文件名的情况"><a href="#3-省略文件名的情况" class="headerlink" title="3. 省略文件名的情况"></a>3. 省略文件名的情况</h2><h4 id="a-以”-“结尾：lab-glasscom-com-dir"><a href="#a-以”-“结尾：lab-glasscom-com-dir" class="headerlink" title="(a) 以”&#x2F;“结尾：lab.glasscom.com/dir/"></a>(a) 以”&#x2F;“结尾：<code>lab.glasscom.com/dir/</code></h4><p>以”&#x2F;dir&#x2F;“结尾代表&#x2F;dir&#x2F;后面本应该有的文件名被省略了。<br>我们会在服务器上事先设置好文件名省略时要访问的默认文件名，大多情况下是index.html或者default.htm。因此，像前面这样省略文件名时，服务器就会访问其中的默认文件。</p>
<h4 id="b-域名-”-“：lab-glasscom-com"><a href="#b-域名-”-“：lab-glasscom-com" class="headerlink" title="(b) 域名+”&#x2F;“：lab.glasscom.com/"></a>(b) 域名+”&#x2F;“：<code>lab.glasscom.com/</code></h4><p>以”域名+&#x2F;“结尾表示访问一个名叫”&#x2F;“的目录（根目录）；<br>由于省略了文件名，会访问&#x2F;index.html之类的文件。</p>
<h4 id="c-域名：lab-glasscom-com"><a href="#c-域名：lab-glasscom-com" class="headerlink" title="(c) 域名：lab.glasscom.com"></a>(c) 域名：<code>lab.glasscom.com</code></h4><p>以域名结尾时，就代表访问根目录下事先设置的默认文件，也就是&#x2F;index.html之类的文件。</p>
<h4 id="d-路径结尾无”-“：lab-glasscom-com-whatisthis"><a href="#d-路径结尾无”-“：lab-glasscom-com-whatisthis" class="headerlink" title="(d) 路径结尾无”&#x2F;“：lab.glasscom.com/whatisthis"></a>(d) 路径结尾无”&#x2F;“：<code>lab.glasscom.com/whatisthis</code></h4><p><strong>先文件，后目录。</strong><br>如果Web服务器上存在名为whatisthis的文件，则将whatisthis作为文件名来处理；<br>如果存在名为whatisthis的目录，则将whatisthis作为目录名来处理。</p>
<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><ul>
<li>URL：Uniform Resource Locator，统一资源定位符。</li>
<li>FTP：File Transfer Protocol，文件传送协议。是在上传、下载文件时使用的协议（也指使用FTP协议传送文件的程序）。</li>
<li>HTTP：Hypertext Transfer Protocol，超文本传送协议。</li>
<li>根目录：”&#x2F;“目录 表示最顶层的目录 “根目录”。</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络 - url</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>计算机网络</tag>
        <tag>url</tag>
      </tags>
  </entry>
  <entry>
    <title>投放链接防重定向</title>
    <url>/2024/10/14/23-%E6%8A%95%E6%94%BE%E9%93%BE%E6%8E%A5%E9%98%B2%E9%87%8D%E5%AE%9A%E5%90%91/</url>
    <content><![CDATA[<p>为了防止浏览器进行多次重定向，影响页面性能，投放链接应该以 https 开头，以 ‘&#x2F;‘ 结尾<br>不用：<code>http://lc.jr.jd.com/finance/fund/fundinvest/investZone</code><br>使用：<code>https://lc.jr.jd.com/finance/fund/fundinvest/investZone/</code></p>
<h2 id="不正确投放链接"><a href="#不正确投放链接" class="headerlink" title="不正确投放链接"></a>不正确投放链接</h2><p>访问<code>http://lc.jr.jd.com/finance/fund/fundinvest/investZone</code>的请求过程：</p>
<h3 id="一、有缓存"><a href="#一、有缓存" class="headerlink" title="一、有缓存"></a>一、有缓存</h3><h4 id="1-协议变为-https"><a href="#1-协议变为-https" class="headerlink" title="1. 协议变为 https"></a>1. 协议变为 https</h4><p>浏览器把协议从http替换为https（使用307重定向，保证不改变请求方法GET）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/23/1.png"
                      alt="图1"
                ></p>
<h4 id="2-本地缓存获取IP"><a href="#2-本地缓存获取IP" class="headerlink" title="2. 本地缓存获取IP"></a>2. 本地缓存获取IP</h4><p>浏览器在本地缓存中获取到IP（远端地址）；重定向到补充末尾”&#x2F;“的规范URL</p>
<ul>
<li>返回304响应码，该GET请求的request header中包含（与缓存相关的）条件参数</li>
<li>使用path相对路径进行重定向，因为nginx在server中设置了<code>absolute_redirect off</code></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/23/2.png"
                      alt="图2"
                ></p>
<p>请求头中的条件参数（If-xxx）：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/23/3.png"
                      alt="图3"
                ></p>
<h4 id="3-请求资源"><a href="#3-请求资源" class="headerlink" title="3. 请求资源"></a>3. 请求资源</h4><p>浏览器使用上述请求从本地缓存中获取的IP，向远端服务器GET资源，并成功<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/23/4.png"
                      alt="图4"
                ></p>
<h3 id="二、无缓存"><a href="#二、无缓存" class="headerlink" title="二、无缓存"></a>二、无缓存</h3><p>无缓存时，第2步变为使用301重定向</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/23/5.png"
                      alt="图5"
                ></p>
<h2 id="正确投放链接"><a href="#正确投放链接" class="headerlink" title="正确投放链接"></a>正确投放链接</h2><p>访问<code>https://lc.jr.jd.com/finance/fund/fundinvest/investZone/</code>的请求过程：</p>
<h3 id="一、有缓存-1"><a href="#一、有缓存-1" class="headerlink" title="一、有缓存"></a>一、有缓存</h3><p>服务器返回304响应码，表示可以使用客户端中之前缓存的副本</p>
<ul>
<li>该请求的request header中包含「与缓存相关」的条件参数</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/23/6.png"
                      alt="图6"
                ></p>
<h3 id="二、无缓存-1"><a href="#二、无缓存-1" class="headerlink" title="二、无缓存"></a>二、无缓存</h3><p>普通请求，响应码为200</p>
]]></content>
      <categories>
        <category>计算机网络 - url</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>计算机网络</tag>
        <tag>url</tag>
        <tag>实践问题</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器缓存与304状态码</title>
    <url>/2024/10/16/24-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E4%B8%8E304%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    <content><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>出现304状态码的条件</p>
<ul>
<li>不禁止缓存</li>
<li>不检查本地缓存是否过期；或者检查本地缓存、且未过期</li>
<li>响应头有<code>Etag</code>（则下次的请求头中有<code>If-None-Match</code>）；或者响应头有<code>Last-Modified</code>（则下次的请求头中有<code>If-Modified-since</code>）</li>
<li>缓存有效</li>
</ul>
<p>注意：下图中的<code>Etag</code>和<code>Last-Modified</code>之间不存在先后顺序</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/22/15fe1d6fc1269a86~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png"
                      alt="图1"
                ></p>
<h2 id="一、304请求的交互过程"><a href="#一、304请求的交互过程" class="headerlink" title="一、304请求的交互过程"></a>一、304请求的交互过程</h2><p>假设用户通过浏览器访问某静态资源（比如图片image.png），且该资源之前已被浏览器缓存，现在分析两次请求的交互过程。</p>
<h3 id="第一次请求（初始加载）"><a href="#第一次请求（初始加载）" class="headerlink" title="第一次请求（初始加载）"></a>第一次请求（初始加载）</h3><h4 id="1、浏览器发送请求"><a href="#1、浏览器发送请求" class="headerlink" title="1、浏览器发送请求"></a>1、浏览器发送请求</h4><p>用户在浏览器中输入 URL，浏览器向服务器发送 GET 请求，获取 image.png。<br>请求头可能如下：</p>
<div class="highlight-container" data-rel="Http"><figure class="iseeu highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/image.png</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example.com</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 ...</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>image/webp,image/apng,image/*,*/*;q=0.8</span><br></pre></td></tr></table></figure></div>

<h4 id="2、服务器响应"><a href="#2、服务器响应" class="headerlink" title="2、服务器响应"></a>2、服务器响应</h4><p>服务器处理请求，并返回 200 OK 响应，同时附带以下响应头：</p>
<div class="highlight-container" data-rel="Http"><figure class="iseeu highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>image/png</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>123456</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Mon, 01 Jan 2023 12:00:00 GMT</span><br><span class="line"><span class="attribute">ETag</span><span class="punctuation">: </span>&quot;abc123&quot;</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=31536000</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>Last-Modified</code>：表示资源最后修改的时间</li>
<li><code>ETag</code>：资源的唯一标识符</li>
<li><code>Cache-Control</code>：指示浏览器可以缓存该资源的时长</li>
</ul>
<h4 id="3、浏览器缓存资源"><a href="#3、浏览器缓存资源" class="headerlink" title="3、浏览器缓存资源"></a>3、浏览器缓存资源</h4><p>浏览器接收响应后，将image.png缓存到本地，并根据响应头信息（如<code>Last-Modified</code>和<code>ETag</code>）记录该资源的状态</p>
<h3 id="第二次请求（缓存验证）"><a href="#第二次请求（缓存验证）" class="headerlink" title="第二次请求（缓存验证）"></a>第二次请求（缓存验证）</h3><h4 id="1、浏览器发送条件请求"><a href="#1、浏览器发送条件请求" class="headerlink" title="1、浏览器发送条件请求"></a>1、浏览器发送条件请求</h4><p>当用户再次访问同一资源，浏览器会检查缓存，如果该资源仍然有效，就发送一个带条件的 GET 请求到服务器，请求头如下：</p>
<div class="highlight-container" data-rel="Http"><figure class="iseeu highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/image.png</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example.com</span><br><span class="line"><span class="attribute">If-Modified-Since</span><span class="punctuation">: </span>Mon, 01 Jan 2023 12:00:00 GMT</span><br><span class="line"><span class="attribute">If-None-Match</span><span class="punctuation">: </span>&quot;abc123&quot;</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 ...</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>If-Modified-Since</code>：告诉服务器，如果在指定日期之后资源被修改，则返回新的资源</li>
<li><code>If-None-Match</code>：告诉服务器，如果资源的<code>ETag</code>与提供的值不匹配，则返回新的资源</li>
</ul>
<h4 id="2、服务器处理请求"><a href="#2、服务器处理请求" class="headerlink" title="2、服务器处理请求"></a>2、服务器处理请求</h4><p>服务器接收到条件请求后，检查该资源的状态：<br>如果资源自<code>Last-Modified</code>时间以来未被修改，且<code>ETag</code>匹配，那么服务器不会返回新的内容，而是返回 304 Not Modified。</p>
<p>服务器返回如下响应：</p>
<div class="highlight-container" data-rel="Http"><figure class="iseeu highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">304</span> Not Modified</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Mon, 02 Jan 2023 12:00:00 GMT</span><br></pre></td></tr></table></figure></div>

<p><strong>注意：304 响应没有消息体，通常只包含必要的状态码和一些响应头。</strong></p>
<h4 id="3、浏览器处理304响应"><a href="#3、浏览器处理304响应" class="headerlink" title="3、浏览器处理304响应"></a>3、浏览器处理304响应</h4><p>当浏览器接收到 304 Not Modified 响应时，了解到之前缓存的 image.png 仍然有效，因此直接使用缓存中的版本，而无需重新下载。</p>
<h2 id="二、详细讨论"><a href="#二、详细讨论" class="headerlink" title="二、详细讨论"></a>二、详细讨论</h2><h3 id="1、是否禁止缓存"><a href="#1、是否禁止缓存" class="headerlink" title="1、是否禁止缓存"></a>1、是否禁止缓存</h3><p><strong>禁止缓存</strong>：缓存中不得存储任何关于客户端请求和服务端响应的内容，客户端每次发起的请求都会下载完整的响应内容</p>
<p>在请求头中，<code>Cache-Control: no-store</code> 与 <code>Pragma: no-cache</code> 都可以禁止缓存</p>
<ul>
<li><code>Pragma: no-cache</code> 可用于 <code>http 1.0</code> 和 <code>http 1.1</code></li>
<li><code>Cache-Control: no-store</code> 只能用于 <code>http 1.1</code></li>
</ul>
<h3 id="2、是否检查本地副本是否过期"><a href="#2、是否检查本地副本是否过期" class="headerlink" title="2、是否检查本地副本是否过期"></a>2、是否检查本地副本是否过期</h3><p>由 <code>Cache-Control</code> 的 <code>no-cache</code> 和 <code>must-revalidate</code> 两个可选值控制</p>
<ul>
<li><code>no-cache</code>：告诉浏览器、缓存服务器，不管本地副本是否过期，<strong>使用资源副本前，必须到源服务器进行副本有效性校验</strong></li>
<li><code>must-revalidate</code>：告诉浏览器、缓存服务器，<strong>本地副本过期前，可使用本地副本</strong>；本地副本一旦过期，必须去源服务器进行有效性校验（如果没有该属性，若发生网络问题等情况，客户端可能直接使用本地缓存，而不会向服务器发起校验）</li>
</ul>
<h3 id="3、检查本地副本是否过期"><a href="#3、检查本地副本是否过期" class="headerlink" title="3、检查本地副本是否过期"></a>3、检查本地副本是否过期</h3><p>与「缓存的过期机制」相关的响应头字段（优先级依次降低）：</p>
<h4 id="（1）max-age"><a href="#（1）max-age" class="headerlink" title="（1）max-age=&lt;seconds&gt;"></a>（1）<code>max-age=&lt;seconds&gt;</code></h4><p>表示资源能被缓存的最大时间，通常和 <code>must-revalidate</code> 一起使用。</p>
<p>本地副本过期前，可使用本地副本，缓存时间为60秒；<br>如果本地副本已过期，则重新向服务器请求（要求必须进行有效性校验）：</p>
<div class="highlight-container" data-rel="Http"><figure class="iseeu highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=60, must-revalidate</span><br></pre></td></tr></table></figure></div>

<p>共享缓存（如代理服务器）将在60秒后失效，而个人用户的缓存则在120秒后失效：</p>
<div class="highlight-container" data-rel="Http"><figure class="iseeu highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=120, smax-age=60</span><br></pre></td></tr></table></figure></div>

<h4 id="（2）Expires"><a href="#（2）Expires" class="headerlink" title="（2）Expires"></a>（2）<code>Expires</code></h4><p>表示资源的过期时间。<br>如果无<code>max-age</code>但有<code>Expires</code>，通过比较<code>Expires</code>和<code>Date</code>的值来判断是否缓存有效：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/24/16569eec71a24236~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png"
                      alt="图2"
                ></p>
<h4 id="（3）Last-Modified"><a href="#（3）Last-Modified" class="headerlink" title="（3）Last-Modified"></a>（3）<code>Last-Modified</code></h4><p>表示资源的最后修改时间。<br>如果无<code>max-age</code>和<code>expires</code>但有<code>Last-Modified</code>，缓存的时长等于</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line">(Date - Last-Modified) / <span class="number">10</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/24/16569eec6d61c11a~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png"
                      alt="图3"
                ></p>
<p><strong>如果都没有，浏览器将不会对该需求进行缓存。</strong></p>
<h3 id="4、本地副本没过期"><a href="#4、本地副本没过期" class="headerlink" title="4、本地副本没过期"></a>4、本地副本没过期</h3><p>直接从缓存中读取资源，并返回200状态码。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/24/16569eec7215656e~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png"
                      alt="图4"
                ></p>
<h3 id="5、本地副本已过期"><a href="#5、本地副本已过期" class="headerlink" title="5、本地副本已过期"></a>5、本地副本已过期</h3><p>进行「源服务器进行有效性校验」的前期准备：</p>
<h4 id="（1）If-None-Match"><a href="#（1）If-None-Match" class="headerlink" title="（1）If-None-Match"></a>（1）If-None-Match</h4><p>首先，在请求头里寻找<code>If-None-Match</code>字段（其值为服务器上次返回的<code>ETag</code>响应头的值）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/24/16569eec71ddeec1~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png"
                      alt="图5"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/24/16569eec89fb1991~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png"
                      alt="图6"
                ></p>
<h4 id="（2）If-Modified-Since"><a href="#（2）If-Modified-Since" class="headerlink" title="（2）If-Modified-Since"></a>（2）If-Modified-Since</h4><p>如果没有<code>If-None-Match</code>，则在请求头中寻找<code>If-Modified-Since</code>字段（其值为服务器上次返回的<code>Last-Modified</code>响应头中的日期值）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/24/16569eec8a29d072~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png"
                      alt="图7"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/24/16569eed35bf1c0e~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png"
                      alt="图8"
                ></p>
<p>如果<code>If-None-Match</code>与<code>If-Modified-Since</code>都没有，则直接向服务器请求数据</p>
<h3 id="6、去源服务器进行有效性校验"><a href="#6、去源服务器进行有效性校验" class="headerlink" title="6、去源服务器进行有效性校验"></a>6、去源服务器进行有效性校验</h3><p>如果请求头中有<code>If-None-Match</code>或<code>If-Modified-Since</code>，则到源服务器进行有效性校验。<br>如果源服务器资源没有变化，则返回304；如果有变化，则返回200。</p>
<h3 id="7、上述流程的总结图"><a href="#7、上述流程的总结图" class="headerlink" title="7、上述流程的总结图"></a>7、上述流程的总结图</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/24/16569eed5984fb4b~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png"
                      alt="图9"
                ></p>
<h2 id="三、意义"><a href="#三、意义" class="headerlink" title="三、意义"></a>三、意义</h2><ul>
<li><strong>避免了不必要的数据传输，提高了网络效率和用户体验</strong>；</li>
<li><strong>在频繁访问相同资源的情况下，可以显著降低带宽消耗和服务器负载</strong>。</li>
</ul>
<h2 id="四、补充"><a href="#四、补充" class="headerlink" title="四、补充"></a>四、补充</h2><h3 id="私有缓存和公共缓存"><a href="#私有缓存和公共缓存" class="headerlink" title="私有缓存和公共缓存"></a>私有缓存和公共缓存</h3><p>在<code>Cache-Control</code>还有两个值：<code>private</code>与<code>public</code>：</p>
<ul>
<li>public 表示该响应可被任何中间人（比如中间代理、CDN等）缓存。</li>
<li>private 表示该响应是专用于某单个用户的，不能被中间人缓存，应该用于浏览器的私有缓存中，比如：带有HTTP验证信息（帐号密码）的页面 或 某些特定影响状态码的页面*。</li>
</ul>
<p>“某些特定影响状态码的页面”指具有特殊语义的状态码，比如：</p>
<h5 id="（1）401-Unauthorized"><a href="#（1）401-Unauthorized" class="headerlink" title="（1）401 Unauthorized"></a>（1）401 Unauthorized</h5><p>当访问受保护的资源时，如果用户未通过身份验证，服务器可能返回401状态码。<br>此时通常只应允许客户端缓存该响应，因为该内容对其他用户是不适用的。</p>
<h4 id="（2）403-Forbidden"><a href="#（2）403-Forbidden" class="headerlink" title="（2）403 Forbidden"></a>（2）403 Forbidden</h4><p>表示服务器理解请求但拒绝执行它。<br>在某些情况下，公共内容也可能出于安全考虑而不被中间缓存，因此可标记为 private。</p>
<h5 id="（2）404-Not-Found"><a href="#（2）404-Not-Found" class="headerlink" title="（2）404 Not Found"></a>（2）404 Not Found</h5><p>如果某资源不存在，虽然它是公开的，但可能在某些应用场景下不希望被中间缓存。</p>
<h5 id="（3）500-Internal-Server-Error"><a href="#（3）500-Internal-Server-Error" class="headerlink" title="（3）500 Internal Server Error"></a>（3）500 Internal Server Error</h5><p>表示服务器出现了问题，返回的内容可能不稳定，因此不应被中间缓存。</p>
<h4 id="private-使用场景"><a href="#private-使用场景" class="headerlink" title="private 使用场景"></a>private 使用场景</h4><h5 id="（1）用户特定数据"><a href="#（1）用户特定数据" class="headerlink" title="（1）用户特定数据"></a>（1）用户特定数据</h5><p>如个性化推荐、用户历史记录等，仅对特定用户合适，其他用户无法访问，即便返回成功状态，为了保护用户隐私，建议使用 private。</p>
<h5 id="（2）临时性数据"><a href="#（2）临时性数据" class="headerlink" title="（2）临时性数据"></a>（2）临时性数据</h5><p>如操作结果、表单提交后给予反馈的信息等，这类信息通常只需当前用户知道，对其他用户无意义，适合标记为 private。</p>
]]></content>
      <categories>
        <category>计算机网络 - 状态码</category>
        <category>计算机网络 - 浏览器</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>计算机网络</tag>
        <tag>url</tag>
        <tag>状态码</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS</title>
    <url>/2024/10/18/25-DNS/</url>
    <content><![CDATA[<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p>DNS 是：</p>
<ul>
<li>一个使得主机能够查询分布式数据库的<strong>应用层协议</strong></li>
<li>一个由分层的 DNS 服务器实现的<strong>分布式数据库</strong></li>
</ul>
<p>（1）DNS 是一个分布式数据库，整个 DNS 系统由分散在世界各地的很多 DNS 服务器组成，每台服务器上都保存了一些数据，可以让我们最终查到主机名对应的 IP。</p>
<p>（2）DNS 是一个应用层协议，发送一个包含所查询主机名的请求，它会返回该主机名对应的 IP。</p>
<p><strong>分布式：</strong> 世界上没有一台 DNS 服务器拥有因特网上所有主机的映射，每台 DNS 只负责部分映射。</p>
<h2 id="二、层次"><a href="#二、层次" class="headerlink" title="二、层次"></a>二、层次</h2><p>DNS 服务器有 3 种类型：</p>
<ul>
<li>根 DNS 服务器</li>
<li>顶级域（Top-Level Domain, TLD）</li>
<li>DNS 服务器</li>
<li>权威 DNS 服务器</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img1.baidu.com/it/u=2736501838,3539264290&fm=253&fmt=auto&app=138&f=PNG?w=722&h=408"
                      alt="图1"
                ></p>
<h3 id="1、根-DNS-服务器"><a href="#1、根-DNS-服务器" class="headerlink" title="1、根 DNS 服务器"></a>1、根 DNS 服务器</h3><p>比如 <code>www.baidu.com</code>，其完整写法是 <code>www.baidu.com.</code>，最后的这个 <code>.</code> 就是根域名。</p>
<p>通过询问根 DNS 服务器，可以知道它的下一级，也就是顶级域 DNS 服务器的 IP 是多少，从而继续向顶级域 DNS 服务器发起查询请求。</p>
<h3 id="2、顶级域-DNS-服务器"><a href="#2、顶级域-DNS-服务器" class="headerlink" title="2、顶级域 DNS 服务器"></a>2、顶级域 DNS 服务器</h3><p>除了前面提到的 <code>com</code> 是顶级域名，常见的顶级域名还有 <code>cn</code>、<code>org</code>、<code>edu</code> 等。顶级域 DNS 服务器，也就是 TLD，提供了它的下一级，也就是权威 DNS 服务器的 IP 地址。</p>
<h3 id="3、权威-DNS-服务器"><a href="#3、权威-DNS-服务器" class="headerlink" title="3、权威 DNS 服务器"></a>3、权威 DNS 服务器</h3><p>权威 DNS 服务器可以返回主机和IP之间的最终映射。</p>
<h2 id="三、本地-DNS-服务器"><a href="#三、本地-DNS-服务器" class="headerlink" title="三、本地 DNS 服务器"></a>三、本地 DNS 服务器</h2><p>每个 ISP（Internet Server Provider, 网络服务提供商）都有一台本地 DNS 服务器，比如一个居民区的 ISP、一个大学的 ISP、一个机构的 ISP，都有一台或多台本地 DNS 服务器。</p>
<p>当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，<strong>本地 DNS 服务器起着代理的作用，并负责将该请求转发到 DNS 服务器层次结构中。</strong></p>
<p>严格来说，本地 DNS 服务器不属于 DNS 的层次结构。</p>
<h2 id="四、递归查询、迭代查询"><a href="#四、递归查询、迭代查询" class="headerlink" title="四、递归查询、迭代查询"></a>四、递归查询、迭代查询</h2><p>如下图，假设主机 m.n.com 想要获取主机 a.b.com 的 IP 地址，会经过以下几个步骤：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bb796a3045e409aabb0f89ad40d3fad~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.webp"
                      alt="图2"
                ></p>
<p>（1）首先，主机 m.n.com 向它的本地 DNS 服务器发送一个 DNS 查询报文，包含期待被转换的主机名 a.b.com；</p>
<p>（2）本地 DNS 服务器将该报文转发到根 DNS 服务器；</p>
<p>（3）该根 DNS 服务器注意到 com 前缀，向本地 DNS 服务器返回 com 对应的顶级域 DNS 服务器（TLD）的 IP 地址列表。</p>
<p>（4）本地 DNS 服务器则向其中一台 TLD 服务器发送查询报文；</p>
<p>（5）该 TLD 服务器注意到 b.com 前缀，向本地 DNS 服务器返回权威 DNS 服务器的 IP 地址。</p>
<p>（6）本地 DNS 服务器又向其中一台权威服务器发送查询报文；</p>
<p>（7）该权威服务器返回了 a.b.com 的 IP 地址；</p>
<p>（8）本地 DNS 服务器将 a.b.com 跟 IP 地址的映射返回给主机 m.n.com，m.n.com 就可以用该 IP 向 a.b.com 发送请求了。</p>
<h3 id="1、递归"><a href="#1、递归" class="headerlink" title="1、递归"></a>1、递归</h3><p>主机 m.n.com 向本地 DNS 服务器 dns.n.com 发出的查询就是递归查询，这个查询是主机 m.n.com 以自己的名义向本地 DNS 服务器请求想要的 IP 映射，并且本地 DNS 服务器直接返回映射结果给到主机。</p>
<h3 id="2、迭代"><a href="#2、迭代" class="headerlink" title="2、迭代"></a>2、迭代</h3><p>而后继的三个查询是迭代查询，包括本地 DNS 服务器向根 DNS 服务器发送查询请求、本地 DNS 服务器向 TLD 服务器发送查询请求、本地 DNS 服务器向权威 DNS 服务器发送查询请求，所有的请求都是由本地 DNS 服务器发出，所有的响应都是直接返回给本地 DNS 服务器。</p>
<h3 id="3、另一种-DNS-查询"><a href="#3、另一种-DNS-查询" class="headerlink" title="3、另一种 DNS 查询"></a>3、另一种 DNS 查询</h3><p>从理论上讲，任何 DNS 查询既可以是递归的，也可以是迭代的。下图的所有查询就都是递归的，不包含迭代。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd1422f81c2647a19cde72cb9694bc89~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.webp"
                      alt="图3"
                ></p>
<h4 id="TLD-一定知道权威-DNS-服务器的-IP-地址吗？"><a href="#TLD-一定知道权威-DNS-服务器的-IP-地址吗？" class="headerlink" title="TLD 一定知道权威 DNS 服务器的 IP 地址吗？"></a>TLD 一定知道权威 DNS 服务器的 IP 地址吗？</h4><p>不一定，有时 TLD 只是知道中间的某个 DNS 服务器，再由这个中间 DNS 服务器去找到权威 DNS 服务器。</p>
<p>这种情况不仅增加了延迟，还使得网络上需要传输更多的数据包，也会产生更多的 DNS 报文。</p>
<h2 id="五、DNS-优化"><a href="#五、DNS-优化" class="headerlink" title="五、DNS 优化"></a>五、DNS 优化</h2><h3 id="1、DNS-缓存"><a href="#1、DNS-缓存" class="headerlink" title="1、DNS 缓存"></a>1、DNS 缓存</h3><p>DNS 存在多级缓存，从离浏览器的距离排序，有以下几种：<br>浏览器缓存，系统缓存，路由器缓存，IPS 服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。</p>
<ul>
<li>在chrome浏览器中输入 <code>chrome://net-internals/#dns</code>，可以看到chrome浏览器的DNS缓存</li>
<li>系统缓存主要存在 <code>/etc/hosts</code> （Linux系统）中</li>
</ul>
<p>缓存并不是永久的，每一条映射记录都有对应的生存时间，一旦过了生存时间，该条记录就会从缓存移出。</p>
<h3 id="2、DNS-负载均衡"><a href="#2、DNS-负载均衡" class="headerlink" title="2、DNS 负载均衡"></a>2、DNS 负载均衡</h3><p>访问某网站的时候，每次响应的很可能不是同一个服务器（IP 地址不同），因为一般公司都有多台服务器来支撑访问，而 DNS 会返回一个合适的机器的 IP 给用户（<strong>根据每台机器的负载量、该机器和用户地理位置的距离等</strong>），这就是 DNS 负载均衡。</p>
]]></content>
      <categories>
        <category>计算机网络 - DNS</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>计算机网络</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>CDN</title>
    <url>/2024/10/29/26-CDN/</url>
    <content><![CDATA[<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>CDN 全称为 “Content Delivery Network”，即内容分发网络。<br>CDN 是一种特殊的 DNS服务器。</p>
<h2 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h2><p>当使用域名访问某一个网站时（比如访问 <code>www.baidu.com</code>），分为两步：</p>
<ul>
<li>首先解析出该域名所对应的 IP地址（DNS 域名解析）</li>
<li>然后将 Http请求包 路由到 IP地址 所对应的服务器</li>
</ul>
<p>（注：IP地址和网卡相绑定，一个服务器可以有多个网卡，即可能有多个IP地址）</p>
<h3 id="1、域名解析"><a href="#1、域名解析" class="headerlink" title="1、域名解析"></a>1、域名解析</h3><p>域名解析分为两种：</p>
<ul>
<li>将域名解析为IP地址</li>
<li>将域名解析为另一个域名（CNAME）</li>
</ul>
<p>购买一个域名之后，需要去映射一个 IP地址，用 Map 表示：{域名：IP}。<br>也可以给某域名取一个别名，比如给 <code>www.baidu.com</code> 取一个别名 <code>test.baidu.com</code>，用 Map 表示：{域名：CNAME}，这里的CNAME就是别名。</p>
<p><strong>域名解析，实际上就是解析出指定域名所对应的 IP地址，或该域名的一个 CNAME。</strong></p>
<p>没有CNAME的情况：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/7/16/16bf9e293d4bc895~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.webp#?w=1004&h=474&s=41808&e=png&b=fefbfb"
                      alt="图1"
                ></p>
<p>有CNAME的情况：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/7/16/16bf9e293e8c88d4~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.webp#?w=1012&h=468&s=46488&e=png&b=fefafa"
                      alt="图1"
                ></p>
<p>特别注意：在有 CNAME 的情况下，CNAME 在域名解析的过程中承担了代理的角色，这是 CDN 实现的关键。</p>
<h3 id="2、资源分类"><a href="#2、资源分类" class="headerlink" title="2、资源分类"></a>2、资源分类</h3><p>服务器上的资源分为两种：</p>
<ul>
<li>静态资源：这种资源通常很少变动，比如图片，视频，css，js 等等</li>
<li>动态资源：这种资源不同用户不同时刻访问通常是不一样的，比如 ftl，jsp 等等。</li>
</ul>
<h4 id="（1）集群（动态资源）"><a href="#（1）集群（动态资源）" class="headerlink" title="（1）集群（动态资源）"></a>（1）集群（动态资源）</h4><p>在全国各地部署服务器，每个服务器上都有相同的动态资源，并且还需配置相应的数据库，这就涉及到数据同步等问题。这种做法专业一点就是集群，目前集群架构最多是三地五中心，因为全国多地集群成本太高。</p>
<h4 id="（2）CDN服务器（静态资源）"><a href="#（2）CDN服务器（静态资源）" class="headerlink" title="（2）CDN服务器（静态资源）"></a>（2）CDN服务器（静态资源）</h4><p>在每个服务器上只部署静态资源是成本较低的方式，因为静态资源通常不涉及数据库，也能提高用户访问速度。</p>
<p>现在有很多 CDN供应商，只要把系统接入并将静态资源传给 CDN服务，这些静态资源将会自动分布到世界各地。</p>
<p>在访问静态资源时，DNS系统 进行域名解析的过程中，如何解析出离用户最近的 IP地址？<br>这就需要使用 CDN服务器，该服务器知道用户当前所在位置，和用户访问的域名对应哪些 IP地址，及这些 IP地址 分别在哪。</p>
<p>这样，只要用户在通过某域名访问静态资源时，<strong>配置自己电脑的 DNS地址 为 CDN专用DNS服务器</strong>，就可以解决问题了，但不能要求所有用户都去修改自己电脑的 DNS地址，这时就要利用 DNS 中的 CNAME 了。</p>
<h3 id="3、负载均衡和缓存"><a href="#3、负载均衡和缓存" class="headerlink" title="3、负载均衡和缓存"></a>3、负载均衡和缓存</h3><h4 id="（1）负载均衡系统"><a href="#（1）负载均衡系统" class="headerlink" title="（1）负载均衡系统"></a>（1）负载均衡系统</h4><p>如果没有返回 IP地址，本地DNS服务器 会向对应的 CDN服务器 再次发送请求，通过 CDN负载均衡系统 进行智能调度：</p>
<ul>
<li>看用户的 IP 地址，查表得知<strong>地理位置</strong>，找相对最近的边缘节点</li>
<li>看用户所在的<strong>运营商网络</strong>，找相同网络的边缘节点</li>
<li>检查边缘节点的<strong>负载情况</strong>，找负载较轻的节点</li>
<li>其他，比如节点的“健康状况”、服务能力、带宽、响应时间等</li>
</ul>
<p>结合以上因素，得到最合适的边缘节点，并把该节点返回给用户，用户就能就近访问 CDN 的缓存代理。</p>
<p>整体流程如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/7/16/16bf9e293edf212d~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.webp#?w=1090&h=720&s=68194&e=png&b=fefcfc"
                      alt="图3"
                ></p>
<h4 id="（2）缓存代理"><a href="#（2）缓存代理" class="headerlink" title="（2）缓存代理"></a>（2）缓存代理</h4><p>缓存系统是 CDN 的另一个关键组成部分，缓存系统会缓存最常用的资源，有两个衡量 CDN服务质量 的指标：</p>
<ul>
<li><strong>命中率</strong>：用户访问的资源恰好在缓存系统里，可直接返回给用户，命中次数与所有访问次数之比</li>
<li><strong>回源率</strong>：缓存里没有，必须用代理的方式回源站取，回源次数与所有访问次数之比</li>
</ul>
<p>缓存系统可以划分层次为：一级缓存节点和二级缓存节点，一级缓存直连源站，二级缓存直连用户。<br>在回源时，二级缓存首先找一级缓存，一级缓存没有才回源站，可有效减少真正的回源。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6db24ee3dcb84eed84b7736b09bdaec9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.webp"
                      alt="图4"
                ></p>
<p>现在的商业 CDN命中率都在 90% 以上，相当于把源站的服务能力放大了 10 倍以上</p>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>域名解析有多种记录类型，最常用的有：</p>
<ul>
<li><strong>A记录：一个域名对应一个IP地址</strong></li>
<li><strong>CNAME：一个域名对应另外一个域名</strong></li>
<li>NS：将子域名指定其他DNS服务器解析</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络 - CDN</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>计算机网络</tag>
        <tag>CDN</tag>
      </tags>
  </entry>
  <entry>
    <title>interface &amp; type</title>
    <url>/2024/11/05/28-interface&amp;type/</url>
    <content><![CDATA[<h2 id="一、相同点"><a href="#一、相同点" class="headerlink" title="一、相同点"></a>一、相同点</h2><h3 id="1、都可以描述对象和函数的类型"><a href="#1、都可以描述对象和函数的类型" class="headerlink" title="1、都可以描述对象和函数的类型"></a>1、都可以描述对象和函数的类型</h3><p>但语法不一样，type 使用 &#x3D; 赋值</p>
<div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SetUser</span> &#123;</span><br><span class="line">    (<span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">age</span>: <span class="built_in">number</span>): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SetUser</span> = <span class="function">(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span></span><br></pre></td></tr></table></figure></div>

<h3 id="2、都允许扩展（extends）"><a href="#2、都允许扩展（extends）" class="headerlink" title="2、都允许扩展（extends）"></a>2、都允许扩展（extends）</h3><p>并且 interface 和 type 可以互相扩展</p>
<h4 id="（1）interface-扩展-interface"><a href="#（1）interface-扩展-interface" class="headerlink" title="（1）interface 扩展 interface"></a>（1）interface 扩展 interface</h4><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Name</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_">Name</span> &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="（2）type-扩展-type"><a href="#（2）type-扩展-type" class="headerlink" title="（2）type 扩展 type"></a>（2）type 扩展 type</h4><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = <span class="title class_">Name</span> &amp; &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="（3）interface-扩展-type"><a href="#（3）interface-扩展-type" class="headerlink" title="（3）interface 扩展 type"></a>（3）interface 扩展 type</h4><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_">Name</span> &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="（4）type-扩展-interface"><a href="#（4）type-扩展-interface" class="headerlink" title="（4）type 扩展 interface"></a>（4）type 扩展 interface</h4><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Name</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = <span class="title class_">Name</span> &amp; &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="二、不同点"><a href="#二、不同点" class="headerlink" title="二、不同点"></a>二、不同点</h2><h3 id="1、type-可以，但-interface-不行"><a href="#1、type-可以，但-interface-不行" class="headerlink" title="1、type 可以，但 interface 不行"></a>1、type 可以，但 interface 不行</h3><h4 id="（1）基本类型别名"><a href="#（1）基本类型别名" class="headerlink" title="（1）基本类型别名"></a>（1）基本类型别名</h4><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Name</span> = <span class="built_in">string</span></span><br></pre></td></tr></table></figure></div>

<h4 id="（2）联合类型"><a href="#（2）联合类型" class="headerlink" title="（2）联合类型"></a>（2）联合类型</h4><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="attr">dogName</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="attr">catName</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Pet</span> = <span class="title class_">Dog</span> | <span class="title class_">Cat</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StringOrNumber</span> = <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Text</span> = <span class="built_in">string</span> | &#123; <span class="attr">text</span>: <span class="built_in">string</span> &#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="（3）元组"><a href="#（3）元组" class="headerlink" title="（3）元组"></a>（3）元组</h4><p>具体定义数组每个位置的类型</p>
<div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PetList</span> = [<span class="title class_">Dog</span>, <span class="title class_">List</span>]</span><br></pre></td></tr></table></figure></div>

<h4 id="（4）使用-typeof-获取实例的类型-对-type-进行赋值"><a href="#（4）使用-typeof-获取实例的类型-对-type-进行赋值" class="headerlink" title="（4）使用 typeof 获取实例的类型 对 type 进行赋值"></a>（4）使用 typeof 获取实例的类型 对 type 进行赋值</h4><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> divEle = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Div</span> = <span class="keyword">typeof</span> divEle</span><br></pre></td></tr></table></figure></div>

<h3 id="2、interface-可以，但-type-不行"><a href="#2、interface-可以，但-type-不行" class="headerlink" title="2、interface 可以，但 type 不行"></a>2、interface 可以，但 type 不行</h3><h4 id="interface-能够声明合并"><a href="#interface-能够声明合并" class="headerlink" title="interface 能够声明合并"></a>interface 能够声明合并</h4><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * User 接口为 &#123;</span></span><br><span class="line"><span class="comment"> *     name: string</span></span><br><span class="line"><span class="comment"> *     age: number</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div>

<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>优先用 interface，无法实现再用 type，因为 interface 具有更直观和易于理解的特点，并且能够进行声明合并。</p>
]]></content>
  </entry>
  <entry>
    <title>三次握手&amp;四次挥手</title>
    <url>/2024/11/04/27-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B&amp;%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><h4 id="1、TCP-协议"><a href="#1、TCP-协议" class="headerlink" title="1、TCP 协议"></a>1、TCP 协议</h4><p>TCP（Transmission Control Protocol），即传输控制协议。<br>TCP 协议是一个 <strong>面向连接的、可靠的、基于字节流</strong> 的 <strong>传输层协议</strong>。</p>
<p>TCP 连接可以用于 <strong>保证可靠性</strong> 和 <strong>流量控制机制</strong>，包括 Socket、序列号及窗口大小。</p>
<p>其中 Socket 是由 IP 加端口组成的，序列号是用来解决乱序问题的，而窗口大小则是用来做流量控制的。</p>
<h4 id="2、TCP-的特点"><a href="#2、TCP-的特点" class="headerlink" title="2、TCP 的特点"></a>2、TCP 的特点</h4><ul>
<li>面向连接：TCP 是通过服务端和客户端进行连接的协议。</li>
<li>面向字节流：TCP 服务端和客户端之间的数据通讯是通过 <strong>字节流数据</strong> 传输的。</li>
<li>可靠的：TCP 传输的可靠性得益于 TCP 会记录 <strong>信息的发送状态</strong> 和 <strong>数据的接收与否</strong>，对于丢包等发送不成功的情况，TCP 会重新发包，进而保证 TCP 的可靠性。</li>
</ul>
<h3 id="3、TCP-三次握手"><a href="#3、TCP-三次握手" class="headerlink" title="3、TCP 三次握手"></a>3、TCP 三次握手</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://ask.qcloudimg.com/http-save/yehe-1208223/0b58ac09994e834e14ca43dcf357294b.png?imageView2/2/w/1620"
                      alt="图1"
                ></p>
<ul>
<li>SYN：Synchronize Sequence Numbers，同步序列号，表示发起一个新连接。</li>
<li>ACK：确认收到一个新连接。</li>
<li>SEQ：序列号。</li>
</ul>
<p>TCP 三次握手执行过程：</p>
<h4 id="（1）第一次握手（在吗？）"><a href="#（1）第一次握手（在吗？）" class="headerlink" title="（1）第一次握手（在吗？）"></a>（1）第一次握手（在吗？）</h4><p>Client 将 <code>SYN</code> 发给 Server。<br>Client 进入 <code>SYN_SENT</code> 状态，等待 Server 确认。</p>
<h4 id="（2）第二次握手（在的，有事？）"><a href="#（2）第二次握手（在的，有事？）" class="headerlink" title="（2）第二次握手（在的，有事？）"></a>（2）第二次握手（在的，有事？）</h4><p>Server 收到 <code>SYN</code>，将 <code>SYN</code>+<code>ACK</code> 发给 Client。<br>Server 进入 <code>SYN_RCVD</code> 状态，等待 Client 确认。</p>
<h4 id="（3）第三次握手（需要数据传输）"><a href="#（3）第三次握手（需要数据传输）" class="headerlink" title="（3）第三次握手（需要数据传输）"></a>（3）第三次握手（需要数据传输）</h4><p>Client 收到 <code>SYN</code>+<code>ACK</code>，将 <code>SYN</code> 发给 Server。<br>连接成功，Client 与 Server 进入 <code>ESTABLISHED</code> 状态，可以传输数据。</p>
<h4 id="TCP-为什么需要三次握手？"><a href="#TCP-为什么需要三次握手？" class="headerlink" title="TCP 为什么需要三次握手？"></a>TCP 为什么需要三次握手？</h4><p><strong>为了防止已失效的请求报文段传送到服务端而产生连接的误判。</strong></p>
<p>假设是两次握手：</p>
<p>当 A 发送一个连接请求给 B，但是该请求由于网络原因被阻塞了，一段时间后，A 未收到回复，会认为该消息丢失了，就会重新发送消息。</p>
<p>当 A 和 B 通信完成后，这个被 A 认为已经丢失的请求到达了 B，B 会认为这是一个新的请求连接消息，就向 A 发送确认。</p>
<p>但是 A 认为自己没有给 B 再次发送消息，所以不会理睬 B 的确认，但是 B 会一直等待 A 的消息，导致 B 的资源被浪费。</p>
<p>这就是为什么不能两次握手。</p>
<p><strong>设计成三次握手的情况，客户端在接收到服务端 SEQ+1 的返回消息后，就会知道该连接是历史连接，接着发送报文告诉服务端。</strong></p>
<p>为了节省资源，也没必要设计成更多次的握手。</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img-blog.csdnimg.cn/20190627203747107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NodWZmbGVfVHM=,size_16,color_FFFFFF,t_70"
                      alt="图2"
                ></p>
<h3 id="四次挥手的-6-种状态"><a href="#四次挥手的-6-种状态" class="headerlink" title="四次挥手的 6 种状态"></a>四次挥手的 6 种状态</h3><h4 id="（1）FIN-WAIT-1"><a href="#（1）FIN-WAIT-1" class="headerlink" title="（1）FIN_WAIT_1"></a>（1）FIN_WAIT_1</h4><p>主动方在 <code>ESTABLISHED</code> 状态的时候，想要主动关闭连接，向对方发送 <code>FIN</code> 报文，并进入 <code>FIN_WAIT_1</code> 状态。</p>
<h4 id="（2）FIN-WAIT-2"><a href="#（2）FIN-WAIT-2" class="headerlink" title="（2）FIN_WAIT_2"></a>（2）FIN_WAIT_2</h4><p>当主动方收到被动方回复的 <code>ACK</code> 报文后，就进入了 <code>FIN_WAIT_2</code> 状态。</p>
<p>当主动方进入 <code>FIN_WAIT_2</code> 时，表示半连接状态，即被动方还有数据要发过来。</p>
<h4 id="（3）CLOSE-WAIT"><a href="#（3）CLOSE-WAIT" class="headerlink" title="（3）CLOSE_WAIT"></a>（3）CLOSE_WAIT</h4><p>当被动方接收到 <code>FIN</code> 时，会回复一个 <code>ACK</code>，并进入 <code>CLOSE_WAIT</code> 状态。</p>
<p>在该状态中，被动方如果还有数据要发送，就继续发送，如果没有，就关闭连接，并发送一个 <code>FIN</code> 给对方。</p>
<h4 id="（4）TIME-WAIT"><a href="#（4）TIME-WAIT" class="headerlink" title="（4）TIME_WAIT"></a>（4）TIME_WAIT</h4><p>当主动方接收到了 <code>FIN</code> 报文，就回复一个 <code>ACK</code> 报文，并进入 <code>TIME_WAIT</code> 状态。</p>
<p>如果主动方在 <code>FIN_WAIT_1</code> 状态下，收到了对方的 <code>FIN</code>+<code>ACK</code> 报文，可以跳过 <code>FIN_WAIT_2</code> 直接进入 <code>TIME_WAIT</code> 状态。</p>
<h4 id="（5）LAST-ACK"><a href="#（5）LAST-ACK" class="headerlink" title="（5）LAST_ACK"></a>（5）LAST_ACK</h4><p>被动方发送了 <code>FIN</code> 报文后，最后等待对方的 <code>ACK</code> 报文时进入的状态。收到ACK报文后就可以进入CLOSED状态了。</p>
<h4 id="（6）CLOSED"><a href="#（6）CLOSED" class="headerlink" title="（6）CLOSED"></a>（6）CLOSED</h4><p>主动方进入 <code>TIME_WAIT</code> 状态后，再等待 <code>2MSL</code> 就会进入 <code>CLOSED</code> 状态。<br>被动方在收到 <code>ACK</code> 报文后，立即进入 <code>CLOSED</code> 状态。</p>
<h3 id="TIME-WAIT-的意义"><a href="#TIME-WAIT-的意义" class="headerlink" title="TIME_WAIT 的意义"></a><code>TIME_WAIT</code> 的意义</h3><p>如果没有 <code>TIME-WAIT</code>，主动方会直接进入 <code>CLOSED</code> 状态。<br>此时如果因为网络原因最后一次 <code>ACK</code> 丢失了，服务端会重复发送 <code>FIN</code> 请求给客户端，所以就需要主动方发送最后一次 <code>ACK</code> 之后进入 <code>TIME_WAIT</code> 状态，等待 <code>2MSL</code>（两个报文最大生命周期），等待这段时间就是为了如果接收到了重发的 <code>FIN</code> 请求能够进行最后一次 <code>ACK</code> 回复。</p>
]]></content>
      <categories>
        <category>计算机网络 - TCP</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>计算机网络</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP</title>
    <url>/2024/11/05/29-TCP/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/23/1707236e03d22cbc~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.webp"
                      alt="图1"
                ></p>
<h2 id="一、TCP-和-UDP-的区别"><a href="#一、TCP-和-UDP-的区别" class="headerlink" title="一、TCP 和 UDP 的区别"></a>一、TCP 和 UDP 的区别</h2><p>TCP 和 UDP 都是传输层协议，不同点在于：</p>
<ul>
<li>TCP 是 <strong>面向连接的、可靠的、面向字节流</strong> 的</li>
<li>UDP 是 <strong>面向无连接</strong> 的</li>
</ul>
<p>TCP 的三大核心特性</p>
<h3 id="1、面向连接"><a href="#1、面向连接" class="headerlink" title="1、面向连接"></a>1、面向连接</h3><p>在客户端和服务器互相通信之前，TCP 需要三次握手建立连接，而 UDP 不需要</p>
<h3 id="2、可靠性"><a href="#2、可靠性" class="headerlink" title="2、可靠性"></a>2、可靠性</h3><p>TCP 的可靠性体现在<strong>有状态、可控制</strong>。</p>
<h4 id="（1）有状态"><a href="#（1）有状态" class="headerlink" title="（1）有状态"></a>（1）有状态</h4><p>TCP 会记录发送的数据，以及其中被接收和未被接收的数据，并保证数据包按序到达</p>
<h4 id="（2）可控制"><a href="#（2）可控制" class="headerlink" title="（2）可控制"></a>（2）可控制</h4><p>当意识到丢包或网络不佳，TCP 会根据情况调整自身行为，控制发送速度或者重发</p>
<h3 id="3、面向字节流"><a href="#3、面向字节流" class="headerlink" title="3、面向字节流"></a>3、面向字节流</h3><p>UDP 的数据传输是基于数据报的，这仅仅继承了 IP 层的特性；而 TCP 为了维护状态，将 IP 包变成了字节流</p>
<h2 id="二、TCP-三次握手过程-为什么是三次"><a href="#二、TCP-三次握手过程-为什么是三次" class="headerlink" title="二、TCP 三次握手过程 &amp; 为什么是三次"></a>二、TCP 三次握手过程 &amp; 为什么是三次</h2><h3 id="1、流程"><a href="#1、流程" class="headerlink" title="1、流程"></a>1、流程</h3><p>发送与接收方需要确认双方的两种能力：发送和接收，于是会有三次握手的过程:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/23/170723de9b8aa08b~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.webp"
                      alt="图2"
                ></p>
<h4 id="（1）服务器变为-LISTEN"><a href="#（1）服务器变为-LISTEN" class="headerlink" title="（1）服务器变为 LISTEN"></a>（1）服务器变为 LISTEN</h4><h5 id="起初双方都处于-CLOSED-状态。服务端开始监听某个端口，进入-LISTEN-状态"><a href="#起初双方都处于-CLOSED-状态。服务端开始监听某个端口，进入-LISTEN-状态" class="headerlink" title="起初双方都处于 CLOSED 状态。服务端开始监听某个端口，进入 LISTEN 状态"></a>起初双方都处于 CLOSED 状态。服务端开始监听某个端口，进入 LISTEN 状态</h5><h4 id="（2）客户端变为-SYN-SENT"><a href="#（2）客户端变为-SYN-SENT" class="headerlink" title="（2）客户端变为 SYN-SENT"></a>（2）客户端变为 SYN-SENT</h4><h5 id="客户端主动发起连接，发送-SYN，并进入-SYN-SENT-状态"><a href="#客户端主动发起连接，发送-SYN，并进入-SYN-SENT-状态" class="headerlink" title="客户端主动发起连接，发送 SYN，并进入 SYN-SENT 状态"></a>客户端主动发起连接，发送 SYN，并进入 SYN-SENT 状态</h5><p>其中 seq&#x3D;x，表示客户端告诉服务端，我发送的首个数据包 序列号从 x 开始</p>
<h4 id="（3）服务端变为-SYN-REVD"><a href="#（3）服务端变为-SYN-REVD" class="headerlink" title="（3）服务端变为 SYN-REVD"></a>（3）服务端变为 SYN-REVD</h4><h5 id="服务端接收到，返回-SYN-和-ACK（对应客户端发来的-SYN），并进入-SYN-REVD-状态"><a href="#服务端接收到，返回-SYN-和-ACK（对应客户端发来的-SYN），并进入-SYN-REVD-状态" class="headerlink" title="服务端接收到，返回 SYN 和 ACK（对应客户端发来的 SYN），并进入 SYN-REVD 状态"></a>服务端接收到，返回 SYN 和 ACK（对应客户端发来的 SYN），并进入 SYN-REVD 状态</h5><p>其中 seq&#x3D;y，ack&#x3D;x+1，seq&#x3D;y 表示服务端的初始序列号是 y ，ack&#x3D;x+1 表示服务端告诉客户端：已收到从序列号 x 开始的数据包，期望下次发送从序列号 x+1 开始的数据包</p>
<h4 id="（4）客户端变为-ESTABLISHED"><a href="#（4）客户端变为-ESTABLISHED" class="headerlink" title="（4）客户端变为 ESTABLISHED"></a>（4）客户端变为 ESTABLISHED</h4><h5 id="客户端再发送-ACK-给服务端，并进入-ESTABLISHED-状态"><a href="#客户端再发送-ACK-给服务端，并进入-ESTABLISHED-状态" class="headerlink" title="客户端再发送 ACK 给服务端，并进入 ESTABLISHED 状态"></a>客户端再发送 ACK 给服务端，并进入 ESTABLISHED 状态</h5><p>其中 seq&#x3D;x+1 ，ack&#x3D;y+1 。seq&#x3D;x+1 表示客户端按照服务端的期望，从序列号 x+1 开始发送数据包，ack&#x3D;y+1 表示客户端告诉服务端：已收到从序列号 y 开始的数据包，期望下次发送从序列号 y+1 开始的数据包</p>
<h5 id="服务端收到-ACK-之后，也进入-ESTABLISHED-状态"><a href="#服务端收到-ACK-之后，也进入-ESTABLISHED-状态" class="headerlink" title="服务端收到 ACK 之后，也进入 ESTABLISHED 状态"></a>服务端收到 ACK 之后，也进入 ESTABLISHED 状态</h5><p>注意：凡是需要对端确认的，一定会消耗 TCP 报文的序列号。<br>SYN 需要对端的确认，而 ACK 不需要，因此 SYN 消耗一个序列号，下次发送对应的 ACK 序列号要加 1，而 ACK 不需要。</p>
<h3 id="2、为什么不是两次握手"><a href="#2、为什么不是两次握手" class="headerlink" title="2、为什么不是两次握手"></a>2、为什么不是两次握手</h3><p>根本原因：<strong>没有第三次握手，服务端无法确认客户端的接收能力</strong></p>
<p>如果是两次，客户端发送 SYN 报文试图和服务端建立连接，但是这个包发生了滞留；一段时间后，客户端未收到服务端响应，以为丢了包，于是重传，两次握手建立好了连接。</p>
<p>但是在连接关闭后，如果滞留的包到达了服务端，这时由于是两次握手，服务端只要接收到、并给客户端发送了相应的数据包，就默认建立连接，但是此时客户端已经断开，这就带来了资源的浪费。</p>
<h3 id="3、三次握手过程中可以携带数据么"><a href="#3、三次握手过程中可以携带数据么" class="headerlink" title="3、三次握手过程中可以携带数据么"></a>3、三次握手过程中可以携带数据么</h3><p>第三次握手可以携带数据，前两次握手不能携带</p>
<p>如果前两次握手能够携带数据，一旦有人想攻击服务器，只需要在第一次握手中的 SYN 报文中放大量数据，服务器势必会消耗更多的时间和内存空间去进行处理，增大了服务器被攻击的风险</p>
<p>第三次握手时，客户端已处于 ESTABLISHED 状态，并且能够确认服务器的接收、发送能力正常，这时相对安全，可以携带数据</p>
<h2 id="三、TCP-四次挥手的过程"><a href="#三、TCP-四次挥手的过程" class="headerlink" title="三、TCP 四次挥手的过程"></a>三、TCP 四次挥手的过程</h2>]]></content>
      <categories>
        <category>计算机网络 - TCP</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>计算机网络</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>北大-区块链技术与应用1-简介</title>
    <url>/2025/01/02/30-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>本课程主要讲：比特币和以太坊 两种加密货币</p>
<p>视频链接：</p>
<p><a class="link"   href="https://www.bilibili.com/video/BV1Vt411X7JF/?spm_id_from=333.337.search-card.all.click&vd_source=69ac93649ea21c4726fe85f272b6d968" >https://www.bilibili.com/video/BV1Vt411X7JF/?spm_id_from=333.337.search-card.all.click&amp;vd_source=69ac93649ea21c4726fe85f272b6d968 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>Web3 - 北大肖臻-区块链技术与应用</category>
      </categories>
      <tags>
        <tag>web3</tag>
      </tags>
  </entry>
  <entry>
    <title>北大-区块链技术与应用2-密码学基础</title>
    <url>/2025/01/02/31-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>Crypto-currency（加密货币）</p>
<p>区块链和比特币主要用到：哈希函数 和 数字签名</p>
<h2 id="一、Cryptographic-Hash-Function（哈希函数）"><a href="#一、Cryptographic-Hash-Function（哈希函数）" class="headerlink" title="一、Cryptographic Hash Function（哈希函数）"></a>一、Cryptographic Hash Function（哈希函数）</h2><p>区块链用到了哈希函数的 抗碰撞性 和 隐私性；比特币除了这两个性质，还要求 谜题友好性</p>
<h3 id="（1）Collision-resistance（抗碰撞）"><a href="#（1）Collision-resistance（抗碰撞）" class="headerlink" title="（1）Collision resistance（抗碰撞）"></a>（1）Collision resistance（抗碰撞）</h3><p> x≠y, H(x)≠H(y)<br> 给定一个x，没有高效的方法找到一个y，满足H(x)&#x3D;H(y)，可以用 brute-force（蛮力破解）</p>
<p> Message digest（信息摘要）：给定一个消息m，用H(m)检测对消息的篡改<br> 对m’≠m，H(m’)≠H(m)</p>
<p> MD5已经可以被人为地制造碰撞</p>
<h3 id="（2）Hiding（隐私性）-Not-invertable（单向不可逆）"><a href="#（2）Hiding（隐私性）-Not-invertable（单向不可逆）" class="headerlink" title="（2）Hiding（隐私性）&#x2F; Not invertable（单向不可逆）"></a>（2）Hiding（隐私性）&#x2F; Not invertable（单向不可逆）</h3><p> x –&gt; H(x)，没有高效的方法从H(x)得到x，除了 brute-force</p>
<h3 id="（3）Puzzle-friendly（谜题友好）"><a href="#（3）Puzzle-friendly（谜题友好）" class="headerlink" title="（3）Puzzle friendly（谜题友好）"></a>（3）Puzzle friendly（谜题友好）</h3><p> 不知道如何选定x，使H(x)落在某个区间内，Exp. 00…0XXX…X（以k个0开始）</p>
<p> 挖矿过程：找一个nonce，和区块块头中的其他信息和在一起作为输入，哈希过后的值要小于等于目标域值，即H(block header) ≤target<br> 其谜题友好意味着，挖矿的过程不存在捷径，只能靠 brute-force，所以该过程才能作为 power of work（pow，工作量证明）<br> 设置 mining puzzle 的原则：Difficult to solve, but easy to verify</p>
<h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h4><p>比特币中用到的哈希函数是 SHA-256（Secure Hash Algorithm），满足以上三个性质</p>
<h4 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h4><p>Digital commitment（数字承诺），又名 Digital Equivalent of a Sealed Envelope（密封信封的数字等价物），允许一方将某个值（秘密或消息）“承诺”给另一方（验证者）</p>
<p>结合了哈希函数的抗碰撞和隐私性<br>Hiding：公开m&#x3D;H(x)，给定x’，如果H(x’)&#x3D;m，即可保证x’&#x3D;x</p>
<p>扩大输入空间的方法：选取nonce（number once）随机数，H(x||nonce)</p>
<h2 id="二、Digital-Signature（数字签名）"><a href="#二、Digital-Signature（数字签名）" class="headerlink" title="二、Digital Signature（数字签名）"></a>二、Digital Signature（数字签名）</h2><p>不同于银行的开户流程，比特币是去中心化的，只要在本地创建一个公私钥对（public key，private key），就代表一个比特币账户，来源于非对称加密体系（asymmetric encryption algorithm）</p>
<p>在比特币系统中，公私钥用于签名：发布者用自己的私钥对交易进行签名，接受者通过发布者的公钥验签</p>
<p>生成公私钥、以及签名 都需要 a good source of randomess</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在比特币系统中，通常对一个message取哈希，然后再对该哈希值进行签名</p>
]]></content>
      <categories>
        <category>Web3 - 北大肖臻-区块链技术与应用</category>
      </categories>
      <tags>
        <tag>web3</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>北大-区块链技术与应用4-共识协议</title>
    <url>/2025/01/02/33-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="一、Double-spending-attack（双花攻击）"><a href="#一、Double-spending-attack（双花攻击）" class="headerlink" title="一、Double spending attack（双花攻击）"></a>一、Double spending attack（双花攻击）</h2><p>双花攻击指同一笔资金被重复支付的情况，也是数字货币面临的主要挑战</p>
<p>中心化解决方案：数字货币上添加唯一编号，并由央行维护一个数据结构，展示每个编号的货币由谁持有；如果付费方的货币在表中对应的持有人与此人不符，则证明该货币已支付给其他人</p>
<p>去中心化的解决方案：比特币</p>
<p>关注：货币的发行（挖矿）、交易的有效性验证（防范双花攻击）</p>
<h2 id="二、交易的有效性验证"><a href="#二、交易的有效性验证" class="headerlink" title="二、交易的有效性验证"></a>二、交易的有效性验证</h2><p>通过一个由所有用户共同维护的数据结构——区块链 来实现</p>
<h2 id="三、区块链简易结构"><a href="#三、区块链简易结构" class="headerlink" title="三、区块链简易结构"></a>三、区块链简易结构</h2><p>Note：以下为简易版的区块链，每个区块都只有一个交易，实际上每个区块的交易记录都构成一个 Merkle tree</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/33/1.png"
                      alt="图1"
                ></p>
<p>存在两种哈希指针：将区块串联成链表的指针，和指向前面某个交易的指针（为了说明币的来源，避免凭空捏造和重复交易）</p>
<p>1、用户A 具有发行货币的权利（铸币权，mint 铸币），并发行了10个比特币（coin base transaction，铸币交易）</p>
<p>2、用户A 分别给 用户B、用户C 5个比特币</p>
<p>3、用户B 分别给 用户C 2个比特币、用户D 3个比特币</p>
<p>4、用户C 转给 用户E 7个比特币</p>
<p>5、假设用户B 继续给 用户F 5个比特币，通过区块的回溯，校验出其已经在先前的交易中支付过了，所以交易不合法（避免双花攻击）</p>
<p>在 用户A 向 用户B 的交易中，需要记录 「输入」A的公钥、A的签名 和 「输出」B的地址（通过B的公钥取哈希等操作得到，可类比为银行卡账号）<br>A 需要 B的公钥 知道向哪里转账，所有节点都 需要 A的公钥 来验签</p>
<h4 id="BitCoin-Scripts"><a href="#BitCoin-Scripts" class="headerlink" title="BitCoin Scripts"></a>BitCoin Scripts</h4><p>交易中的A的公钥（该交易的输入脚本），需要与 币的来源的A的公钥的哈希（前一交易的输出脚本） 相符（两脚本拼在一起能顺利执行）；否则说明币的来源有问题，A被冒名顶替了</p>
<h2 id="四、区块结构"><a href="#四、区块结构" class="headerlink" title="四、区块结构"></a>四、区块结构</h2><h3 id="1、Block-header"><a href="#1、Block-header" class="headerlink" title="1、Block header"></a>1、Block header</h3><p>包含区块的宏信息，比如：version（协议版本）、hash of privious block header（前一区块头的哈希）、merkle root hash（Merkle树 根哈希），还有和挖矿相关的 target（挖矿的难度目标域值）、nonce（随机数）</p>
<p>Note：</p>
<p>（1）hash of privious block header 取的只是前一区块头的哈希，不包含块体</p>
<p>（2）Merkle树 根哈希 保证了块体中的交易列表不会被篡改</p>
<p>（3）target 满足 H(block header)≤target，块头中存的是该目标域值的编码 nBits（nBits 是用于表示难度的参数，用于判断区块头是否有效）</p>
<h4 id="nBits"><a href="#nBits" class="headerlink" title="nBits"></a>nBits</h4><p>nBits 是一个包含了目标值信息的编码，通常以十六进制形式存储并表示为一个 4 字节（32 位）的数<br>该编码包含两个部分：</p>
<ul>
<li>难度指数（Exponent）：前 1 个字节（8 位）</li>
<li>目标哈希的有效值（Coefficient）：后 3 个字节（24 位）<br>目标值越小，挖掘新区块的难度就越大。这允许系统灵活地调整挖矿的难度，并以压缩的方式存储信息</li>
</ul>
<h3 id="2、Block-body"><a href="#2、Block-body" class="headerlink" title="2、Block body"></a>2、Block body</h3><p>包含 transaction list（交易列表）</p>
<h2 id="五、Distributed-consensus（分布式共识）"><a href="#五、Distributed-consensus（分布式共识）" class="headerlink" title="五、Distributed consensus（分布式共识）"></a>五、Distributed consensus（分布式共识）</h2><p>账本的内容要取得分布式的共识</p>
<h3 id="1、共识的例子：Distributed-hash-table（分布式哈希表）"><a href="#1、共识的例子：Distributed-hash-table（分布式哈希表）" class="headerlink" title="1、共识的例子：Distributed hash table（分布式哈希表）"></a>1、共识的例子：Distributed hash table（分布式哈希表）</h3><p>达成共识的是 key-value pairs（键值对）</p>
<h3 id="2、Impossibility-result（不可能结论）"><a href="#2、Impossibility-result（不可能结论）" class="headerlink" title="2、Impossibility result（不可能结论）"></a>2、Impossibility result（不可能结论）</h3><p>Example：FLP impossibility result<br>在 asynchronous system（异步系统）中，即使只有一个成员是 faulty（有故障的），那么也无法取得共识</p>
<p>CAP Theorem</p>
<p>（1）Consistency（一致性）</p>
<p>（2）Availability（可用性）：即使某些节点不可用，系统仍然能够提供服务</p>
<p>（3）Partition tolerance（分区容忍性）：分区是指在网络中，若干节点之间的通信链路发生故障时形成的网络割裂，这意味着某些节点无法与其他节点进行交互</p>
<p>不可能三角：任何一个分布式系统，只能满足以上两个性质，不可能三个性质都满足</p>
<h3 id="3、分布式共识的著名协议：Paxos"><a href="#3、分布式共识的著名协议：Paxos" class="headerlink" title="3、分布式共识的著名协议：Paxos"></a>3、分布式共识的著名协议：Paxos</h3><p>该协议能保证一致性，但是有可能一直达不成共识（可能性比较小）</p>
<h2 id="六、Consensus-in-BitCoin（比特币中的共识）"><a href="#六、Consensus-in-BitCoin（比特币中的共识）" class="headerlink" title="六、Consensus in BitCoin（比特币中的共识）"></a>六、Consensus in BitCoin（比特币中的共识）</h2><h3 id="1、基于投票的共识方案"><a href="#1、基于投票的共识方案" class="headerlink" title="1、基于投票的共识方案"></a>1、基于投票的共识方案</h3><p>基于投票的方案需要确认投票权的 membership，比如联盟链的协议 hyperledger fabric（超分类账结构）。常规的投票方案会带来 sybil attack（女巫攻击），即通过超级计算机生成超半数的比特币账户以获取控制权</p>
<h3 id="2、验证过程"><a href="#2、验证过程" class="headerlink" title="2、验证过程"></a>2、验证过程</h3><p>H(block header) ≤ target，block header 中包含 4 bytes 的随机数 nonce，组装好区块后就开始尝试不同的 nonce，直到哈希值落在 target 内。如果某节点找到了符合要求的 nonce，即具备了记账权（在去中心化账本中写入&#x2F;发布下一个区块的权利），发布后即由其他区块进行验证：</p>
<p>1、验证 block header 中的几项</p>
<p>2、看 block body 中的交易列表，验证每个交易都是合法的：（1）要有合法的签名；（2）以前没有被交易过</p>
<h3 id="3、Forking-attack（分叉攻击）"><a href="#3、Forking-attack（分叉攻击）" class="headerlink" title="3、Forking attack（分叉攻击）"></a>3、Forking attack（分叉攻击）</h3><p>但是不同的链上可能发生重复交易（forking attack），解决方案是以 longest valid chain（最长合法链）为准，因此只有扩展最长合法链的区块才是合法的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/33/2.png"
                      alt="图2"
                ></p>
<p>当两个矿工同时创造新区块时，其他节点按照接收时间来选择接受哪个区块，等长的临时性的分叉会维持一段时间，直到其中一条链胜出（先找到下一个区块）；而另一条链就变成了 orphan block（孤儿区块） &#x2F; stale block，被丢弃掉，也就没有出块奖励</p>
<h3 id="4、Block-reward（区-出块奖励）"><a href="#4、Block-reward（区-出块奖励）" class="headerlink" title="4、Block reward（区&#x2F;出块奖励）"></a>4、Block reward（区&#x2F;出块奖励）</h3><p>获得记账权的节点，在发布的区块里可以进行 coinbase transaction（铸币交易），发布一定数量的比特币</p>
<p>一开始，每个发布的区块可以产生 50 BTC；21万个区块以后，出块奖励会减半为 25 BTC；再过21万个区块，会变成 12.5 BTC（现在）</p>
<p>平均出块时间为10分钟，出块奖励减半的时间：21w * 10min &#x2F; (60min * 24h * 365d) ≈ 4年</p>
<h3 id="5、基于-hash-rate-的共识方案"><a href="#5、基于-hash-rate-的共识方案" class="headerlink" title="5、基于 hash rate 的共识方案"></a>5、基于 hash rate 的共识方案</h3><p>Hash rate（计算 nonce 哈希的速度）决定了投票的权重，hash rate 越高，获得记账权并得到出块奖励的概率越大</p>
<p>避免 sybil attack（女巫攻击）：创建多个账户不会增加 hash rate，也不会增加投票权重</p>
<h2 id="七、类比"><a href="#七、类比" class="headerlink" title="七、类比"></a>七、类比</h2><p>挖矿：mining</p>
<p>比特币：digital gold</p>
<p>矿工（争夺记账权的节点）：minner</p>
]]></content>
      <categories>
        <category>Web3 - 北大肖臻-区块链技术与应用</category>
      </categories>
      <tags>
        <tag>web3</tag>
        <tag>共识协议</tag>
      </tags>
  </entry>
  <entry>
    <title>北大-区块链技术与应用3-数据结构</title>
    <url>/2025/01/02/32-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="一、Hash-Pointers（哈希指针）"><a href="#一、Hash-Pointers（哈希指针）" class="headerlink" title="一、Hash Pointers（哈希指针）"></a>一、Hash Pointers（哈希指针）</h2><p>哈希指针除了地址之外，还要保存地址的哈希值，用于检测结构体的内容是否被篡改</p>
<p>Block chain is a linked list using hash pointers.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/32/1.png"
                      alt="图1"
                ></p>
<p>区块链中的第一个区块叫 genesis block（创世区块），其 height（高度）为 0；最后一个区块叫 most recent block</p>
<p>后一个区块中的哈希指针是对前一区块的整体取哈希（包含前一区块中储存的哈希指针），可以实现 tamper-evident log（篡改证明记录）</p>
<p>修改一个区块，会导致其后所有区块的哈希发生改变。所以只需保存和比对最后一个哈希值，就能检测出对区块链中任何部位的修改</p>
<h2 id="二、Merkle-Tree（默克尔树）"><a href="#二、Merkle-Tree（默克尔树）" class="headerlink" title="二、Merkle Tree（默克尔树）"></a>二、Merkle Tree（默克尔树）</h2><p>Merkle tree 和 Binary tree 对比，就是把普通指针换成哈希指针</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/32/2.png"
                      alt="图2"
                ></p>
<p>只要记录并比对 root hash（根哈希值），就能检测出整个树中任何部位的修改</p>
<h3 id="区块结构"><a href="#区块结构" class="headerlink" title="区块结构"></a>区块结构</h3><p>每个区块包含 block header（块头） 和 block body（块身）</p>
<p>1、块头：包含 该区块的所有交易组成的 Merkle tree 的根哈希值，但没有具体的交易内容<br>2、块体：包含具体的交易列表</p>
<h3 id="比特币节点"><a href="#比特币节点" class="headerlink" title="比特币节点"></a>比特币节点</h3><p>比特币中的节点分为：</p>
<ul>
<li>full node, or fully validationg node（全节点）</li>
<li>light node, or light-weight node（轻节点）</li>
</ul>
<p>1、全节点：保存整个区块的内容，包括块头和块体（包含 tansaction list，即交易的具体信息）；会验证每一笔交易</p>
<p>2、轻节点：比如手机上的比特币钱包的APP，只保存块头；无法独立验证交易的合法性</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/32/3.png"
                      alt="图3"
                ></p>
<p>Merkle proof 指从交易发生到根哈希值的路径，可以向轻节点证明某笔交易写入了区块链，流程如下：</p>
<p>（1）轻节点向全节点请求图3中红色的哈希值</p>
<p>（2）然后根据交易和红色的哈希值，自底向上算出绿色的哈希值，直至算出根哈希值</p>
<p>（3）最后将算出的根哈希值，与轻节点块头中的哈希指针比较，一致则证明该交易发生在此区块</p>
<p>上述方法也叫做 proof of membership 或 proof of inclusion<br>假设最底层的交易数为n，验证交易存在的时间复杂度为：θ(log(n))</p>
<p>对于无序的 Merkle tree，proof of non-membership（验证交易不存在）的时间复杂度为线性 θ(n)，即一个一个试<br>对于 Sorted Merkle tree（对交易取哈希，并且按哈希值大小排序），上述验证的时间复杂度为 θ(log(n))，与二分法一致：只需要对其大小相邻的两个交易进行哈希值的校验，如果和根哈希一致，则证明该交易不存在</p>
<p>由于区块链中不需要做不存在证明，所以比特币中的 Merkle tree 不要求排序</p>
<p>除了区块链 和 Merkle tree，哈希指针还可以用在其他无环的链表中</p>
]]></content>
      <categories>
        <category>Web3 - 北大肖臻-区块链技术与应用</category>
      </categories>
      <tags>
        <tag>web3</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>北大-区块链技术与应用5-BTC系统的实现</title>
    <url>/2025/01/12/34-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-BTC%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>比特币采用 transaction-based ledger（基于交易的账本）模式，每个区块中记录交易信息（转账交易、铸币交易），系统上不记录交易信息</p>
<h2 id="一、UTXO"><a href="#一、UTXO" class="headerlink" title="一、UTXO"></a>一、UTXO</h2><p>比特币的全节点要维护一个数据结构 UTXO（Unspent Transaction Output，所有未被花出去的交易的输出 组成的集合）</p>
<p>一个交易可能有多个输出，即用户可以在一次交易中同时向多人转账（可以节省手续费）</p>
<p>比如：A 给 B 交易 5 BTC，B 将其交易出去；A 给 C 交易 3 BTC，但未交易出去。这是两个输出，但是只有 A 给 C 的交易在 UTXO 中</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/34/1.png"
                      alt="图1"
                ></p>
<p>UTXO 中的每个元素要给出产生这个输出的交易的哈希值（可理解为交易的ID），以及它在这个交易里是第几个输出，这两个信息可以定位一个 UTXO 中的输出</p>
<h3 id="UTXO-的用途："><a href="#UTXO-的用途：" class="headerlink" title="UTXO 的用途："></a>UTXO 的用途：</h3><p>在交易发生前，检查即将花出去的币是否在 UTXO 中，在才是合法的，快速校验双花攻击和凭空捏造</p>
<p>每笔交易会消耗掉 UTXO 中的一些输出，同时在 UTXO 中产生新的输出，total inputs &#x3D; total outputs（所有输入的金额 等于 所有输出的金额）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">total inputs ≈ total outputs</span><br><span class="line">    1 BTC         0.99 BTC</span><br></pre></td></tr></table></figure></div>

<h3 id="Transaction-fee（交易费）："><a href="#Transaction-fee（交易费）：" class="headerlink" title="Transaction fee（交易费）："></a>Transaction fee（交易费）：</h3><p>发布区块的节点（矿工）之所以会把他人的交易打包到新区块里，是因为 BTC 系统的第二个激励机制——交易费。通过把他人的交易打包到区块里，矿工会收取一些交易费（费用高的交易优先级就更高）</p>
<p>目前矿工挖矿、争夺记账权，主要目的还是为了获取出块奖励，但是随着出块奖励的减少；多年后，交易费可能会变成矿工的主要收益</p>
<h2 id="二、Account-based-ledger（基于账户的账本）"><a href="#二、Account-based-ledger（基于账户的账本）" class="headerlink" title="二、Account-based ledger（基于账户的账本）"></a>二、Account-based ledger（基于账户的账本）</h2><p>和比特币 transaction-based ledger（基于交易的账本）模式不同，以太坊采用 account-based ledger（基于账户的账本）模式，在这种模式中，系统需要显式地记录每个账户有多少币，查询更方便（不需要说明币的来源），但是隐私保护性不如比特币</p>
<h2 id="三、Block-Example"><a href="#三、Block-Example" class="headerlink" title="三、Block Example"></a>三、Block Example</h2><p>Block header 的详细字段：<a class="link"   href="https://developer.bitcoin.org/reference/block_chain.html" >https://developer.bitcoin.org/reference/block_chain.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>其中，nonce 和 merkle root hash 是可以改变的，通过改变 coinbase message 来改变 merkle root hash（coinbase message 可以看做 extra nonce）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/34/2.png"
                      alt="图3"
                ></p>
<p>在比特币的 POW（Power of work，工作量证明机制）中，矿工需要不断尝试不同的 nonce 和 coinbase message 组合，以找到一个满足目标哈希值的区块头，共有两层循环：</p>
<p>外层循环调整 coinbase 域 的 extra nonce，算出 block header 里的根哈希值之后，内层循环再调整 header 里的 nonce</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/34/3.png"
                      alt="图3"
                ></p>
<p>在比特币系统中，验证交易的合法性，就是通过将交易的 input scripts 和 output scripts 配对后执行来完成的。注意：不是把同一个交易的输入脚本和输入脚本配对，而是把这个交易里的输入脚本 和 前一个提供币来源的交易里的输出脚本配对。如果拼接在一起可以顺利执行，那么该交易就是合法的</p>
<h2 id="四、挖矿概率分析"><a href="#四、挖矿概率分析" class="headerlink" title="四、挖矿概率分析"></a>四、挖矿概率分析</h2><p>Bernoulli trial（伯努利试验）：A random experiment with binary outcome，比如：掷硬币</p>
<p>Bernoulli process（伯努利过程）：A sequence of independent Bernoulli trials</p>
<p>Porsson process（泊松过程）：试验次数很多，成功概率很小</p>
<p>伯努利过程的性质之一是 memoryless（无记忆性）&#x2F; progress free（与过程无关）：前面的实验结果对后面的实验结果无影响。由于挖矿的成功概率很小，所以可以用泊松过程近似</p>
<p>出块时间服从 Exponential distribution（指数分布），纵轴是 probability density（概率密度），横轴是 time to next block（出块时间）。注意这是整个系统的出块时间，不是每个具体矿工的出块时间，具体到每一个矿工，出块时间取决于矿工的算力占系统总算力的百分比</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/34/4.png"
                      alt="图3"
                ></p>
<p>如果不满足 progress free 这个性质，那么算力强的矿工会获得不成比例的优势，比如：A算力是B算力的10倍，但是A获得记账权的概率超过B的10倍。该性质正是挖矿公平性的保证</p>
<h2 id="五、比特币的总量"><a href="#五、比特币的总量" class="headerlink" title="五、比特币的总量"></a>五、比特币的总量</h2><p>产生的比特币数量构成一个 geometric series（几何序列）：21w * 50 + 21w * 25 + 21w* 12.5 + … &#x3D; 21w * 50 * (1 + 1&#x2F;2 + 1&#x2F;4 + …) &#x3D; 2100w</p>
<p>挖矿的过程对于维护比特币系统的安全性是至关重要的：Bitcoin is secured by mining，对于一个去中心化的系统，挖矿提供了一个凭借算力投票的有效手段，只要大部分算力掌握在诚实的节点手里，系统的安全性就能得到保证</p>
<h2 id="六、比特币的安全性"><a href="#六、比特币的安全性" class="headerlink" title="六、比特币的安全性"></a>六、比特币的安全性</h2><h3 id="1、偷币"><a href="#1、偷币" class="headerlink" title="1、偷币"></a>1、偷币</h3><p>偷币是不可能的，因为系统以最长链合法链为准，恶意节点产生的区块会变成孤儿区块被丢弃，并且恶意节点还会损失本应得的出块奖励</p>
<h3 id="2、双花攻击"><a href="#2、双花攻击" class="headerlink" title="2、双花攻击"></a>2、双花攻击</h3><p>可以通过 forking attack（分叉攻击）实现。区块插入的位置在刚开始挖矿的时候就决定，因为设置的 block header 里需要填写前一个区块的哈希值。</p>
<p>分叉攻击：首先制造等长的合法链，比如，M 向 A 转账交易，产生了不可逆的外部效果（如购买实体商品）；然后再将该交易回滚，留下 M 向自己转账的区块，则 M 可从中不当获利</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/34/5.png"
                      alt="图3"
                ></p>
<h4 id="如何防范分叉攻击？"><a href="#如何防范分叉攻击？" class="headerlink" title="如何防范分叉攻击？"></a>如何防范分叉攻击？</h4><p>多等几个区块 &#x2F; confirmation（确认），M 向 A 转账的交易刚写入区块的时候，叫 one confirmation，后面的区块类推。比特币协议中缺省的设置是：等待 6 个 confirmation 之后，才认为前面的交易是不可篡改的（大约1小时）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/34/6.png"
                      alt="图3"
                ></p>
<p>区块链是 Irrevocable ledger（不可篡改的账本），这种不可篡改性只是一种概率上的保证，刚刚写入区块链的内容还是比较容易被改变的，随着后续 confirmation 的增加，被篡改的概率会指数级大幅度下降</p>
<p>Zero confirmation：转账交易发布出去了，但是还未被写入区块链中。这种方式在实际应用中比较普遍，因为（1）比特币协议缺省的设置是 节点接收最先听到的那个交易，所以上述例子中 M 转给自己的交易大概率不会被诚实的节点接受；（2）很多购物网站从支付成功到发货天然是有时间间隔的</p>
<h3 id="3、恶意节点故意不把合法交易写入"><a href="#3、恶意节点故意不把合法交易写入" class="headerlink" title="3、恶意节点故意不把合法交易写入"></a>3、恶意节点故意不把合法交易写入</h3><p>因为总有诚实的节点愿意发布这些交易，所以合法交易总是可以被写到下一个区块里</p>
<p>在正常工作的情况下，也可能出现合法交易未被包含进去的情况，比如近期交易的数目太多。比特币协议中规定，每个区块的大小是有限制的，最多不能超过一兆字节，如果交易的数目太多，可能就只能等到下一个区块再发布</p>
<h3 id="Selfish-mining（自私挖矿）"><a href="#Selfish-mining（自私挖矿）" class="headerlink" title="Selfish mining（自私挖矿）"></a>Selfish mining（自私挖矿）</h3><p>正常情况下，挖到一个区块就立即发布，防止别人发布后自己的区块作废、丧失出块奖励</p>
<p>Selfish mining：挖到多个区块，但是都藏着不发布，攒够6个之后同时发布。这种攻击的前提是，有恶意的节点需要占据很大一部分算力（比如至少51%）</p>
<p>Selfish mining 的好处：如果个人算力较强，可以减少挖后续区块的竞争</p>
]]></content>
      <categories>
        <category>Web3 - 北大肖臻-区块链技术与应用</category>
      </categories>
      <tags>
        <tag>web3</tag>
        <tag>BTC</tag>
      </tags>
  </entry>
  <entry>
    <title>北大-区块链技术与应用6-BTC网络</title>
    <url>/2025/01/13/35-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-BTC%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="一、网络层级"><a href="#一、网络层级" class="headerlink" title="一、网络层级"></a>一、网络层级</h2><p>顶层是 application layer，运行着 BitCoin 和 Block chain 协议；底层是 network layer，运行着 P2P Overlay Network</p>
<p>比特币的 P2P 网络很简单，所有节点都是平等的，不像有的网络有 super node &#x2F; master node</p>
<h2 id="二、加入-离开网络"><a href="#二、加入-离开网络" class="headerlink" title="二、加入&#x2F;离开网络"></a>二、加入&#x2F;离开网络</h2><p>加入网络前，需要和 seed node（种子节点）联系，它会告知网络中的其他节点，节点之间通过 PCP 通信，有利于穿透防火墙；离开时不需要做任何操作，只需退出应用程序，其他节点会将一段时间未接收到消息的节点删除</p>
<p>比特币网络设计的原则是：simple, robust, but not efficient（简单、鲁棒，而不是高效）</p>
<h2 id="三、等待上链的集合"><a href="#三、等待上链的集合" class="headerlink" title="三、等待上链的集合"></a>三、等待上链的集合</h2><p>每个节点维护一个邻居节点的集合，消息传播在网络中采取 flooding（泛洪）的方式。节点第一次听到某个消息的时候，把它传播给其他所有的邻居节点，并记录已收到该消息，下次再收到时就不会再次转发。邻居节点的选取是随机的，不考虑底层的拓扑结构，这样设计可以增强鲁棒性，但牺牲了效率</p>
<p>比特币系统中，每个节点需要维护一个等待上链（写入区块链）的集合。第一次听到某个交易的时候，把交易加入该集合，并把该交易转发给邻居节点，下次就不再转发。转发的前提是交易是合法的：签名合法，之前未被花过</p>
<p>如果同时有两个冲突的交易被广播到网络上，比如：A 转钱给 B，A 又转钱给 C（双花），以首先被写入到区块链上的交易为准，交易被写入到区块链中即被等待上链的集合删除</p>
<h2 id="四、Best-effort"><a href="#四、Best-effort" class="headerlink" title="四、Best effort"></a>四、Best effort</h2><p>比特币网络的传播属于 best effort（尽最大努力），一个交易发送到比特币网络上，不一定所有节点能收到，且顺序也不一定，节点也不一定按照规则传播</p>
]]></content>
      <categories>
        <category>Web3 - 北大肖臻-区块链技术与应用</category>
      </categories>
      <tags>
        <tag>web3</tag>
        <tag>BTC</tag>
      </tags>
  </entry>
  <entry>
    <title>北大-区块链技术与应用7-挖矿难度</title>
    <url>/2025/01/13/36-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="一、挖矿难度和目标域值"><a href="#一、挖矿难度和目标域值" class="headerlink" title="一、挖矿难度和目标域值"></a>一、挖矿难度和目标域值</h2><p>H(block header) ≤ target</p>
<p>调整挖矿难度，就是调整目标空间 在整个输出空间中所占的比例，通俗地说，就是哈希值的前面有多少 0</p>
<p>比特币使用的哈希算法是 SHA-256，整个输出空间是 2^256 个可能的取值</p>
<p>挖矿难度和目标域值成反比：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/36/1.png"
                      alt="图1"
                ></p>
<p>difficulty_1_target：挖矿难度等于1时，对应的目标域值（挖矿难度最小就是1），此时的目标域值很大</p>
<h2 id="二、出块时间太短的后果"><a href="#二、出块时间太短的后果" class="headerlink" title="二、出块时间太短的后果"></a>二、出块时间太短的后果</h2><p>系统的总算力越强，安全性就越高，因为发动 51% attack（考虑2个分叉）的成本就更高</p>
<p>出块时间太短，但是传播速度较慢，很容易导致过多的 forking（分叉），系统的总算力就被分散了，更容易造成 forking attack，因为可以通过较小的算力（100%&#x2F;分叉数+1%）实现攻击</p>
<p>以太坊的出块时间是15s，出块速度是比特币的40倍，因此以太坊设计了新的共识协议 ghost，其中产生的 orphan block 就不能简单的丢弃，而是要给一些奖励（uncle reward）</p>
<h2 id="三、调整挖矿难度"><a href="#三、调整挖矿难度" class="headerlink" title="三、调整挖矿难度"></a>三、调整挖矿难度</h2><p>比特币协议规定每个2016个区块，需要调整目标域值，<code>2016*10/(60*24)≈14天</code></p>
<p>调整目标域值的公式：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/36/2.png"
                      alt="图2"
                ></p>
<p>其中，expected time（预期时间）是 2016*10，actual time（实际时间）是系统近期产生2016个区块所花费的时间。在实际代码中，上调和下调分别有4倍和1&#x2F;4的限度</p>
<h3 id="如何让所有的矿工同时调整域值？"><a href="#如何让所有的矿工同时调整域值？" class="headerlink" title="如何让所有的矿工同时调整域值？"></a>如何让所有的矿工同时调整域值？</h3><p>block header 中存储的 nBits 是目标域值编码的版本（将 target 的256字节 压缩到4字节）。如果有矿工不调整，那么校验就不会被通过</p>
]]></content>
      <categories>
        <category>Web3 - 北大肖臻-区块链技术与应用</category>
      </categories>
      <tags>
        <tag>web3</tag>
        <tag>BTC</tag>
      </tags>
  </entry>
  <entry>
    <title>北大-区块链技术与应用8-BTC挖矿</title>
    <url>/2025/01/13/37-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-BTC%E6%8C%96%E7%9F%BF/</url>
    <content><![CDATA[<h2 id="一、全节点"><a href="#一、全节点" class="headerlink" title="一、全节点"></a>一、全节点</h2><h3 id="1、一直在线"><a href="#1、一直在线" class="headerlink" title="1、一直在线"></a>1、一直在线</h3><h3 id="2、在本地硬盘上维护完整的区块链信息"><a href="#2、在本地硬盘上维护完整的区块链信息" class="headerlink" title="2、在本地硬盘上维护完整的区块链信息"></a>2、在本地硬盘上维护完整的区块链信息</h3><h3 id="3、在内存里维护-UTXO-集合，以便快速检验交易的正确性"><a href="#3、在内存里维护-UTXO-集合，以便快速检验交易的正确性" class="headerlink" title="3、在内存里维护 UTXO 集合，以便快速检验交易的正确性"></a>3、在内存里维护 UTXO 集合，以便快速检验交易的正确性</h3><p>UTXO（unspent transaction output）</p>
<h3 id="4、监听比特币网络上的交易信息，验证每个交易的合法性"><a href="#4、监听比特币网络上的交易信息，验证每个交易的合法性" class="headerlink" title="4、监听比特币网络上的交易信息，验证每个交易的合法性"></a>4、监听比特币网络上的交易信息，验证每个交易的合法性</h3><p>（1）是否有合法的签名</p>
<p>（2）是不是 double spending</p>
<h3 id="5、决定哪些交易会被打包到区块里"><a href="#5、决定哪些交易会被打包到区块里" class="headerlink" title="5、决定哪些交易会被打包到区块里"></a>5、决定哪些交易会被打包到区块里</h3><p>缺省状态下，只要是合法交易、并且交易费符合要求，就会被打包</p>
<h3 id="6、-监听别的矿工挖出来的区块，验证其合法性"><a href="#6、-监听别的矿工挖出来的区块，验证其合法性" class="headerlink" title="6、 监听别的矿工挖出来的区块，验证其合法性"></a>6、 监听别的矿工挖出来的区块，验证其合法性</h3><p>（1）区块中的每个交易都要合法，包括铸币交易，比如是否篡改了出块奖励、发布的难度是否符合要求（block header 取哈希后，前面是否有足够多的 0；block header 里的难度目标域值是否设置正确）</p>
<p>（2）全节点是否每两周调整挖矿难度</p>
<p>（3）检查该区块是否在延伸最长合法链</p>
<h3 id="7、挖矿"><a href="#7、挖矿" class="headerlink" title="7、挖矿"></a>7、挖矿</h3><h4 id="（1）决定沿着哪条链挖下去？"><a href="#（1）决定沿着哪条链挖下去？" class="headerlink" title="（1）决定沿着哪条链挖下去？"></a>（1）决定沿着哪条链挖下去？</h4><p>缺省情况下沿着最长合法链挖下去</p>
<h4 id="（2）当出现等长的分叉的时候，选择哪一个分叉？"><a href="#（2）当出现等长的分叉的时候，选择哪一个分叉？" class="headerlink" title="（2）当出现等长的分叉的时候，选择哪一个分叉？"></a>（2）当出现等长的分叉的时候，选择哪一个分叉？</h4><p>缺省情况下选择最先听到的分叉</p>
<h2 id="二、轻节点"><a href="#二、轻节点" class="headerlink" title="二、轻节点"></a>二、轻节点</h2><p>轻节点也叫做 spv client（simplified payment verification）</p>
<h3 id="1、不是一直在线"><a href="#1、不是一直在线" class="headerlink" title="1、不是一直在线"></a>1、不是一直在线</h3><h3 id="2、不用保存整个区块链，只要保存每个区块的块头"><a href="#2、不用保存整个区块链，只要保存每个区块的块头" class="headerlink" title="2、不用保存整个区块链，只要保存每个区块的块头"></a>2、不用保存整个区块链，只要保存每个区块的块头</h3><p>大约是全节点的 1&#x2F;1000</p>
<h3 id="3、不用保存全部交易，只保存与自己相关的交易"><a href="#3、不用保存全部交易，只保存与自己相关的交易" class="headerlink" title="3、不用保存全部交易，只保存与自己相关的交易"></a>3、不用保存全部交易，只保存与自己相关的交易</h3><h3 id="4、无法检验大多数交易的合法性，只能检验与自己相关-的那些交易的合法性"><a href="#4、无法检验大多数交易的合法性，只能检验与自己相关-的那些交易的合法性" class="headerlink" title="4、无法检验大多数交易的合法性，只能检验与自己相关 的那些交易的合法性"></a>4、无法检验大多数交易的合法性，只能检验与自己相关 的那些交易的合法性</h3><h3 id="5、无法检测网上发布的区块的正确性"><a href="#5、无法检测网上发布的区块的正确性" class="headerlink" title="5、无法检测网上发布的区块的正确性"></a>5、无法检测网上发布的区块的正确性</h3><h3 id="6、可以验证挖矿的难度"><a href="#6、可以验证挖矿的难度" class="headerlink" title="6、可以验证挖矿的难度"></a>6、可以验证挖矿的难度</h3><p>因为挖矿的时候，计算哈希值只用到了块头的信息</p>
<h3 id="7、只能检测哪个是最长链，不知道哪个是最长合法链"><a href="#7、只能检测哪个是最长链，不知道哪个是最长合法链" class="headerlink" title="7、只能检测哪个是最长链，不知道哪个是最长合法链"></a>7、只能检测哪个是最长链，不知道哪个是最长合法链</h3><p>因为无法检测这条链上所包含的交易都是合法的（不过可以检测每个区块是否符合难度要求）</p>
<h2 id="三、挖矿的注意事项"><a href="#三、挖矿的注意事项" class="headerlink" title="三、挖矿的注意事项"></a>三、挖矿的注意事项</h2><p>比特币网络中大部分节点都是轻节点，如果只想进行转账，而不进行挖矿，就不需要运行全节点、只需使用轻节点</p>
<p>在挖矿过程中，如果监听到别人发布了一个区块，需要重新组装区块（block header 和 交易内容都有变化）、重新开始挖</p>
<h2 id="四、比特币的安全性保证"><a href="#四、比特币的安全性保证" class="headerlink" title="四、比特币的安全性保证"></a>四、比特币的安全性保证</h2><h3 id="1、密码学"><a href="#1、密码学" class="headerlink" title="1、密码学"></a>1、密码学</h3><p>恶意节点拿不到私钥，就无法伪造签名，也就无法偷币</p>
<h3 id="2、好节点占大部分算力"><a href="#2、好节点占大部分算力" class="headerlink" title="2、好节点占大部分算力"></a>2、好节点占大部分算力</h3><p>前提是系统中大部分算力的矿工是遵守协议的</p>
<h2 id="五、挖矿趋势一：设备从通用到专用"><a href="#五、挖矿趋势一：设备从通用到专用" class="headerlink" title="五、挖矿趋势一：设备从通用到专用"></a>五、挖矿趋势一：设备从通用到专用</h2><h3 id="1、CPU"><a href="#1、CPU" class="headerlink" title="1、CPU"></a>1、CPU</h3><p>最早是用普通的 CPU &#x2F; 通用计算机 挖矿，但是这种方式无法充分利用内存</p>
<h3 id="2、GPU"><a href="#2、GPU" class="headerlink" title="2、GPU"></a>2、GPU</h3><p>GPU 用于大规模的并行计算，比如深度学习大量的矩阵乘法，但也部分部件也无法充分利用（比如浮点数运算）</p>
<h3 id="3、ASIC-芯片"><a href="#3、ASIC-芯片" class="headerlink" title="3、ASIC 芯片"></a>3、ASIC 芯片</h3><p>ASIC（Application Specific Integrated Circuit，专用集成电路），ASIC 芯片是专门为比特币挖矿计算哈希值而设计，性价比最高</p>
<p>但是同一个芯片只能用于一种币的挖矿，除非两种币使用同一个 mining puzzle。有些新开发的币会使用已有币的 mining puzzle，进而吸引更多矿工，这叫做 merge mining</p>
<p>购买 ASIC 矿机的时机很重要，因为过时得很快，现在一般需要提前预定。不良厂商可能会在矿机生产后的黄金两个月先自己挖矿，然后才卖给用户</p>
<p>有些新型货币，设计的是 alternative mining puzzle，出发点是 ASIC resistance，目的是让通用计算机也能参与挖矿过程</p>
<h2 id="六、挖矿趋势二：大型矿池的出现"><a href="#六、挖矿趋势二：大型矿池的出现" class="headerlink" title="六、挖矿趋势二：大型矿池的出现"></a>六、挖矿趋势二：大型矿池的出现</h2><p>矿池的出现是为了解决单个矿工收入不稳定的问题。矿池把矿工组织起来作为一个整体，其架构是：一个全节点驱动多个矿机</p>
<p>一个矿池一般有一个 pool manager（矿主），下面连着很多 minner（矿工），矿工只负责通过 ASIC 芯片计算哈希值，全节点的其他职责都由矿主承担（比如监听网络上的交易，并将其打包成一个候选区块，同时监听是否有其他节点抢先发布区块）</p>
<h3 id="矿池的收益分配"><a href="#矿池的收益分配" class="headerlink" title="矿池的收益分配"></a>矿池的收益分配</h3><p>矿池一般有两种组织形式：</p>
<p>（1）类似大型数据中心，所有矿机属于同一个机构</p>
<p>（2）分布式的，矿工和矿主不在同一个地方，矿工加入矿池，是通过矿池规定的通讯协议和矿主进行联系。矿主把要计算的哈希值的任务分配给矿工，矿工计算完成后把结果返回给矿主，有出块奖励时一起参与分红</p>
<p>通过工作量证明，按照矿工的贡献大小分配收益：降低挖矿难度（减少目标域值前0的数量），符合条件的叫一个 share（almost valid block），挖到合法区块、得到出块奖励之后，矿主按照矿工 share 的数量来分配收益</p>
<h3 id="1、矿工是否能偷出块奖励？"><a href="#1、矿工是否能偷出块奖励？" class="headerlink" title="1、矿工是否能偷出块奖励？"></a>1、矿工是否能偷出块奖励？</h3><p>矿工不可能挖到一个合法区块自己偷偷发布，因为矿工的任务由矿主分配，矿主负责组装区块，并把不同的 coinbase parameter 所对应的 nonce，交给不同的矿工尝试，而 coinbase transaction 里的收款人地址填的是矿主的地址</p>
<h3 id="2、矿工是否能捣乱？"><a href="#2、矿工是否能捣乱？" class="headerlink" title="2、矿工是否能捣乱？"></a>2、矿工是否能捣乱？</h3><p>是可以的，比如 矿工正常提交 share，但是挖到合法区块之后就丢弃掉</p>
<h3 id="3、矿池的弊端"><a href="#3、矿池的弊端" class="headerlink" title="3、矿池的弊端"></a>3、矿池的弊端</h3><p>恶意方可能吸引到足够多的矿工（不明真相的群众）加入，然后发动 51% attack：</p>
<p>（1）Forking attack：制造分叉，因为算力高，迟早能赶超6个区块；</p>
<p>（2）Boycott：制裁对象一挖出区块，就分叉，因为算力高，更容易使制裁对象的区块作废</p>
<p>类似于云计算中的 on demand computing，平时不用自己去维护很大的计算集群，需要用的时候可以随时召唤，对于矿池来说就是 on demand mining</p>
]]></content>
      <categories>
        <category>Web3 - 北大肖臻-区块链技术与应用</category>
      </categories>
      <tags>
        <tag>web3</tag>
        <tag>BTC</tag>
      </tags>
  </entry>
  <entry>
    <title>北大-区块链技术与应用10-BTC分叉</title>
    <url>/2025/01/14/39-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-BTC%E5%88%86%E5%8F%89/</url>
    <content><![CDATA[<h2 id="一、State-fork（状态分叉）"><a href="#一、State-fork（状态分叉）" class="headerlink" title="一、State fork（状态分叉）"></a>一、State fork（状态分叉）</h2><p>State fork：对比特币当前的状态有分歧造成的分叉，比如两个区块几乎同时生成，造成的分叉</p>
<p>Forking attack 也属于 state fork，但是是人为故意的，所以也叫做 deliberate fork（故意分叉）</p>
<h2 id="二、Protocol-fork（协议分叉）"><a href="#二、Protocol-fork（协议分叉）" class="headerlink" title="二、Protocol fork（协议分叉）"></a>二、Protocol fork（协议分叉）</h2><p>Protocol fork：比特币的协议发生改变（通过软件升级），有些节点由于各种原因可能暂时没有升级，从而造成的分叉</p>
<p>根据对协议修改的内容的不同，可以分为 hard fork（硬分叉）和 soft fork（软分叉）</p>
<h3 id="1、Hard-fork"><a href="#1、Hard-fork" class="headerlink" title="1、Hard fork"></a>1、Hard fork</h3><p><strong>新节点发布的区块，旧节点可能不认</strong></p>
<p>1个交易约为250字节，一个区块约有 1000,000字节&#x2F;250字节&#x3D;4000个交易，每秒约有 4000&#x2F;(60*10)≈7个交易，数量过少</p>
<p>假设 Block size limit 从 1M 更新到 4M，大多数算力的节点更新了软件，但少部分未更新。只要仍有部分节点未更新软件，该分叉就不会消失</p>
<h4 id="Example：ETH-ETC"><a href="#Example：ETH-ETC" class="headerlink" title="Example：ETH &amp; ETC"></a>Example：ETH &amp; ETC</h4><p>2016年，以太坊的 DAO（去中心化自治组织）遭到黑客攻击，导致大量ETH被盗。部分成员支持通过硬分叉回滚交易、恢复被盗资金，而另一些成员认为这会破坏区块链的不可篡改性</p>
<p>最终社区实施硬分叉，恢复到攻击前的状态，这条新链称为 Ethereum（ETH）；而反对硬分叉的用户继续使用原链，称为 Ethereum Classic（ETC），从此两种货币独立发展（通过chain ID 区分两条链）</p>
<h3 id="2、Soft-fork"><a href="#2、Soft-fork" class="headerlink" title="2、Soft fork"></a>2、Soft fork</h3><p><strong>新节点发布的区块，旧节点仍会认可</strong></p>
<p>假设 Block size limit 从 1M 更新到 0.5M，大多数算力的节点更新了软件，但少部分未更新。如果有节点不更新软件，可能会经常产生孤儿区块，所以最终所有节点都会更新，分叉不会继续延展</p>
<h4 id="Example：P2SH（Pay-to-Script-Hash）"><a href="#Example：P2SH（Pay-to-Script-Hash）" class="headerlink" title="Example：P2SH（Pay to Script Hash）"></a>Example：P2SH（Pay to Script Hash）</h4><p>P2SH 的验证分为两步：（1）验证输入脚本给出的赎回脚本，和前一个交易的输出脚本给出的 赎回脚本的哈希值 对得上；（2）执行赎回脚本，验证输入脚本给出的签名是合法的</p>
<p>对于旧节点来说，只会进行第一阶段的认证；所以新节点认为合法的区块，旧节点仍然会认可</p>
<h3 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h3><p>（1）Soft fork：只要系统有半数以上的节点更新，就不会有永久的分叉</p>
<p>（2）Hard fork：如果不是所有的节点都更新了，就会有永久的分叉。根本原因是旧节点不认可新链（不是合法最长链），所以会按照旧链执行</p>
]]></content>
      <categories>
        <category>Web3 - 北大肖臻-区块链技术与应用</category>
      </categories>
      <tags>
        <tag>web3</tag>
        <tag>BTC</tag>
      </tags>
  </entry>
  <entry>
    <title>北大-区块链技术与应用11-课堂回答</title>
    <url>/2025/01/15/40-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-%E8%AF%BE%E5%A0%82%E5%9B%9E%E7%AD%94/</url>
    <content><![CDATA[<p>略（基本没有新东西），详情可参考课程视频：</p>
<p><a class="link"   href="https://www.bilibili.com/video/BV1Vt411X7JF?spm_id_from=333.788.videopod.episodes&vd_source=69ac93649ea21c4726fe85f272b6d968&p=11" >https://www.bilibili.com/video/BV1Vt411X7JF?spm_id_from=333.788.videopod.episodes&amp;vd_source=69ac93649ea21c4726fe85f272b6d968&amp;p=11 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>Web3 - 北大肖臻-区块链技术与应用</category>
      </categories>
      <tags>
        <tag>web3</tag>
      </tags>
  </entry>
  <entry>
    <title>北大-区块链技术与应用12-BTC的匿名性</title>
    <url>/2025/01/15/41-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-BTC%E5%8C%BF%E5%90%8D%E6%80%A7/</url>
    <content><![CDATA[<h2 id="一、比特币的匿名性"><a href="#一、比特币的匿名性" class="headerlink" title="一、比特币的匿名性"></a>一、比特币的匿名性</h2><p>anonimity（匿名性）、privacy（隐私性）</p>
<p>比特币使用的是 pseudonymity（假名）</p>
<p>Example：一个人通过自己的两个账户 addr1 和 addr2，向商家账户转账 addr3，然后把零钱转入自己的另一个账户 addr4</p>
<p>Inputs: addr1, addr2</p>
<p>Outputs: addr3, addr4</p>
<h3 id="1、破坏比特币匿名性的方法："><a href="#1、破坏比特币匿名性的方法：" class="headerlink" title="1、破坏比特币匿名性的方法："></a>1、破坏比特币匿名性的方法：</h3><p>（1）比特币不同账户之间可以进行关联</p>
<p>（2）比特币可以和实体世界相关联</p>
<h3 id="2、Silk-road（丝路）"><a href="#2、Silk-road（丝路）" class="headerlink" title="2、Silk road（丝路）"></a>2、Silk road（丝路）</h3><p>Silk road 是一个非法交易平台，被称为 eBay for illegal drugs，支付手段采用比特币，底层路由采用 TOR（洋葱路由），提供匿名邮寄服务，后被封禁</p>
<p>这说明比特币的匿名性并没有那么好</p>
<h3 id="3、如何提高自己比特币的匿名性？"><a href="#3、如何提高自己比特币的匿名性？" class="headerlink" title="3、如何提高自己比特币的匿名性？"></a>3、如何提高自己比特币的匿名性？</h3><h4 id="（1）Network-layer"><a href="#（1）Network-layer" class="headerlink" title="（1）Network layer"></a>（1）Network layer</h4><p>采用多路由转发，比如 TOR（洋葱路由）</p>
<h4 id="（2）Application-layer"><a href="#（2）Application-layer" class="headerlink" title="（2）Application layer"></a>（2）Application layer</h4><p>Coin mixing（混币交易），即把不同人的币混起来。交易所天然具有 coin mixing 的性质，前提是交易所不会泄露任何交易记录</p>
<h2 id="二、Zero-knowledge-proof（零知识证明）"><a href="#二、Zero-knowledge-proof（零知识证明）" class="headerlink" title="二、Zero-knowledge proof（零知识证明）"></a>二、Zero-knowledge proof（零知识证明）</h2><p>零知识证明：指证明方向验证者证明一个陈述是正确的，而无需泄露额外的任何信息</p>
<h3 id="同态隐藏"><a href="#同态隐藏" class="headerlink" title="同态隐藏"></a>同态隐藏</h3><h4 id="（1）不会碰撞：如果-x-y-不同，那么它们的加密函数值-E-x-和-E-y-也不相同，其逆否命题也成立"><a href="#（1）不会碰撞：如果-x-y-不同，那么它们的加密函数值-E-x-和-E-y-也不相同，其逆否命题也成立" class="headerlink" title="（1）不会碰撞：如果 x, y 不同，那么它们的加密函数值 E(x) 和 E(y) 也不相同，其逆否命题也成立"></a>（1）不会碰撞：如果 x, y 不同，那么它们的加密函数值 E(x) 和 E(y) 也不相同，其逆否命题也成立</h4><h4 id="（2）隐私性：给定-E-x-的值，很难反推出-x-的值"><a href="#（2）隐私性：给定-E-x-的值，很难反推出-x-的值" class="headerlink" title="（2）隐私性：给定 E(x) 的值，很难反推出 x 的值"></a>（2）隐私性：给定 E(x) 的值，很难反推出 x 的值</h4><h4 id="（3）给定-E-x-和-E-y-的值，我们可以很容易地计算出某些关于-x-y-的加密函数值"><a href="#（3）给定-E-x-和-E-y-的值，我们可以很容易地计算出某些关于-x-y-的加密函数值" class="headerlink" title="（3）给定 E(x) 和 E(y) 的值，我们可以很容易地计算出某些关于 x, y 的加密函数值"></a>（3）给定 E(x) 和 E(y) 的值，我们可以很容易地计算出某些关于 x, y 的加密函数值</h4><ul>
<li>同态加法：通过 E(x) 和 E(y) 计算出 E(x+y) 的值</li>
<li>同态乘法：通过 E(x) 和 E(y) 计算出 E(xy) 的值</li>
<li>扩展到多项式</li>
</ul>
<h2 id="三、零币和零钞"><a href="#三、零币和零钞" class="headerlink" title="三、零币和零钞"></a>三、零币和零钞</h2><p>零币（zerocoin）和零钞（zerocash）融合了匿名化处理，但仍未解决与实体世界相关联导致的隐私泄露问题</p>
]]></content>
      <categories>
        <category>Web3 - 北大肖臻-区块链技术与应用</category>
      </categories>
      <tags>
        <tag>web3</tag>
        <tag>BTC</tag>
      </tags>
  </entry>
  <entry>
    <title>北大-区块链技术与应用9-BTC脚本</title>
    <url>/2025/01/14/38-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-BTC%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>本节课较多用到 PPT 上的动画，视频链接如下：</p>
<p><a class="link"   href="https://www.bilibili.com/video/BV1Vt411X7JF?spm_id_from=333.788.player.switch&vd_source=69ac93649ea21c4726fe85f272b6d968&p=9" >https://www.bilibili.com/video/BV1Vt411X7JF?spm_id_from=333.788.player.switch&amp;vd_source=69ac93649ea21c4726fe85f272b6d968&amp;p=9 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>比特币使用的编程语言很简单，内存空间只有一个通用的堆栈</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/38/1.png"
                      alt="图1"
                ></p>
<p>上述的输入脚本包含2个操作：分别把2个很长的数压入栈里</p>
<p>输出脚本有2行，分别对应上面的2个输出，每个输出有自己单独的脚本</p>
<h1 id="BTC-脚本校验方式"><a href="#BTC-脚本校验方式" class="headerlink" title="BTC 脚本校验方式"></a>BTC 脚本校验方式</h1><p>假设 A-&gt;B，B-&gt;C，下面对 B 交易时币的来源做校验，有两种校验方式</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/38/2.png"
                      alt="图2"
                ></p>
<h2 id="1、P2PK（Pay-to-Public-Key）"><a href="#1、P2PK（Pay-to-Public-Key）" class="headerlink" title="1、P2PK（Pay to Public Key）"></a>1、P2PK（Pay to Public Key）</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">input script:</span><br><span class="line">    PUSHDATA(Sig)</span><br><span class="line"></span><br><span class="line">output script:</span><br><span class="line">    PUSHDATA(PubKey)</span><br><span class="line">    CHECKSIG</span><br></pre></td></tr></table></figure></div>

<p>1、PUSHDATA(Sig)：把 B 的签名入栈——来自输入脚本</p>
<p>2、PUSHDATA(PubKey)：把 B 的公钥入栈——来自输出脚本</p>
<p>3、CHECKSIG：弹出栈顶的两个元素（公钥和签名），用公钥验签，通过则返回 TRUE</p>
<h2 id="2、P2PKH（Pay-to-Public-Key-Hash）——最常用"><a href="#2、P2PKH（Pay-to-Public-Key-Hash）——最常用" class="headerlink" title="2、P2PKH（Pay to Public Key Hash）——最常用"></a>2、P2PKH（Pay to Public Key Hash）——最常用</h2><p>P2PKH 与 P2PK 的区别是：输出脚本给出的不是公钥，而是公钥的哈希值；输入脚本除了签名外，还需要给出公钥</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">input script:</span><br><span class="line">    PUSHDATA(Sig)</span><br><span class="line">    PUSHDATA(PubKey)</span><br><span class="line"></span><br><span class="line">output script:</span><br><span class="line">    DUP</span><br><span class="line">    HASH160</span><br><span class="line">    PUSHDATA(PubKeyHash)</span><br><span class="line">    EQUALVERIFY</span><br><span class="line">    CHECKSIG</span><br></pre></td></tr></table></figure></div>

<p>1、PUSHDATA(Sig)：把 B 的签名入栈——来自输入脚本</p>
<p>2、PUSHDATA(PubKey)：把 B 的公钥入栈——来自输入脚本</p>
<p>3、DUP：把栈顶的元素复制一遍（即 B 的公钥）</p>
<p>4、HASH160：把栈顶元素弹出，并取哈希（即对 B 的公钥取哈希），然后把得到的哈希再压入栈</p>
<p>5、PUSHDATA(PubKeyHash)：把 B 的公钥哈希入栈——来自输出脚本</p>
<p>6、EQUALVERIFY 是弹出栈顶的两个元素（哈希值），并比较它们是否相等</p>
<p>7、CHECKSIG：弹出栈顶的两个元素（公钥和签名），用公钥验签，通过则返回 TRUE</p>
<h2 id="3、P2SH（Pay-to-Script-Hash）——最复杂"><a href="#3、P2SH（Pay-to-Script-Hash）——最复杂" class="headerlink" title="3、P2SH（Pay to Script Hash）——最复杂"></a>3、P2SH（Pay to Script Hash）——最复杂</h2><p>P2SH 的特点是 input script 要提供一个 redeem script（赎回脚本）</p>
<p>P2SH 常见的应用场景是对 multiple signature（多重签名，即一个输出要求多个签名才能把钱取出，目前已不推荐）的支持</p>
<p>验证分为两个阶段：第一阶段按照输入脚本和输出脚本的顺序执行；第二阶段执行赎回脚本</p>
<p>具体略，有点复杂，可简单理解为把 P2PKH 中的 PUSHDATA(PubKey) 和 CHECKSIG 提取成一个赎回脚本</p>
<h2 id="4、Proof-of-Burn"><a href="#4、Proof-of-Burn" class="headerlink" title="4、Proof of Burn"></a>4、Proof of Burn</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">output script:</span><br><span class="line">    RETURN</span><br><span class="line">        [Zero or more ops or text]</span><br></pre></td></tr></table></figure></div>

<p>这种类型的输出被称为：Provably Unspendable（可证明不可花费） &#x2F; Prunable Outputs（可删减输出）</p>
<p>这个脚本是证明销毁掉比特币的一种方法，有两种应用场景：（1）有些小的币种要求销毁一定数量的比特币才能够得到该币，这种币叫做 AltCoin（Alternative Coin）；（2）往区块链中写入一些内容，比如 digital commitment，把知识产权取哈希放在 return 后面，可以证明在某个时间点知道某个知识，任何用户都可以通过销毁少量比特币（将币转到不存在的地址）、换取向区块链写入的机会（不提倡，因为该交易会永久保留在 UTXO 中，浪费资源）</p>
<p>注意：以上的 CHECKSIG 全称是 OP_CHECKSIG，DUP 全程是 OP_DUP</p>
]]></content>
      <categories>
        <category>Web3 - 北大肖臻-区块链技术与应用</category>
      </categories>
      <tags>
        <tag>web3</tag>
        <tag>BTC</tag>
      </tags>
  </entry>
  <entry>
    <title>北大-区块链技术与应用13-BTC引发的思考</title>
    <url>/2025/01/15/42-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-BTC%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h2 id="一、哈希指针"><a href="#一、哈希指针" class="headerlink" title="一、哈希指针"></a>一、哈希指针</h2><p>指针保存的是本地的内存地址，区块链中的哈希指针是如何传递的？其实区块中保存的只有哈希，没有指针（只是形象化的说法）。全节点会把区块以 (key, value) 存储在数据库（level DB）中，且只保存最近的几千个区块</p>
<h2 id="二、区块恋"><a href="#二、区块恋" class="headerlink" title="二、区块恋"></a>二、区块恋</h2><p>双方把私钥截成两段，每方保存一段不可取，有两点问题：</p>
<ul>
<li>蛮力攻击更加容易</li>
<li>永久占据 UTXO，浪费资源</li>
</ul>
<p>建议采取 MULTISIG（多重签名）</p>
<h2 id="三、比特币中的稀缺性"><a href="#三、比特币中的稀缺性" class="headerlink" title="三、比特币中的稀缺性"></a>三、比特币中的稀缺性</h2><p>比特币的总量是确定的，这种“稀缺”的东西不适合作为货币，一个好的货币需要有通货膨胀的功能；否则随着社会财富的增加，总量一定的货币会越来越值钱，先来者躺平，后来者买不起（类比国内房地产）</p>
<h2 id="四、量子计算"><a href="#四、量子计算" class="headerlink" title="四、量子计算"></a>四、量子计算</h2><p>量子计算技术离使用还差的很远，就算有一天量子计算能够破解现有的加密体系，首先冲击的是传统金融业；并且后面还会有量子加密算法</p>
<p>比特币并没有直接暴露账户的公钥，而是把公钥取哈希得到一个地址。假设量子计算使得从公钥推出私钥变为可能，比特币还有另一层防护：使用的是公钥哈希，首先需要通过地址推出公钥，而取哈希是不可逆的，因为取哈希的过程中存在信息丢失（比如任意长度的公钥都能通过 SHA-256 压缩成 256位）</p>
<p>从 安全性 和 隐私保护 的角度看，比特币的一个地址一旦用过后，就不要再用了，每次从一个地址取钱时，最好把所有钱都取走，除了支付的钱，剩下的转给自己的另外一个账户</p>
<p>如果担心量子计算的威胁，即使是公钥也不要随意泄露</p>
]]></content>
      <categories>
        <category>Web3 - 北大肖臻-区块链技术与应用</category>
      </categories>
  </entry>
  <entry>
    <title>北大-区块链技术与应用14-ETH概述</title>
    <url>/2025/01/15/43-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-ETH%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>比特币被称为 区块链1.0，以太坊被称为 区块链2.0</p>
<h2 id="一、以太坊和区块链的对比"><a href="#一、以太坊和区块链的对比" class="headerlink" title="一、以太坊和区块链的对比"></a>一、以太坊和区块链的对比</h2><h3 id="1、出块时间"><a href="#1、出块时间" class="headerlink" title="1、出块时间"></a>1、出块时间</h3><p>以太坊的出块时间从比特币的 10分钟 降低到了十几秒</p>
<h3 id="2、共识机制"><a href="#2、共识机制" class="headerlink" title="2、共识机制"></a>2、共识机制</h3><p>以太坊设计了新的 ghost 共识机制</p>
<h3 id="3、mining-puzzle"><a href="#3、mining-puzzle" class="headerlink" title="3、mining puzzle"></a>3、mining puzzle</h3><p>以太坊设计了新的 mining puzzle：比特币的 mining puzzle 是计算型的，比拼的是算力；而以太坊的 mining puzzle 是 memory hard，对内存的要求很高，从而限制了 ASIC 芯片的使用（ASIC resistance）</p>
<h3 id="4、证明机制"><a href="#4、证明机制" class="headerlink" title="4、证明机制"></a>4、证明机制</h3><p>以太坊用 POS（proof of stake，权益证明） 来替代 POW（proof of work，工作量证明）</p>
<h3 id="5、智能合约"><a href="#5、智能合约" class="headerlink" title="5、智能合约"></a>5、智能合约</h3><p>以太坊增加了对 smart contract（智能合约）的支持</p>
<h4 id="（1）BitCoin：decentralized-currency（去中心化货币）"><a href="#（1）BitCoin：decentralized-currency（去中心化货币）" class="headerlink" title="（1）BitCoin：decentralized currency（去中心化货币）"></a>（1）BitCoin：decentralized currency（去中心化货币）</h4><p>在跨国转账方面，fiat currency（法定货币）不如比特币</p>
<h4 id="（2）Etherem：decentralized-contract（去中心化协议）"><a href="#（2）Etherem：decentralized-contract（去中心化协议）" class="headerlink" title="（2）Etherem：decentralized contract（去中心化协议）"></a>（2）Etherem：decentralized contract（去中心化协议）</h4><p>类似的，在跨国协议方面，去中心化协议也有优势</p>
<h3 id="6、最小单位"><a href="#6、最小单位" class="headerlink" title="6、最小单位"></a>6、最小单位</h3><p>比特币的最小单位是 Satoshi（聪）；而以太坊的货币叫做 Ether（以太），最小单位是 Wei</p>
]]></content>
      <categories>
        <category>Web3 - 北大肖臻-区块链技术与应用</category>
      </categories>
      <tags>
        <tag>web3</tag>
        <tag>ETH</tag>
      </tags>
  </entry>
  <entry>
    <title>北大-区块链技术与应用15-ETH的账户</title>
    <url>/2025/01/15/44-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-ETH%E8%B4%A6%E6%88%B7/</url>
    <content><![CDATA[<h2 id="一、比特币——基于交易的账本"><a href="#一、比特币——基于交易的账本" class="headerlink" title="一、比特币——基于交易的账本"></a>一、比特币——基于交易的账本</h2><p>比特币用的是 transaction-based ledger（基于交易的账本），系统没有显示地记录账户的金额，需要通过 UTXO 计算，这种方式隐私性好，但不便于使用</p>
<h2 id="二、以太坊——基于账户的账本"><a href="#二、以太坊——基于账户的账本" class="headerlink" title="二、以太坊——基于账户的账本"></a>二、以太坊——基于账户的账本</h2><p>以太坊用的是 account-based ledger（基于账户的账本），转账时不需要说明币的来源</p>
<h3 id="1、好处"><a href="#1、好处" class="headerlink" title="1、好处"></a>1、好处</h3><p>不会出现 double spending attack（双花攻击——花钱的人不诚实）</p>
<h3 id="2、缺点"><a href="#2、缺点" class="headerlink" title="2、缺点"></a>2、缺点</h3><p>需要预防 replay attack（重放攻击——收钱的人不诚实），一次交易被恶意节点广播多次</p>
<p>通过增加一个计数器 nonce，用来记录某账户交易的次数，转账时交易次数要成为交易内容的一部分，都受到发布交易者签名的保护；如果发起重放攻击，交易中 nonce 的值和计数器的值相等，会被校验为不合法（合法的应该比计数器大 1）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/44/1.png"
                      alt="图一"
                ></p>
<h2 id="三、以太坊的账户类型"><a href="#三、以太坊的账户类型" class="headerlink" title="三、以太坊的账户类型"></a>三、以太坊的账户类型</h2><h3 id="1、Extranally-owned-account（外部账户）"><a href="#1、Extranally-owned-account（外部账户）" class="headerlink" title="1、Extranally owned account（外部账户）"></a>1、Extranally owned account（外部账户）</h3><p>外部账户类似于比特币的账户，通过公私钥控制，也叫做普通账户。一个外部账户的状态有 balance（账户余额）和 nonce（计数器）</p>
<h3 id="2、Smart-contract-account（合约账户）"><a href="#2、Smart-contract-account（合约账户）" class="headerlink" title="2、Smart contract account（合约账户）"></a>2、Smart contract account（合约账户）</h3><p>合约账户不是通过公私钥对控制，不能主动发起交易（只有外部账户可以）。合约账户除了 balance（账户余额），nonce（计数器），还有 code（代码） 和 storage（状态&#x2F;存储）</p>
<p>合约账户如何调用？创建合约时，会返回一个地址，知道合约的地址，就能调用合约，调用过程中状态会发生变化，但是代码是不变的</p>
<p>以太坊的创始人是 Vitalik。现在有人提出用智能合约生成一些 financial derivative（金融衍生品），比如：期权、期货</p>
]]></content>
      <categories>
        <category>Web3 - 北大肖臻-区块链技术与应用</category>
      </categories>
      <tags>
        <tag>web3</tag>
        <tag>ETH</tag>
      </tags>
  </entry>
  <entry>
    <title>北大-区块链技术与应用16-ETH中的状态树</title>
    <url>/2025/01/15/45-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-ETH%E7%8A%B6%E6%80%81%E6%A0%91/</url>
    <content><![CDATA[<p>从账户地址到账户状态的映射：addr -&gt; state</p>
<p>以太坊中的账户地址是 160 bits，也就是 20字节，一般表示为 40个 16进制的数；比特币和以太坊的地址格式、长度都不同，但是以太坊中的地址也是由公钥转换来的（公钥取哈希、进行截取，并只保留后面）</p>
<p>在比特币中，merkle tree 除了证明账户上有多少钱之外，还可以维护各个全节点之间状态的一致性</p>
<h2 id="以太坊的状态树结构"><a href="#以太坊的状态树结构" class="headerlink" title="以太坊的状态树结构"></a>以太坊的状态树结构</h2><p>以太坊采用的数据结构是 MPT（‌Merkle Patricia Tree，默克尔前缀树&#x2F;压缩前缀树），基于 trie（单词查找树）</p>
<h3 id="一、Trie"><a href="#一、Trie" class="headerlink" title="一、Trie"></a>一、Trie</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/45/1.png"
                      alt="图一"
                ></p>
<h4 id="1、优点"><a href="#1、优点" class="headerlink" title="1、优点"></a>1、优点</h4><p>（1）Trie 每个节点的分支数目，取决于 key 每个元素的取值范围，以太坊的 branching factor 是 17（0~f，加结束位）</p>
<p>（2）Trie 的查找效率取决于 key 的长度，越长查找次数越多，以太坊 key 值的长度都是 40</p>
<p>（3）比起 key-value 对，trie 不会出现哈希碰撞</p>
<p>（4）Trie 生成的树和插入顺序无关</p>
<p>（5）Trie 中的更新操作具有局部性</p>
<h4 id="2、缺点"><a href="#2、缺点" class="headerlink" title="2、缺点"></a>2、缺点</h4><p>一脉单传，存储浪费空间，于是就引入了 MPT</p>
<h3 id="二、MPT"><a href="#二、MPT" class="headerlink" title="二、MPT"></a>二、MPT</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/45/2.png"
                      alt="图二"
                ></p>
<p>MPT 对树的高度进行压缩，访问内存的次数减少，提高效率。路径压缩在键值分布比较稀疏的情况下，效果比较好</p>
<p>以太坊中的地址是 160 bits，地址空间为 2^160，因此以太坊账户地址的键值分布非常稀疏。地址这么长的原因是防止哈希碰撞（不同公钥哈希后的值相同）</p>
<p>Merkle tree 比起 binary tree，把普通指针换成哈希指针；同样的，MPT 比起 PT，也是把普通指针换成哈希指针，最后计算出根哈希值</p>
<h4 id="1、根哈希值的作用"><a href="#1、根哈希值的作用" class="headerlink" title="1、根哈希值的作用"></a>1、根哈希值的作用</h4><p>（1）防止篡改</p>
<p>（2）merkle proof，证明账户余额</p>
<p>（3）和 sorted merkle tree 一样，可以证明账户是否存在</p>
<h4 id="2、Modified-MPT"><a href="#2、Modified-MPT" class="headerlink" title="2、Modified MPT"></a>2、Modified MPT</h4><p>以太坊用的是 modified MPT</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/45/3.png"
                      alt="图三"
                ></p>
<p>以太坊之所以会保留历史状态，是为了便于回滚</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/45/4.png"
                      alt="图四"
                ></p>
<h3 id="三、状态树的数据结构"><a href="#三、状态树的数据结构" class="headerlink" title="三、状态树的数据结构"></a>三、状态树的数据结构</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/45/5.png"
                      alt="图五"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/45/6.png"
                      alt="图六"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/45/7.png"
                      alt="图七"
                ></p>
<h3 id="四、状态树中的状态"><a href="#四、状态树中的状态" class="headerlink" title="四、状态树中的状态"></a>四、状态树中的状态</h3><p>状态树中保存的是 (key, value)，value（账户的状态）是通过 RLP（Recursive Length Prefix，递归长度前缀，特点是极简）序列化之后存储在账户中的</p>
<p>Protobuf（protocol buffer）是一个做数据序列化的常用库，只支持一种类型：nested array of bytes（嵌套字节数组）</p>
<p>以太坊中的所有其它类型（整数、哈希），最终都要变成嵌套字节数组，实现 RLP 比嵌套字节数组容易很多</p>
]]></content>
      <categories>
        <category>Web3 - 北大肖臻-区块链技术与应用</category>
      </categories>
      <tags>
        <tag>web3</tag>
        <tag>ETH</tag>
      </tags>
  </entry>
  <entry>
    <title>北大-区块链技术与应用17-ETH中的交易树和收据树</title>
    <url>/2025/01/16/46-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-ETH%E4%BA%A4%E6%98%93%E6%A0%91&amp;%E6%94%B6%E6%8D%AE%E6%A0%91/</url>
    <content><![CDATA[<p>以太坊中的交易树和收据树也是 MPT，其好处是支持查找操作，查找的键值是交易在发布的区块中的序号（即排第几），其顺序由发布交易的区块确定</p>
<p>交易树和收据树都是只把当前区块发布的交易组织起来，而状态树是把系统中所有账户的状态都包含进去（原因是：便于查找账户余额，尤其是很久没发生过交易的区块，更重要的是无法找到新账户）</p>
<p>上节课讲到，多个区块的状态树是共享节点的；而每个区块的交易树和收据树是独立的</p>
<p>交易树和收据树的用途是：提供 Merkle proof，交易树可以证明某个交易被打包到区块里，收据树的可以证明某个交易的执行结果</p>
<h2 id="1、Bloom-filter（布隆过滤器）"><a href="#1、Bloom-filter（布隆过滤器）" class="headerlink" title="1、Bloom filter（布隆过滤器）"></a>1、Bloom filter（布隆过滤器）</h2><p>以太坊的收据树包含一个 Bloom filter</p>
<p>Bloom filter 可以支持高效的查找某元素是否在某个大的集合。通过将大的集合中的元素做哈希，映射到一个小的数组，该数组元素初始全为0，最终如果有元素映射到该位置，则置为1</p>
<p>用 Bloom filter 检测元素是否在某个集合中，可能会出现 false positive（假阳性），即 实际不在、但是检测结果在，但<strong>检测结果在、实际一定在</strong>。且 Bloom filter 不支持删除元素</p>
<p>Bloom filter 在以太坊中的用途是支持复杂查询操作，比如：找到过去10天所有 和某个智能合约有关 &#x2F; 众筹 &#x2F; 发布新币的交易</p>
<p>每个交易执行后会形成一个收据，收据里包含一个 Bloom filter，记录该交易的类型、地址和其他信息。发布的区块在块头里也有一个总的 Bloom filter，是区块里所有交易 Bloom filter 的并集</p>
<p>轻节点只有块头信息，可以通过 Bloom filter 过滤掉很多区块，只保留符合条件的（即可能含有该交易的）区块，然后向全节点获取进一步的信息</p>
<p>以太坊的运行过程，可以看做一个 transaction-driven state machine（交易驱动的状态机），状态是所有账户的状态，交易是每次发布的区块中的交易，执行交易会驱动系统转移到下一个状态</p>
<p>比特币也可以看做一个交易驱动的状态机，其状态是 UTXO</p>
<h2 id="2、交易树、收据树、叔父数组-源码"><a href="#2、交易树、收据树、叔父数组-源码" class="headerlink" title="2、交易树、收据树、叔父数组 源码"></a>2、交易树、收据树、叔父数组 源码</h2><p>有点复杂，暂时没搞明白，详见以下课程链接（从29分开始）：</p>
<p><a class="link"   href="https://www.bilibili.com/video/BV1Vt411X7JF?spm_id_from=333.788.player.switch&vd_source=69ac93649ea21c4726fe85f272b6d968&p=17" >https://www.bilibili.com/video/BV1Vt411X7JF?spm_id_from=333.788.player.switch&amp;vd_source=69ac93649ea21c4726fe85f272b6d968&amp;p=17 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>Web3 - 北大肖臻-区块链技术与应用</category>
      </categories>
      <tags>
        <tag>web3</tag>
        <tag>ETH</tag>
      </tags>
  </entry>
  <entry>
    <title>北大-区块链技术与应用18-GHOST协议</title>
    <url>/2025/01/16/47-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-GHOST%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>以太坊出块时间的显著降低，使得更容易出现分叉（甚至多个分叉），大型矿池有优势，尤其对个体矿工不公平</p>
<p>因为当出现分叉时，所有个体矿工的算力是分散的，而矿池中的所有算力会集中在其挖出的区块，导致矿池挖出的区块更容易成为最长合法链，造成 mining centralization，这种情况也叫做 centralization bias（中心化带来的不成比例的优势）；再加上矿池会在网络的多个地方有接口，所以其发布的区块可能更早被其他节点收到</p>
<h2 id="一、叔父区块"><a href="#一、叔父区块" class="headerlink" title="一、叔父区块"></a>一、叔父区块</h2><p>GHOST 协议不是以太坊发明的，是以太坊对其做了改进。核心思想是给予孤儿区块（在以太坊中叫做 uncle block，叔父区块）一定的奖励（7&#x2F;8 的出块奖励），而打包叔父区块的区块可以获得额外的 1&#x2F;32 的出块奖励（一个区块最多包含 2 个叔父区块）</p>
<p>以太坊一开始的出块奖励是 5个以太币，后来改为 3个以太币，现在变为 2个以太币（和挖矿难度相关）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/47/1.png"
                      alt="图一"
                ></p>
<p>GHOST 的这种设计有利于鼓励系统中出现分叉后及时进行合并（解决系统中的临时性分叉）</p>
<p>但是可能存在矿池恶意竞争，故意不包含叔父区块</p>
<h2 id="二、Uncle-reward（叔父区块的奖励）"><a href="#二、Uncle-reward（叔父区块的奖励）" class="headerlink" title="二、Uncle reward（叔父区块的奖励）"></a>二、Uncle reward（叔父区块的奖励）</h2><p>最长合法链上的后续区块，仍然能包含前面区块未打包的叔父区块，但是叔父区块距离越远，奖励越小（7&#x2F;8, 6&#x2F;8, 5&#x2F;8, 4&#x2F;8, 3&#x2F;8, 2&#x2F;8），最长不能超过六代</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/47/2.png"
                      alt="图二"
                ></p>
<p>叔父区块的定义：必须和当前区块在七代以内有共同的祖先（at most seven generations）</p>
<p>设计七代以内辈分的原因是：如果不限制备份，全节点需要维护的状态就太多了；七代以内辈分 uncle reward 逐级递减的原因是：有利于鼓励出现分叉后尽早进行合并</p>
<p>在比特币和以太坊中，把 block reward 叫做 static reward（静态奖励）</p>
<p>在比特币中，tx fee 叫做 dynamic reward（动态奖励）；而在以太坊中，在执行区块中包含的智能合约时，可以得到 gas fee（汽油费），叔父区块是得不到汽油费的</p>
<p>比特币被比喻为数字黄金，是用来储值的；以太币被比喻为石油，是用来消耗的（不太恰当，因为以太币本身不会消失）</p>
<p>打包叔父区块时不应该执行叔父区块中的交易，因为叔父区块中可能存在有冲突的交易（执行完父区块的交易，再执行叔父区块的交易就会非法）；而是会通过 block header 检查叔父区块是不是一个合法发布的区块（是否符合挖矿难度要求）</p>
<p>叔父区块后面的节点不能给予奖励，否则分叉攻击就变得太简单了：如果成功，可以回滚交易；不成功，也可以合并获得 uncle reward</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/47/3.png"
                      alt="图三"
                ></p>
]]></content>
      <categories>
        <category>Web3 - 北大肖臻-区块链技术与应用</category>
      </categories>
      <tags>
        <tag>web3</tag>
        <tag>ETH</tag>
      </tags>
  </entry>
  <entry>
    <title>北大-区块链技术与应用19-ETH挖矿算法</title>
    <url>/2025/01/18/48-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-ETH%E6%8C%96%E7%9F%BF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>Block chain is secured by mining（挖矿保障了区块链的安全性），比特币的挖矿算法是一个天然的 bug bounty（悬赏找bug），如果能找到漏洞或挖矿的捷径（shortcut）就能获取很大的利益</p>
<p>很多人认为，挖矿设备的专业化 和比特币的去中心化理念是相违背的（one cpu, one vote），普通人能够参与挖矿有利于分散算力，预防 51% attack。所以后续的加密货币设计 mining puzzle 的一个理念是 ASIC resistance</p>
<p>设计 ASIC resistance 的 mining puzzle 的常用做法是：增加 puzzle 对内存访问的需求，即 memory hard mining puzzle，因为 ASIC 芯片计算能力强，但是在内存访问的性能上没有很大的优势</p>
<h2 id="一、LiteCoin-Scrypt"><a href="#一、LiteCoin-Scrypt" class="headerlink" title="一、LiteCoin &amp; Scrypt"></a>一、LiteCoin &amp; Scrypt</h2><p>一个早期的例子是 LiteCoin（莱特币），曾经是市值仅次于比特币的加密货币，其 mining puzzle 基于 scrypt</p>
<p>Scrypt 是一个对内存要求很高的哈希函数，设计思想是：开设一个很大的数组，按照顺序填充一些伪随机数；具体过程是：按照一个 seed 的值，运算出一个数填在第一个位置，后面每个位置都是前一个位置取哈希得到的；其特点是里面的取值是有前后依赖关系的；求解 puzzle 时，按照伪随机的顺序从数组中读取一些数（通过对当前数运算得到下一个读取顺序，模拟随机）；好处是：如果数组开得足够大，对于矿工来说就是 memory hard 的，有的矿工可能保存一部分内存区域的内容，比如只保留奇数位置的数，需要读取到偶数再算，这也叫做 time-memory trade off（时间换空间）</p>
<p>其坏处是：对于轻节点验证来说也是 memory hard，不符合 difficult to solve, but easy to verify。所以其实际使用过程中，数组只有 128k，不足以对 ASIC 芯片造成遏制，但该理念对其冷启动有很大帮助（需要冷启动是因为，参与挖矿的人太少很容易遭受恶意攻击），所以莱特币现在仍然是主流货币</p>
<p>莱特币的出块时间是两分半，速度是比特币的四倍，其他部分和比特币基本相同</p>
<h2 id="二、以太坊-memory-hard"><a href="#二、以太坊-memory-hard" class="headerlink" title="二、以太坊 memory hard"></a>二、以太坊 memory hard</h2><p>以太坊的挖矿算法叫做 ethash，矿工挖矿需要 1G 的内存，和莱特币的 128k 比，大了 8000 多倍，光是 cashe 就大了 100 多倍；更别说现在内存要求还在增长</p>
<p>以太坊使用一大一小两个数据集：16M 的 cache 和 1G 的dataset，轻节点只要保存 cache，矿工才需要保存 1G 的大数据集</p>
<h3 id="1、具体算法"><a href="#1、具体算法" class="headerlink" title="1、具体算法"></a>1、具体算法</h3><p>算法太复杂了，没完全搞明白，具体算法的伪代码可参考课程视频（28分）：</p>
<p><a class="link"   href="https://www.bilibili.com/video/BV1Vt411X7JF?spm_id_from=333.788.player.switch&vd_source=69ac93649ea21c4726fe85f272b6d968&p=19" >https://www.bilibili.com/video/BV1Vt411X7JF?spm_id_from=333.788.player.switch&amp;vd_source=69ac93649ea21c4726fe85f272b6d968&amp;p=19 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>cache 的生成方式和 scrypt 类似，但是不同于莱特币从数组中按照伪随机的顺序读取并进行运算，以太坊是需要先生成一个更大的数组（dataset 要大得多），而且 cache 和 dataset 是定期增长的，因为计算机的内存容量也在增长</p>
<p>dataset 中的每个元素都是从 cache 中按照伪随机的顺序读取一些元素（和莱特币类似），一共读 256 次，用这 256 个数算出一个数，作为 dataset 的第一个元素，后续元素也一样</p>
<p>求解 puzzle 时只使用 dataset 中的数，按照伪随机的顺序，从大数据集中读取 128 个数：一开始根据区块的块头、包括其中的 nonce 值，算出一个初始的哈希，然后根据该哈希映射到这个大数据集中的某个位置，将其中的数读取出来（同时将其相邻的元素读取出来），然后进行一些运算算出下一个位置，总共进行 64 次循环，共读取 128 个数。最后算出一个哈希值，和挖矿难度的目标域值比较，看是否符合要求，如果不符合，更换 nonce 之后再重新计算</p>
<h3 id="2、矿工保存-dataset-的原因"><a href="#2、矿工保存-dataset-的原因" class="headerlink" title="2、矿工保存 dataset 的原因"></a>2、矿工保存 dataset 的原因</h3><p>由于矿工需要验证非常多的 nonce，如果每次都从 16M 的 cache 中重新生成，挖矿的效率就太低了，并且其中有大量的重复计算（因为随机选取的 dataset 的元素中有很多是重复的，可能是之前尝试别的 nonce 时用过的）。所以矿工采取空间换时间的策略，保存整个 dataset</p>
<h3 id="3、轻节点只保存-cache-的原因"><a href="#3、轻节点只保存-cache-的原因" class="headerlink" title="3、轻节点只保存 cache 的原因"></a>3、轻节点只保存 cache 的原因</h3><p>轻节点由于只验证一个 nonce，验证时直接生成要用到的 dataset 中的元素即可</p>
<p>和比特币相比，以太坊中验证一个 nonce 的计算量要大很多，但也在可接受范围内</p>
<p>目前以太坊挖矿还是以 GPU 为主，所以起到了 ASIC resistance</p>
<h2 id="三、以太坊-POS"><a href="#三、以太坊-POS" class="headerlink" title="三、以太坊 POS"></a>三、以太坊 POS</h2><p>以太坊没有出现 ASIC 矿机的另一个原因是，以太坊2.0（或以太坊合并）已经于 2022年 从 POW 转向 POS（Power of Stake，权益证明），即按照所占的权益进行投票从而形成共识，而不是挖矿，类似于股份制公司按照股份多少来投票</p>
<p>这对于 ASIC 厂商是很大的威胁，因为其研发周期很长（1年都算快的），并且研发成本也很高，如果后续不挖矿了，那么所有投入都白费了</p>
<h2 id="四、预挖矿"><a href="#四、预挖矿" class="headerlink" title="四、预挖矿"></a>四、预挖矿</h2><p>以太坊采用了 pre-mining（预挖矿），在当初发行货币的时候，预留一部分货币给以太坊的开发者，类似创业公司留一部分股票给创始人和早期员工；而比特币没有采用 pre-mining 的模式，都是挖矿挖出来的</p>
<p>Pre-sale（预售） 就是把 pre-mining 中预留的币，通过出售的方法来换取一些资产，用于加密货币的开发工作</p>
<p>但有一些人认为，让通用计算设备参与挖矿反而是不安全的，用 ASIC 芯片挖矿才是最安全的，因为购买矿机需要大量的资金，并且只能用于一种加密货币，成本较高</p>
]]></content>
      <categories>
        <category>Web3 - 北大肖臻-区块链技术与应用</category>
      </categories>
      <tags>
        <tag>web3</tag>
        <tag>ETH</tag>
      </tags>
  </entry>
  <entry>
    <title>北大-区块链技术与应用18-ETH挖矿难度调整</title>
    <url>/2025/01/18/49-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-ETH%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6%E8%B0%83%E6%95%B4/</url>
    <content><![CDATA[<p>比特币是每隔 2016 个区块会调整挖矿难度，目标是维持出块时间在十分钟左右；以太坊是每个区块都可以修改挖矿难度</p>
<h2 id="一、难度调整公式"><a href="#一、难度调整公式" class="headerlink" title="一、难度调整公式"></a>一、难度调整公式</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/49/1.png"
                      alt="图一"
                ></p>
<p>基础部分的作用是维持出块时间在 15秒 左右</p>
<p>ε 是难度炸弹，为了以太坊从 POW 逐步过渡到 POS</p>
<h3 id="1、基础部分"><a href="#1、基础部分" class="headerlink" title="1、基础部分"></a>1、基础部分</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/49/2.png"
                      alt="图二"
                ></p>
<p>x 是难度调整的力度，为父区块的难度除以 2048，再向下取整</p>
<p>一次性下调难度最多是父区块难度的 99&#x2F;2048</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/49/3.png"
                      alt="图三"
                ></p>
<h3 id="2、难度炸弹"><a href="#2、难度炸弹" class="headerlink" title="2、难度炸弹"></a>2、难度炸弹</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/49/4.png"
                      alt="图四"
                ></p>
<h2 id="二、以太坊发展的四个阶段"><a href="#二、以太坊发展的四个阶段" class="headerlink" title="二、以太坊发展的四个阶段"></a>二、以太坊发展的四个阶段</h2><p>Frontier（前沿）、Homestead（家园）、Metropolis（大都会）和 Serenity（宁静）</p>
<p>其中 Metropolis 分为 两个子阶段：Byzantium（拜占庭） 和 Constantinople（君士坦丁堡），难度炸弹的回调发生在 Byzantium 阶段</p>
<p>Serenity（宁静）即以太坊2.0，从 POW 转向 POS</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/49/5.png"
                      alt="图五"
                ></p>
<p>EIP（Ethereum Improvement Proposal）：以太坊改进提案</p>
<p>BitCoin Improvement Proposal）：比特币改进提案</p>
<h2 id="三、具体代码实现"><a href="#三、具体代码实现" class="headerlink" title="三、具体代码实现"></a>三、具体代码实现</h2><p>略，没特别明白，可以参考课程视频（20分）：</p>
<p><a class="link"   href="https://www.bilibili.com/video/BV1Vt411X7JF?spm_id_from=333.788.player.switch&vd_source=69ac93649ea21c4726fe85f272b6d968&p=20" >https://www.bilibili.com/video/BV1Vt411X7JF?spm_id_from=333.788.player.switch&amp;vd_source=69ac93649ea21c4726fe85f272b6d968&amp;p=20 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>比特币中讲过最长合法链，而对于以太坊来说是最难合法链</p>
]]></content>
      <categories>
        <category>Web3 - 北大肖臻-区块链技术与应用</category>
      </categories>
      <tags>
        <tag>web3</tag>
        <tag>ETH</tag>
      </tags>
  </entry>
  <entry>
    <title>北大-区块链技术与应用19-权益证明</title>
    <url>/2025/01/19/50-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-POS/</url>
    <content><![CDATA[<p>POW（Proof of work，工作量证明）受到的普遍批评是浪费电</p>
<p>以太坊交易的能耗比比特币低，是因为出块时间更短</p>
<h2 id="一、POS-基本思想"><a href="#一、POS-基本思想" class="headerlink" title="一、POS 基本思想"></a>一、POS 基本思想</h2><p>POS（Proof of Stake，权益证明）的基本思想是：按照每个人投入资金的多少来决定收益的分配，这也叫做 virtual mining（虚拟挖矿）</p>
<p>采用权益证明的货币，在发行前一般会预留一部分货币给开发者，也会出售一部分货币来换取开发所需的资金。将来按照的权益证明的共识机制，按照每个人持有货币的数量进行投票</p>
<h2 id="二、POS-的好处"><a href="#二、POS-的好处" class="headerlink" title="二、POS 的好处"></a>二、POS 的好处</h2><p>（1）省去了挖矿的过程，也避免了由此带来的能耗和对环境的影响</p>
<p>（2）如果有人想发动恶意攻击，需要设法获得该币种一半以上的份额，即发动攻击的资源只能从加密系统内部获得，形成一个闭环。如果有人在初期大量买入，币价大涨，早期投资者可能会跑卖出路（类似于股份制公司遭受恶意收购）</p>
<p>基于 POW 的共识系统，从某种意义上来说，维护区块链安全的资源不是一个闭环，因为 Block chain is secured by mining. 而 mining 所需的 equipment 是由法币买来的（即加密货币的生态系统之外得到的），这就带来一个问题：虽然加密货币的总市值有了很大的增长，但是和世界经济总量相比仍然是微乎其微的，也就是说发动 51% attack 攻击的资源可以从外界得到、并且是有可能达到的，尤其对于刚发行的小的币种 AltCoin（Alternative coin），这叫做 AltCoin Infanticide（杀婴）</p>
<p>有些加密货币采用的是一种混合模型，即仍然需要挖矿，但是挖矿难度和占有权益（持有币的数量）相关。这样会导致，系统中持有币数量最多的人，每次挖矿都最容易，所以有些加密货币要求，投入的币会被锁定一段时间，不能重复使用（比如：挖矿时投入一些币降低挖矿难度，等区块发布出来后，投入的币就会被锁定一段时间，下次再挖就不能用了，过一定区块才能继续用），这叫做 Proof of Deposit（存款证明）</p>
<h2 id="三、早期-POS-遭遇的问题"><a href="#三、早期-POS-遭遇的问题" class="headerlink" title="三、早期 POS 遭遇的问题"></a>三、早期 POS 遭遇的问题</h2><p>Nothing at stake（两边下注）：参与者通过持有并锁定一定数量的加密货币、而不需要消耗资源（如算力）来生成区块，因此可以同时支持多个分叉上的区块而没有损失</p>
<h2 id="四、Casper-协议"><a href="#四、Casper-协议" class="headerlink" title="四、Casper 协议"></a>四、Casper 协议</h2><p>Casper 是以太坊采用的 POS 协议</p>
<p>Casper the Friendly Finality Gadget（CFG，Casper 友好的最终性工具）：在过渡阶段，需要和工作量证明混合使用，为工作量证明提供 finality，它是一种最终的状态，包含在其中的交易不会被取消</p>
<p>单纯基于挖矿的交易时可能被回滚的，比如某个交易被写入区块链里，但是有人从前面的区块开始分叉，挖出一条更长的分叉链</p>
<p>Casper 引入了 validator（验证者）的概念，validator 必须投入一定数量的以太币作为保证金，保证金会被锁定。Validator 的作用是推动系统达成共识，投票决定哪条链是最长合法链，投票权重取决于保证金的数目大小</p>
<p>具体做法类似于数据库中的 two-phase commit（两阶段提交），第一阶段是 prepare message，第二阶段是 commit message</p>
<p>每挖出 100个 区块，就作为一个 epoch（纪元），要决定其能否成为 finality 需要进行投票，Casper 规定每一轮投票都要得到 2&#x2F;3 以上验证者（按照保证金金额大小）同意才能通过</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/50/1.png"
                      alt="图一"
                ></p>
<p>实际系统中不区分 prepare message 和 commit message，而且把 epoch 从原来的 100个 区块，减少到了 50个 区块就作为一个 epoch，每个 epoch 只需要一轮投票，投票结果对于上一个区块是 commit message，对于下一个区块是 prepare message，需要连续两轮投票（2个 epoch）都得到 2&#x2F;3 以上的通过，才算有效</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/50/2.png"
                      alt="图二"
                ></p>
<p>验证者参与该过程的好处是，如果其履行职责，可以得到相应的奖励；相反，如果验证者有不良行为被发现，会受到相应的处罚，比如：该投票时不投票，导致系统迟迟无法达成共识，这种情况会扣除其一部分保证金；比如乱投票，给两个有冲突的分叉都投票（两边下注），这种情况会没收其所有保证金（所有扣除或没收都是销毁的模式）</p>
<p>每个验证者有一定的任期，任期满后会有一个等待期，该等待期是为了让其他节点检举或揭发其是否有不良行为。如果等待期过了，验证者就可以取回当初的保证金和应得的奖励</p>
<h2 id="五、关于-Casper-的思考"><a href="#五、关于-Casper-的思考" class="headerlink" title="五、关于 Casper 的思考"></a>五、关于 Casper 的思考</h2><p>Casper 在挖矿的过程中，对其状态做一个 check point（检查点），这是否安全；或者说通过验证者投票达成的 finality 是否可能被推翻？</p>
<p>假设某个有恶意的组织想发动攻击，如果组织仅仅是矿工，那么就无法推翻已经达成的 finality，因为它是验证者投票的结果；如果组织是验证者，由于需要连续两轮投票都得到 2&#x2F;3 以上的通过才算有效，那么至少有 1&#x2F;3 的验证者两边下注了：正常链得到至少 2&#x2F;3 的票数，非法链也得到至少 2&#x2F;3 的票数，那么至少一共是 2&#x2F;3+2&#x2F;3&#x3D;4&#x2F;3 的票数，即至少 4&#x2F;3-1&#x3D;1&#x2F;3 的验证者都参与了两条链的投票。这 1&#x2F;3 的验证者被发现后，会被没收所有的保证金</p>
<p>EOS 加密货币（俗称柚子），采用的是 DPOS（Delegated Proof of Stake）协议，先用投票的方式选出 21个 超级节点，再由这些超级节点产生区块，现在已经凉了</p>
<h2 id="六、POW-的争论"><a href="#六、POW-的争论" class="headerlink" title="六、POW 的争论"></a>六、POW 的争论</h2><p>很多人认为 POW 挖矿的好处是，提供了把多余电能转化为钱的一种手段，可以有效地化解过剩产能，带动当地经济的发展。因为电能是很难存储、很难传输的，很多大型数据中心要建在电比较便宜的地方，就是因为传输数据比传输电容易，很多比特币的矿场都是建在电力资源丰富的地方</p>
]]></content>
      <categories>
        <category>Web3 - 北大肖臻-区块链技术与应用</category>
      </categories>
      <tags>
        <tag>web3</tag>
        <tag>ETH</tag>
        <tag>POS</tag>
      </tags>
  </entry>
  <entry>
    <title>北大-区块链技术与应用20-智能合约</title>
    <url>/2025/01/19/51-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/</url>
    <content><![CDATA[<h2 id="一、智能合约概念"><a href="#一、智能合约概念" class="headerlink" title="一、智能合约概念"></a>一、智能合约概念</h2><p>Smart contract（智能合约）是运行在区块链上的一段代码，代码的逻辑定义了合约的内容</p>
<p>智能合约的账户保存了合约当前的运行状态</p>
<ul>
<li>balance 当前余额</li>
<li>nonce 交易次数</li>
<li>code 合约代码</li>
<li>storage 存储，数据结构是一颗 MPT</li>
</ul>
<p>Sodility 是智能合约最常用的语言，语法上与 JavaScript 很接近</p>
<h2 id="二、Sodility-数据结构"><a href="#二、Sodility-数据结构" class="headerlink" title="二、Sodility 数据结构"></a>二、Sodility 数据结构</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/51/1.png"
                      alt="图一"
                ></p>
<p>其中，bid() 后面的 payable 说明该合约账户能接受外部转账。该函数是用来进行竞拍出价的，在出价时需要把以太币发送并存储到合约里，锁定到拍卖结束，因此该函数需要有能接受外部转账的能力</p>
<p>withdraw() 函数是在拍卖结束后，未中标的账户可调用该函数，把出价时锁定在智能合约中的以太币取回来</p>
<h2 id="三、智能合约调用"><a href="#三、智能合约调用" class="headerlink" title="三、智能合约调用"></a>三、智能合约调用</h2><h3 id="1、一个账户调用一个智能合约"><a href="#1、一个账户调用一个智能合约" class="headerlink" title="1、一个账户调用一个智能合约"></a>1、一个账户调用一个智能合约</h3><p>外部账户调用智能合约，和转账类似：假设 A 发起一个交易转账给 B，如果 B 是普通用户，则为普通交易；如果 B 是合约账户，那么该调用实际是对 B 合约的调用，具体调用函数是在 data 域中进行说明</p>
<h3 id="2、一个合约调用另一个合约"><a href="#2、一个合约调用另一个合约" class="headerlink" title="2、一个合约调用另一个合约"></a>2、一个合约调用另一个合约</h3><p>以太坊中规定，一个交易只有外部账户才能发起，一个合约账户不能主动发起交易。所以在实际中，有两种调用方式</p>
<h4 id="（1）直接调用"><a href="#（1）直接调用" class="headerlink" title="（1）直接调用"></a>（1）直接调用</h4><p>通过一个普通账户调用合约 B 中的函数，然后这个函数再调用合约 A 中的函数</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/51/2.png"
                      alt="图二"
                ></p>
<h4 id="（2）使用-address-类型的-call-函数"><a href="#（2）使用-address-类型的-call-函数" class="headerlink" title="（2）使用 address 类型的 call() 函数"></a>（2）使用 address 类型的 call() 函数</h4><p>这种调用和上述不同的是：对于错误处理的不同。在直接调用中，如果被调用的合约执行发生错误，会导致发起调用的合约也跟着一起回滚；而 addr.call() 的方法，如果被调用的合约发生异常，addr.call() 会返回 flase，但发起调用的合约不会抛出异常，而是会继续执行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/51/3.png"
                      alt="图三"
                ></p>
<h4 id="（3）代理使用-delegatecall"><a href="#（3）代理使用-delegatecall" class="headerlink" title="（3）代理使用 delegatecall()"></a>（3）代理使用 delegatecall()</h4><p>和 call() 很像，区别是 delegatecall() 不需要切换到被调用的合约的环境中去执行，而是在当前合约的环境中执行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/51/4.png"
                      alt="图四"
                ></p>
<h3 id="3、fallback-函数"><a href="#3、fallback-函数" class="headerlink" title="3、fallback() 函数"></a>3、fallback() 函数</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/51/5.png"
                      alt="图五"
                ></p>
<p>A 调用 B 的合约，要在转账交易里的 data 域说明调用的是 B 中的哪个函数。如果 A 给合约 B 转了一笔钱，没有说明掉的是哪个函数（或者调的函数在 data 域中不存在），此时缺省就调用 fallback() 函数</p>
<p>在交易中，转账金额可以为 0，但是汽油费不能为 0，因为没有汽油费，发布该区块的矿工就不会将该笔交易打包进去</p>
<h2 id="四、智能合约的创建和运行"><a href="#四、智能合约的创建和运行" class="headerlink" title="四、智能合约的创建和运行"></a>四、智能合约的创建和运行</h2><p>智能合约是由某个外部账户发起一个转账交易，转给 0X0 地址，转账金额为 0，然后把要发布的合约的代码放到 data 域里</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/51/6.png"
                      alt="图六"
                ></p>
<p>JVM 的目的是增强可移植性，EVM 也是类似的思想，通过加一层虚拟机，对智能合约的运行提供一个一致性的平台，所以 EVM 有时叫做 world wide computer，EVM 的寻址空间非常大，为 256 位</p>
<h2 id="五、汽油费"><a href="#五、汽油费" class="headerlink" title="五、汽油费"></a>五、汽油费</h2><p>比特币的设计理念很简单，功能有限（比如不支持循环）；而以太坊需要提供一个 Turing-complete Programming Model（图灵完备的编程模型），包含条件控制、循环和递归、数据存储、基本的算术运算功能，但也可能带来问题，比如出现死循环</p>
<p>一个全节点收到一个对智能合约的调用，不知道该调用执行起来是否会导致死循环，这叫做 Halting Problem（停机问题），这个问题是不可解的，不是 NPC 问题（Non-deterministic Polynomial 的问题，即多项式复杂程度的非确定性问题，NPC 是可解的，只是没有多项式时间的解法）</p>
<p>以太坊引入了汽油费机制，发起一个对智能合约的调用，就要支付相应的汽油费</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/51/7.png"
                      alt="图七"
                ></p>
<p>当一个全节点收到一个对智能合约的调用时，先按照调用中给出的 gasLimit，算出可能花掉的最大汽油费，然后一次性把汽油费从发起调用的账户上扣除，然后再根据实际执行的情况，算出实际花了多少汽油费（多退）</p>
<p>不同的指令消耗的汽油费不同，简单的指令（比如加减法），消耗的汽油费是很少的，复杂的指令消耗的汽油费就比较多（比如取哈希）；除了计算量，需要存储状态的指令消耗的汽油费也比较大；只需读取公共指令的命令是免费的</p>
<h2 id="六、错误处理"><a href="#六、错误处理" class="headerlink" title="六、错误处理"></a>六、错误处理</h2><p>以太坊中的交易执行起来具有原子性，一个交易要么全部执行、要么完全不执行，不会只执行一部分，既包含普通的转账交易，也包含对智能合约的调用。所以如果在执行智能合约的过程中，出现任何错误，会导致整个交易的执行回滚，退回到开始执行前的状态</p>
<h3 id="1、出现错误的情况"><a href="#1、出现错误的情况" class="headerlink" title="1、出现错误的情况"></a>1、出现错误的情况</h3><p>（1）交易执行结束后，没有达到当初的 gas limit，多余的汽油费会被退回到这个账户里；相反的，如果执行一半，gas limit 已经都用完了，这时合约的执行会退回到开始执行之前的状态，且已经消耗掉的汽油费是不退的</p>
<p>（2）抛出错误的语句 assert（通常判断内部条件），require（通常判断外部条件，比如函数输入是否符合要求），revert（无条件抛出异常，原来是 throw）。sodility 当中没有 try catch 这种结构</p>
<h3 id="2、嵌套调用"><a href="#2、嵌套调用" class="headerlink" title="2、嵌套调用"></a>2、嵌套调用</h3><p>如果嵌套调用，一个智能合约调用另外一个智能合约，被调用的智能合约出现错误，不一定会导致发起调用的智能合约也跟着一起回滚，即连锁式回滚</p>
<p>这取决于调用智能合约的方式，如果这个智能合约是直接调用，就会触发连锁式回滚；如果用 call() 的方式，就不会连锁回滚，而是返回一个 false</p>
<p>如果只是向一个账户里转账，但该账户为合约账户，该操作就有可能触发对函数的调用，因为如果没有指明哪个函数，仍会调用 fallback() 函数</p>
<h2 id="七、Block-header"><a href="#七、Block-header" class="headerlink" title="七、Block header"></a>七、Block header</h2><p>gasUsed 是该区块里所有交易所消耗的汽油费的总和</p>
<p>发布区块需要消耗一定的资源，需要对消耗的资源有一个限制（类似比特币区块大小不能超过一兆），gasLimit 是该区块里所有交易实际能够消耗汽油的上限</p>
<p>比特币区块一兆大小的限制是固定的，但是以太坊的 gasLimit 也有一个上限，但是每个矿工发布区块时，可以对 gasLimit 进行微调，即在上一个区块 gasLimit 的基础上 上调或下调 1&#x2F;1024</p>
<h2 id="八、思考"><a href="#八、思考" class="headerlink" title="八、思考"></a>八、思考</h2><h3 id="1、先挖矿还是先执行"><a href="#1、先挖矿还是先执行" class="headerlink" title="1、先挖矿还是先执行"></a>1、先挖矿还是先执行</h3><p>前置知识：任何对状态的修改，都是在改本地的数据结构，只有当合约执行完了，发布到区块链之后，这些本地的修改才会变成外部可见的、变成区块链上的共识</p>
<p>假设某个全节点要打包一些交易到一个区块里，这些交易里有一些是对智能合约的调用，那么全节点是先把这些智能合约都执行完再去挖矿，还是应该先挖矿、获得记账权之后，再执行合约？</p>
<p>答案是先执行智能合约，因为不先执行，更新三颗树（状态、交易、收据），就无法得到三颗树的根哈希，也就无法通过 block header 去挖矿</p>
<h3 id="2、是否会存在故意不验证的全节点"><a href="#2、是否会存在故意不验证的全节点" class="headerlink" title="2、是否会存在故意不验证的全节点"></a>2、是否会存在故意不验证的全节点</h3><p>汽油费的设置是对于矿工执行智能合约所消耗资源的一种补偿，但是这种补偿只有最终挖到矿的矿工才能得到</p>
<p>如果某个区块不验证新发布的交易，不去执行新发布的区块，也就没办法更新本地的三棵树，以后就没办法再发布区块</p>
<h3 id="3、合约执行错误能否上链"><a href="#3、合约执行错误能否上链" class="headerlink" title="3、合约执行错误能否上链"></a>3、合约执行错误能否上链</h3><p>如果智能合约执行的过程中出现了错误，也要发布到区块链上，否则汽油费扣不掉。也就是说发布到区块链上的交易不一定都是成功执行的</p>
<h3 id="4、智能合约是否支持多线程"><a href="#4、智能合约是否支持多线程" class="headerlink" title="4、智能合约是否支持多线程"></a>4、智能合约是否支持多线程</h3><p>多核处理器很普遍，但是智能合约不支持多核并行处理，sodility 没有支持多线程的语句，原因是：以太坊是一个交易驱动的状态机，状态机必须是完全确认性的，给定同一组输入，产生的输出&#x2F;转移到的下一个状态必须是完全确定的。因为所有的全节点都得执行同一组操作，达到同一个状态，如果不确定的话，三个树的根哈希值根本对不上。多线程的问题是多个核对内存访问顺序不同的话，执行结果有可能不确定</p>
<p>除了多线程之外，其他可能造成执行结果不确定的操作也都不支持，比如：产生随机数，所以以太坊中的智能合约没办法产生真正意义下的随机数，只能用伪随机数</p>
<h2 id="九、收据树"><a href="#九、收据树" class="headerlink" title="九、收据树"></a>九、收据树</h2><p>下面是 Receipt 的数据结构：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/51/8.png"
                      alt="图八"
                ></p>
<p>每个交易执行完之后会形成一个收据，status 表示交易的执行情况</p>
<h2 id="十、智能合约可以获得的信息"><a href="#十、智能合约可以获得的信息" class="headerlink" title="十、智能合约可以获得的信息"></a>十、智能合约可以获得的信息</h2><h3 id="1、智能合约可以获得的区块信息"><a href="#1、智能合约可以获得的区块信息" class="headerlink" title="1、智能合约可以获得的区块信息"></a>1、智能合约可以获得的区块信息</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/51/9.png"
                      alt="图九"
                ></p>
<h3 id="2、智能合约可以获得的调用信息"><a href="#2、智能合约可以获得的调用信息" class="headerlink" title="2、智能合约可以获得的调用信息"></a>2、智能合约可以获得的调用信息</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/51/10.png"
                      alt="图十"
                ></p>
<p>msg.data 说明了调用哪个函数，和该函数的参数取值</p>
<p>msg.gas 是剩余的汽油费，决定了还能做那些操作，想要再调用其他合约，前提是有足够的汽油费剩余</p>
<p>msg.sig 是 msg.data 的前四个字节，即函数标识符，表示调用的是哪个函数</p>
<p>now 是当前区块的时间戳，等同于图区块信息中的 block.timestamp</p>
<p>消息发送者 msg.sender 和 交易发起者 tx.origin 是不一样的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/51/11.png"
                      alt="图十一"
                ></p>
<p>比如上述交易，对于 f2，msg.sender 是 C1，但是 tx.origin 是 A</p>
<h3 id="3、地址类型"><a href="#3、地址类型" class="headerlink" title="3、地址类型"></a>3、地址类型</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/51/12.png"
                      alt="图十二"
                ></p>
<p>addr.balance 是成员变量，剩余的都是成员函数</p>
<p>addr.transfer(amount) 是当前合约往地址 addr 转入 amount 以太币，转入的地址是 addr，转出的地址是该合约地址</p>
<p>addr.call() 合约账户发起对 addr 这个合约的调用</p>
<h3 id="4、三种发送-ETH-的方式"><a href="#4、三种发送-ETH-的方式" class="headerlink" title="4、三种发送 ETH 的方式"></a>4、三种发送 ETH 的方式</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">addr.transfer(amount)</span><br><span class="line">addr.send(amount) return (bool)</span><br><span class="line">addr.call.value(amount)()</span><br></pre></td></tr></table></figure></div>

<p>（1）transfer 会导致连锁性的回滚；失败时抛出异常；为要调用的合约提供 2300 汽油费（少量）</p>
<p>（2）send 在失败时会返回一个 false；不会导致连锁式回滚；为要调用的合约提供 2300 汽油费（少量）</p>
<p>（3）call 在失败时会返回一个 false；不会导致连锁式回滚；会将当前调用剩下的所有汽油都发送给要调用的合约，合约后续会执行什么操作当前账户无法控制</p>
<h2 id="十一、智能合约拍卖实例"><a href="#十一、智能合约拍卖实例" class="headerlink" title="十一、智能合约拍卖实例"></a>十一、智能合约拍卖实例</h2><p>这部分结合智能合约拍卖实例，讲述可能存在的安全漏洞，代码截图较多，视频链接如下（1小时31分25秒）：</p>
<p><a class="link"   href="https://www.bilibili.com/video/BV1Vt411X7JF/?spm_id_from=333.788.player.switch&vd_source=69ac93649ea21c4726fe85f272b6d968&p=22" >https://www.bilibili.com/video/BV1Vt411X7JF/?spm_id_from=333.788.player.switch&amp;vd_source=69ac93649ea21c4726fe85f272b6d968&amp;p=22 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>Web3 - 北大肖臻-区块链技术与应用</category>
      </categories>
      <tags>
        <tag>web3</tag>
        <tag>ETH</tag>
        <tag>智能合约</tag>
      </tags>
  </entry>
</search>
