[{"title":"vue3 应用的创建&使用","url":"/2023/11/06/1-vue3%E5%BA%94%E7%94%A8%E7%9A%84%E5%88%9B%E5%BB%BA&%E4%BD%BF%E7%94%A8/","content":"创建应用npm create vue@latest\n\n通过CDN使用vue这里使用了提供 npm 包服务的 CDN —— unpkg\n&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;\n\nDOM 中的根组件模板当根组件没有设置 template 选项时，Vue 将自动使用容器的 innerHTML 作为模板\n这种方式通常用于此种“无构建步骤”（通过 CDN 使用 vue）的应用程序\n&lt;div id=&quot;app&quot;&gt;  &lt;button @click=&quot;count++&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/div&gt;\n\nimport &#123; createApp &#125; from &#x27;vue&#x27;;const app = createApp(&#123;  data() &#123;    return &#123;      count: 0    &#125;  &#125;&#125;).mount(&#x27;#app&#x27;);\n\n全局构建上述链接使用 全局构建 版本的 Vue，所有顶层 API 都暴露为全局 Vue 对象的属性\n&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;script&gt;  const &#123; createApp, ref &#125; = Vue;/**  1. 创建应用并挂载 */  createApp(&#123;    setup() &#123;      const message = ref(&#x27;Hello world!&#x27;);      return &#123;        message      &#125;;    &#125;  &#125;).mount(&#x27;#app&#x27;);    /**  2. 分步骤 */  // // a. 创建应用  // const app = createApp(&#123;  //   setup() &#123;  //     const message = ref(&#x27;Hello world!&#x27;);  //     return &#123;  //       message  //     &#125;  //   &#125;;  // &#125;);  // // b. 挂载  // app.mount(&#x27;#app&#x27;);&lt;/script&gt;\n\n导入映射表（Import maps）不使用完整的 CDN URL 引入，而使用 es6 的导入映射表（import maps）\n&lt;script type=&quot;importmap&quot;&gt;  &#123;    &quot;imports&quot;: &#123;      &quot;vue&quot;: &quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;    &#125;  &#125;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;script type=&quot;module&quot;&gt;  import &#123; createApp, ref &#125; from &quot;vue&quot;;  createApp(&#123;    setup() &#123;      const message = ref(&quot;Hello world!&quot;);      return &#123;        message      &#125;;    &#125;  &#125;).mount(&#x27;#app&#x27;);&lt;/script&gt;\n\n拆分模块将代码拆分为单独的 js 文件以便管理\n出于安全原因，es 模块只能通过 http 协议工作，所以需要使用本地的 http 服务器，通过 http 协议提供 index.html。比如：安装 Node.js，在 html 文件所在的文件夹运行 npx serve\n&lt;!-- index.html --&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;script type=&quot;module&quot;&gt;  import &#123; createApp &#125; from &#x27;vue&#x27;;  import MyComponent from &#x27;./my-component.js&#x27;;  createApp(MyComponent).mount(&#x27;#app&#x27;);&lt;/script&gt;\n\n// my-component.jsimport &#123; ref &#125; from &#x27;vue&#x27;;export default &#123;  setup() &#123;    const count = ref(0);    return &#123; count &#125;;  &#125;,  template: `&lt;div&gt;count is &#123;&#123; count &#125;&#125;&lt;/div&gt;`&#125;\n","categories":["vue3 - 文档"],"tags":["vue3","vue"]},{"title":"v-model","url":"/2023/12/05/10-v-model/","content":"基础&lt;input    :value=&quot;text&quot;    @input=&quot;event =&gt; text = event.target.value&quot; /&gt;\n\n用 v-model 简化：\n&lt;input v-model=&quot;text&quot; /&gt;\n\n类型单行&lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;input v-model=&quot;message&quot; placeholder=&quot;edit&quot; /&gt;\n\n多行&lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;textarea v-model=&quot;message&quot; placeholder=&quot;edit&quot;&gt;&lt;/textarea&gt;\n\n复选框label 标签 for 属性的作用：用户点击 label 标签时，浏览器会将焦点转移到与 for 属性值相匹配的表单控件上，从而提高表单的可访问性和易用性。\n&lt;div&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/div&gt;&lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt;&lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt;&lt;label for=&quot;john&quot;&gt;John&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt;&lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt;\n\n单选&lt;div&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/div&gt;&lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot; /&gt;&lt;label for=&quot;one&quot;&gt;One&lt;/label&gt;&lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot; /&gt;&lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt;\n\n选择器单个：\n&lt;div&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/div&gt;&lt;select v-model=&quot;selected&quot;&gt;  &lt;option disabled value=&quot;&quot;&gt;Please select one&lt;/option&gt;  &lt;option&gt;A&lt;/option&gt;  &lt;option&gt;B&lt;/option&gt;  &lt;option&gt;C&lt;/option&gt;&lt;/select&gt;\n\n多个（将值绑定到数组上）：\n&lt;div&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/div&gt;&lt;select v-model=&quot;selected&quot; multiple&gt;  &lt;option&gt;A&lt;/option&gt;  &lt;option&gt;B&lt;/option&gt;  &lt;option&gt;C&lt;/option&gt;&lt;/select&gt;\n\n修饰符.lazy.lazy 修饰符表示在 “change” 事件而不是 “input” 事件触发时更新：\n这意味着数据将在失去焦点后才会同步到视图中，而不是每次输入时都同步。可以用于减少输入框频繁更新视图的情况，尤其是在处理大量输入时可以提高性能。\n&lt;input v-model.lazy=&quot;msg&quot; /&gt;\n\n.number让用户输入自动转换为数字，如果该值无法被 parseFloat() 处理，则将返回原始值。\nnumber 修饰符会在输入框有 type&#x3D;”number” 时自动启用。\n&lt;input v-model.lazy=&quot;msg&quot; /&gt;\n\n.trim默认自动去除用户输入内容中两端的空格：\n&lt;input v-model.trim=&quot;msg&quot; /&gt;\n","categories":["vue - 文档"],"tags":["vue"]},{"title":"vue3 生命周期","url":"/2023/12/05/11-vue3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","content":"vue3 生命周期图示\n\n注册生命钩子用法&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;;onMounted(() =&gt; &#123;    console.log(&#x27;now mounted&#x27;);&#125;);&lt;/script&gt;\n\n调用 onMounted 时，Vue 会自动将回调函数注册到当前正被初始化的组件实例上，所以该钩子应当被同步注册。\n这并不意味对 onMounted 的调用必须放在 setup() 或 &lt;script setup&gt; 内的词法上下文中。\nonMounted() 也可以在一个外部函数中调用，只要调用栈是同步的，且最终起源自 setup() 就可以。\n","categories":["vue3 - 文档"],"tags":["vue3","vue"]},{"title":"vue3 侦听器","url":"/2023/12/07/12-vue3%E4%BE%A6%E5%90%AC%E5%99%A8/","content":"基本用法&lt;script setup&gt;import &#123; ref, watch &#125; from &#x27;vue&#x27;;const initVal = ref(&#x27;&#x27;);watch(initVal, (newVal, oldVal) =&gt; &#123;    ...&#125;);&lt;/script&gt;\n\n侦听数据源类型ref（包括计算属性 computed）、响应式对象、getter 函数、多个数据源组成的数组\nconst x = ref(0), y = ref(0);// refwatch(x, (newX) =&gt; &#123;    console.log(`x is $&#123;newX&#125;`);&#125;);// getter 函数watch(    () =&gt; x.value + y.value,    (sum) =&gt; &#123;        console.log(`sum is $&#123;sum&#125;`);    &#125;);// 多个数据源组成的数组watch(    [x, () =&gt; y.value],    ([newX, newY], [oldX, oldY]) =&gt; &#123;        console.log(`x is $&#123;newX&#125; y is $&#123;newY&#125;`);    &#125;);\n\n侦听响应式对象的属性值不能直接监听响应式对象的属性值，而是使用返回该属性的 getter 函数\nconst obj = reactive(&#123; count: 0 &#125;);// 错误，因为 obj.count 是一个 numberwatch(obj.count, () =&gt; &#123;    .console.log(`count is: $&#123;count&#125;`)&#125;);// 正确，使用一个 getter 函数watch(    () =&gt; obj.count,    (count) =&gt; &#123;      console.log(`count is: $&#123;count&#125;`)    &#125;);\n\n深层侦听器给 watch 传响应式对象，会隐式创建深层监听器\nconst obj = reactive(&#123; count: 0 &#125;);watch(obj, (newVal, oldVal) =&gt; &#123;    ...&#125;);obj.count++; // 属性变更时触发\n\n返回一个响应对象的 getter 函数，只在返回不同对象时才会触发回调\nwatch(    () =&gt; source.obj,    () =&gt; &#123;        ... // 仅当 test.obj 被替换时触发    &#125;);\n\n可以显示添加 deep，转为深层侦听器\nwatch(    () =&gt; source.obj,    () =&gt; &#123;        ... // 仅当 test.obj 被替换时触发    &#125;,    &#123; deep: true &#125;);\n\n创建时立即执行的侦听器创建侦听器时，立即执行\nwatch(source,     (newVal, oldVal) =&gt; &#123;&#125;,     &#123; immediate: true &#125;);\n","categories":["vue3 - 文档"],"tags":["vue3","vue"]},{"title":"vue3 模板引用","url":"/2023/12/08/13-vue3%E6%A8%A1%E6%9D%BF%E5%BC%95%E7%94%A8/","content":"基础&lt;input ref=&quot;myInput&quot; /&gt;&lt;script setup&gt;    import &#123; ref, onMounted &#125; from &#x27;vue&#x27;;    const myInput = ref(null); // 必须和模版中的 ref 同名        onMounted(() =&gt; &#123;        myInput.value.focus(); // 自动聚焦    &#125;);&lt;/script&gt;\n\n只能在组件挂载后访问模板引用，因为初次渲染时模板引用为 null\n比如：\nwatchEffect(() =&gt; &#123;  if (input.value) &#123;    input.value.focus()  &#125; else &#123;    // 此时还未挂载，或此元素已卸载（例如 v-if=false）  &#125;&#125;)\n\n列表引用&lt;script setup&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;;const list = ref([    /* ... */]);const itemRefs = ref([]);onMounted(() =&gt; &#123;    console.log(itemRefs.value);&#125;);&lt;/script&gt;&lt;template&gt;    &lt;ul&gt;        &lt;li v-for=&quot;item in list&quot; ref=&quot;itemRefs&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;    &lt;/ul&gt;&lt;/template&gt;\n\n函数模板引用每次组件更新时会调用 handleRef：\n&lt;input :ref=&quot;handleRef(el)&quot; /&gt;&lt;script setup&gt;const handleRef = (el) =&gt; &#123;    /*  将 el 赋给 ref 变量 */&#125;;&lt;/script&gt;\n\n组件上的 ref引用获得的值是组件实例：\n&lt;script setup&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;;import Child from &#x27;./Child.vue&#x27;;const child = ref(null);onMounted(() =&gt; &#123;    // child.value 是 &lt;Child/&gt; 组件实例&#125;);&lt;/script&gt;&lt;template&gt;    &lt;Child ref=&quot;child&quot; /&gt;&lt;/template&gt;\n\n父组件对子组件访问权1. 选项式 API 或 不使用 &lt;script setup&gt;父组件对子组件的所有属性和方法有完全的访问权（大多情况下应使用 props 和 emit）。\n2. 使用 &lt;script setup&gt;子组件默认私有，除非子组件在其中通过 defineExpose 宏显示暴露。\n&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;;const a = 1, b = ref(2);// 编译器宏无需导入defineExpose(&#123;    a,    b&#125;);&lt;/script&gt;\n","categories":["vue3 - 文档"],"tags":["vue3","vue"]},{"title":"vue3 组件基础","url":"/2023/12/11/14-vue3%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/","content":"基础父传子defineProps 是仅在 &lt;script setup&gt; 中可用的编译宏命令\n&lt;script setup&gt;defineProps([&#x27;title&#x27;, &#x27;content&#x27;]);&lt;/script&gt;&lt;template&gt;&#123;&#123; title &#125;&#125;&#123;&#123; content &#125;&#125;&lt;/template&gt;\n\n子传父defineEmits 是仅在 &lt;script setup&gt; 中可用的编译宏命令\n&lt;script setup&gt;const emit = defineEmits(&#x27;enlarge-text&#x27;);emit(&#x27;enlarg-text&#x27;); // 抛出事件&lt;/script&gt;\n\nslot 插槽子组件：\n&lt;template&gt;    &lt;div class=&quot;child&quot;&gt;        &lt;span&gt;123&lt;/span&gt;        &lt;slot /&gt;    &lt;/div&gt;&lt;/template&gt;\n\n父组件：\n&lt;template&gt;    &lt;child-component&gt;        &lt;span&gt;hahaha&lt;span&gt;    &lt;/child-component&gt;&lt;/template&gt;\n\n子组件渲染结果为：\n&lt;template&gt;    &lt;div class=&quot;child&quot;&gt;        &lt;span&gt;123&lt;/span&gt;        &lt;span&gt;hahaha&lt;/span&gt;    &lt;/div&gt;&lt;/template&gt;\n\n子组件标签子组件有关闭标签父组件可以子组件传递 slot 内容\n&lt;my-component&gt;&lt;/my-component&gt;\n\n子组件无关闭标签父组件无法向子组件传递 slot 内容\n&lt;my-component /&gt;\n\n动态组件通过 component 组件，和 :is 属性切换动态组件\n&lt;template&gt;    &lt;!-- 点击切换 tab --&gt;    &lt;button v-for=&quot;tab in tabs&quot; @click=&quot;curTab = tab&quot;&gt;       &#123;&#123; tab &#125;&#125;    &lt;/button&gt;    &lt;!-- 动态组件 --&gt;   &lt;component :is=&quot;tabs[curTab]&quot;&gt;&lt;/component&gt;&lt;/template&gt;&lt;script setup&gt;import Home from &#x27;./Home.vue&#x27;;import Posts from &#x27;./Posts.vue&#x27;;import Archive from &#x27;./Archive.vue&#x27;;import &#123; ref &#125; from &#x27;vue&#x27;;const curTab = ref(&#x27;Home&#x27;); // 初始展示 Home 组件const tabs = &#123;    Home,    Posts,    Archive&#125;;&lt;/script&gt;\n\n元素位置限制某些元素对于放在其中的元素类型有限制：&lt;ul&gt;, &lt;ol&gt;, &lt;table&gt;, &lt;select&gt;\n某些元素仅在特定元素中才会显示：&lt;li&gt;, &lt;tr&gt;, &lt;option&gt;\n&lt;table&gt;    &lt;!-- 自定组件在 &lt;table&gt; 中不生效 --&gt;    &lt;post-row&gt;&lt;/post-row&gt;&lt;/table&gt;\n\n解决方案（使用 is 属性）：\n&lt;table&gt;    &lt;tr is=&quot;vue:post-row&quot;&gt;&lt;/tr&gt;&lt;/table&gt;\n","categories":["vue3 - 文档"],"tags":["vue3","vue"]},{"title":"vue3 组件注册","url":"/2023/12/13/15-vue3%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C/","content":"全局注册所有子组件可以使用全局注册的组件。\n使用 vue 应用实例的 .component() 方法：\nimport &#123; createApp &#125; from &#x27;vue&#x27;;const app = createApp(&#123;&#125;);app.component(&#x27;myComponent&#x27;,&#123;    // 组件的实现&#125;);\n\n对于单文件组件：\nimport MyComponent from &#x27;./App.vue&#x27;app.component(&#x27;MyComponent&#x27;, MyComponent);\n\n链式：\napp.    component(&#x27;ComponentA&#x27;, ComponentA).    component(&#x27;ComponentB&#x27;, ComponentB).    component(&#x27;ComponentC&#x27;, ComponentC);\n\n局部注册优点\ntree-shaking：全局注册的组件，即使不用，也会出现在打包后的 JS 文件中；而局部注册会移除未使用的组件。\n依赖关系明确：全局注册使大型项目中组件的依赖关系不够明确；而局部组件使组件间的依赖关系更加明确。\n\n","categories":["vue3 - 文档"],"tags":["vue3","vue"]},{"title":"vue3 props & emits","url":"/2023/12/15/16-vue3%20props%20&%20emits/","content":"props注意：props 为单向数据流，从父组件流子组件，所以不应该在子组件中修改 props。\n如有需要：\n\n用另一个属性接收该 prop 的初始值；\n基于该 prop 定义一个计算属性；\n向父组件抛出一个事件。\n\n声明使用字符串数组：\n&lt;script setup&gt;const props = defineProps([&#x27;foo&#x27;]);&lt;/script&gt;\n\n使用对象：\n&lt;script setup&gt;const props = defineProps(&#123;    title: String,    likes: Number&#125;);&lt;/script&gt;\n\n静态 prop除了静态字符串，都应该使用变量进行传递。\n&lt;BlogPost title=&quot;this is a title&quot; /&gt;&lt;!-- &lt;BlogPost :likes=&quot;42&quot; /&gt; --&gt;&lt;BlogPost :likes=&quot;post.likes&quot; /&gt;&lt;!-- &lt;BlogPost is-published=&quot;true&quot; /&gt; --&gt;&lt;BlogPost :is-published=&quot;post.isPublished&quot; /&gt;&lt;!-- &lt;BlogPost ids=&quot;[1, 2, 3]&quot; /&gt; --&gt;&lt;BlogPost :ids=&quot;post.ids&quot; /&gt;&lt;!-- &lt;BlogPost author=&quot;&#123; name: &#x27;Zoella&#x27;, age: 22 &#125;&quot; /&gt; --&gt;&lt;BlogPost :author=&quot;post.author&quot; /&gt;\n\n一个对象绑定多个 prop使用无参数的 v-bind，而不是 :prop-name\nconst post = &#123;    id: 1,    title: &quot;this is title&quot;,&#125;;\n\n&lt;BlogPost v-bind=&quot;post&quot; /&gt;\n\nprop 校验defineProps(&#123;  // 多种可能的类型检查（给出 `null` 和 `undefined` 值则会跳过任何类型检查）  propA: [String, Number],  // 必传，且为 String 类型，默认值为 &#x27;defualtVal&#x27;  propB: &#123;    type: String,    required: true,    default: &#x27;defaultVal&#x27;  &#125;,  // 对象类型的默认值  propC: &#123;    type: Object,    // 对象或数组的默认值，必须从一个工厂函数返回。    // 该函数接收组件所接收的原始 prop 作为参数。    default(rawProps) &#123;      return &#123; message: &#x27;hello&#x27; &#125;    &#125;  &#125;,  // 自定义类型校验函数  propD: &#123;    validator(value) &#123;      return [&#x27;success&#x27;, &#x27;warning&#x27;, &#x27;danger&#x27;].includes(value)    &#125;  &#125;,  // 函数类型的默认值  propE: &#123;    type: Function,    default() &#123;      return &#x27;Default function&#x27;    &#125;  &#125;&#125;);\n\nBoolean 类型转换defineProps(&#123;  disabled: Boolean&#125;);\n\n使用时：\n&lt;!-- 等同于 &lt;MyComponent :disabled=&quot;true&quot;&gt;&lt;/MyComponent&gt; --&gt;&lt;MyComponent disabled&gt;&lt;/MyComponent&gt;&lt;!-- 等同于 &lt;MyComponent :disabled=&quot;false&quot;&gt;&lt;/MyComponent&gt; --&gt;&lt;MyComponent&gt;&lt;/MyComponent&gt;\n\nemit事件校验&lt;script setup&gt;const emit = defineEmits(&#123;  // 无校验  click: null,  // 校验 submit 事件  submit: (&#123; email, password &#125;) =&gt; &#123;    if (email &amp;&amp; password) &#123;      return true;    &#125; else &#123;      console.warn(&#x27;Invalid submit event payload!&#x27;)      return false;    &#125;  &#125;&#125;);function submitForm(email, password) &#123;  // 抛出 submit 事件，携带 email, password 参数  emit(&#x27;submit&#x27;, &#123; email, password &#125;);&#125;&lt;/script&gt;\n","categories":["vue3 - 文档"],"tags":["vue3","vue"]},{"title":"vue3 组件 v-model","url":"/2023/12/15/17-vue3%E7%BB%84%E4%BB%B6v-model/","content":"基础父组件：\n&lt;CustomInput v-model=&quot;searchText&quot; /&gt;&lt;!-- 被展开为： --&gt;&lt;!-- &lt;CustomInput    :model-value=&quot;searchText&quot;    @update:model-value=&quot;newValue =&gt; searchText = newValue&quot; /&gt; --&gt;\n\n子组件：\n在引用的子组件中使用 v-model 指令时，子组件的 modelValue prop 默认用于传递输入值，并且会触发名为 update:modelValue 的事件来更新该属性。\n&lt;script setup&gt;// 声明属性 modelValue，这是父组件通过 v-model 传给当前组件的 propdefineProps([&#x27;modelValue&#x27;]);// 声明事件 update:modelValue，用于在当前组件中触发父组件的更新操作defineEmits([&#x27;update:modelValue&#x27;]);&lt;/script&gt;&lt;template&gt;  &lt;!-- 将 modelValue 作为其值，并在输入时触发 update:modelValue 事件 --&gt;  &lt;input    :value=&quot;modelValue&quot;    @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;  /&gt;&lt;/template&gt;\n\n如何更改默认名 modelValue父组件：\n&lt;MyComponent v-model:title=&quot;bookTitle&quot; /&gt;\n\n子组件：\n&lt;!-- MyComponent.vue --&gt;&lt;script setup&gt;defineProps([&#x27;title&#x27;]);defineEmits([&#x27;update:title&#x27;]);&lt;/script&gt;&lt;template&gt;  &lt;input    type=&quot;text&quot;    :value=&quot;title&quot;    @input=&quot;$emit(&#x27;update:title&#x27;, $event.target.value)&quot;  /&gt;&lt;/template&gt;\n\n自定义 v-model 修饰符创建一个自定义修饰符 capitalize，自动将 v-model 绑定输入字符串的第一个字母转为大写：\n&lt;MyComponent v-model.capitalize=&quot;myText&quot; /&gt;\n\n&lt;script setup&gt;// modelModifiers prop 包含了 capitalize 且其值为 true// 因为它在模板中的 v-model 绑定 v-model.capitalize=&quot;myText&quot; 上被使用了const props = defineProps(&#123;    modelValue: String,    modelModifiers: &#123;        default: () =&gt; (&#123;&#125;) // 默认值为空对象    &#125;,&#125;);defineEmits([&#x27;update:modelValue&#x27;]);// 将首字母大写function emitValue(e) &#123;    let value = e.target.value;    if(props.modelModifiers.captialize) &#123;        value = value.charAt(0).toUpperCase() + value.slice(1);    &#125;    emit(&#x27;update:modelValue&#x27;, value);&#125;&lt;/script&gt;&lt;template&gt;    &lt;!-- 每次 &lt;input /&gt; 元素触发 input 事件时触发 emitValue --&gt;    &lt;input        type=&quot;text&quot;        :value=&quot;modelValue&quot;        @input=&quot;emitValue&quot;    /&gt;&lt;/template&gt;\n\n带多个不同参数的 v-model 修饰符&lt;UserName    v-model:first-name.capitalize=&quot;first&quot;    v-model:last-name.uppercase=&quot;last&quot;/&gt;\n\n&lt;script setup&gt;const props = defineProps(&#123;    firstName: String,    lastName: String,    firstNameModifiers: &#123;  // firstName + Modifiers        default: () =&gt; (&#123;&#125;)     &#125;,    lastNameModifiers: &#123;  // lastName + Modifiers        default: () =&gt; (&#123;&#125;)    &#125;,&#125;);defineEmits([&#x27;update:firstName&#x27;, &#x27;update:lastName&#x27;]);console.log(props.firstNameModifiers); // &#123; calitalize: true &#125;console.log(props.lastNameModifiers); // &#123; uppercase: true &#125;&lt;/script&gt;\n","categories":["vue3 - 文档"],"tags":["vue3","vue"]},{"title":"vue3 继承 attributes","url":"/2023/12/21/18-vue3%E7%BB%A7%E6%89%BFattributes/","content":"禁用 attributes 继承如果不想一个组件自动继承 attribute，可在组件选项中设置 inheritAttrs: false\n&lt;script setup&gt;defineOptions(&#123;    inheritAttrs: false&#125;);&lt;/script&gt;\n\n透传进来的 attribute 可在模版的表达式中用 $attrs 访问：\n&lt;span&gt;attribute: &#123;&#123; $attrs &#125;&#125;&lt;/span&gt;\n\n示例常见的需要禁用 attribute 继承的场景是：attribute 需要应用在根节点以外的其他元素。\n比如：希望透传的 attribute 应用在内层的节点而非外层。\n&lt;div class=&#x27;btn-wrapper&#x27;&gt;    &lt;button class=&#x27;btn&#x27; v-bind=&quot;$attrs&quot;&gt;click me&lt;/button&gt;&lt;/div&gt;&lt;script setup&gt;defineOptions(&#123;    inheritAttrs: false&#125;);&lt;/script&gt;\n\n多根节点的 attributes 继承需要显示绑定 $attrs，否则会有警告\n&lt;header&gt;...&lt;/header&gt;&lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main&gt;&lt;footer&gt;...&lt;/footer&gt;\n\n在 JS 中访问透传的 attributes使用 useAttrs() API 访问组件的所有透传 attribute\n&lt;script setup&gt;import &#123; useAttrs &#125; from &#x27;vue&#x27;;const attrs = useAttrs();&lt;/script&gt;\n\n但是这里的 attrs 对象不具有响应式，如有需要：\n（1）可使用 prop；\n（2）可使用 onUpdated() 在每次更新时获取最新的 attrs。\n","categories":["vue3 - 文档"],"tags":["vue3","vue"]},{"title":"vue 插槽","url":"/2023/12/26/19-vue%E6%8F%92%E6%A7%BD/","content":"基础插槽内容可以为文本、模版、组件\n&lt;!-- 父组件 --&gt;&lt;FancyButton&gt;  Click me! &lt;!-- 插槽内容 --&gt;&lt;/FancyButton&gt;\n\n&lt;!-- 子组件 --&gt;&lt;button class=&quot;fancy-btn&quot;&gt;  &lt;slot&gt;&lt;/slot&gt; &lt;!-- 插槽出口 --&gt;&lt;/button&gt;\n\n渲染结果：\n&lt;button class=&quot;fancy-btn&quot;&gt;Click me!&lt;/button&gt;\n\n默认内容子组件的 &lt;slot&gt;&lt;/slot&gt; 标签之间是默认值\n&lt;button type=&quot;submit&quot;&gt;  &lt;slot&gt;Submit&lt;/slot&gt; &lt;!-- 默认内容 --&gt;&lt;/button&gt;\n\n具名插槽当一个组件包含多个插槽出口时，需要使用 name 来给各个插槽分配唯一的 ID，没有提供 name 的插槽会隐式地命名为“default”。\n&lt;!-- 子组件 --&gt;&lt;div class=&quot;container&quot;&gt;  &lt;header&gt;    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;  &lt;/header&gt;  &lt;main&gt;    &lt;slot&gt;&lt;/slot&gt; &lt;!-- name 为 default --&gt;  &lt;/main&gt;  &lt;footer&gt;    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;  &lt;/footer&gt;&lt;/div&gt;\n\n在父组件中，使用 v-slot 或者 # 加上插槽名，来指定插槽内容。\n&lt;!-- 父组件 --&gt;&lt;BaseLayout&gt;  &lt;template v-slot:header&gt;    &lt;!-- header 插槽的内容 --&gt;  &lt;/template&gt;  &lt;template #footer&gt;    &lt;!-- footer 插槽的内容 --&gt;  &lt;/template&gt;&lt;/BaseLayout&gt;\n\n动态插槽名可定义动态插槽名：\n&lt;base-layout&gt;  &lt;template v-slot:[dynamicSlotName]&gt;  &lt;/template&gt;  &lt;!-- 缩写 --&gt;  &lt;template #[dynamicSlotName]&gt;    ...  &lt;/template&gt;&lt;/base-layout&gt;\n\n作用域插槽可以向插槽出口传递 attributes\n默认插槽&lt;!-- 子组件 --&gt;&lt;div&gt;    &lt;slot :text=&quot;message&quot; :count=&quot;1&quot;&gt;&lt;/slot&gt;&lt;/div&gt;\n\n&lt;!-- 父组件 --&gt;&lt;MyComponent v-slot=&quot;slotProps&quot;&gt;    &#123;&#123; slotProps.text &#125;&#125; &#123;&#123; slotProps.count &#125;&#125;&lt;/MyComponent&gt;&lt;!-- 或者 --&gt;&lt;MyComponent v-slot=&quot;&#123; text, count &#125;&quot;&gt;    &#123;&#123; text &#125;&#125; &#123;&#123; count &#125;&#125;&lt;/MyComponent&gt;\n\n具名插槽&lt;!-- 父组件 --&gt;&lt;MyComponent&gt;  &lt;template #header=&quot;headerProps&quot;&gt;    &#123;&#123; headerProps &#125;&#125;  &lt;/template&gt;  &lt;!-- 不缩写 --&gt;  &lt;template v-slot:default=&quot;defaultProps&quot;&gt;    &#123;&#123; defaultProps &#125;&#125;  &lt;/template&gt;  &lt;template #footer=&quot;footerProps&quot;&gt;    &#123;&#123; footerProps &#125;&#125;  &lt;/template&gt;&lt;/MyComponent&gt;\n\n&lt;!-- 子组件 --&gt;&lt;slot name=&quot;header&quot; :msg1=&quot;hello1&quot;&gt;&lt;/slot&gt;&lt;slot :msg2=&quot;hello2&quot;&gt;&lt;/slot&gt; &lt;!-- name 为 default --&gt;&lt;slot name=&quot;header&quot; :msg3=&quot;hello3&quot;&gt;&lt;/slot&gt;\n","categories":["vue - 文档"],"tags":["vue"]},{"title":"vue 指令语法","url":"/2023/11/06/2-vue%E6%8C%87%E4%BB%A4%E8%AF%AD%E6%B3%95/","content":"指令种类：v-html, v-bind, v-on, v-model, v-slot …\n指令语法如下图所示：\n动态参数（1）动态参数的值应为字符串或 null（null 会移除该绑定）\n（2）动态参数的名称避免使用大写字母，因为会被强制转为小写（someAttr -&gt; someattr）\n&lt;a :[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;&lt;a @[eventName]=&quot;doSomething&quot;&gt;\n\n修饰符修饰符为以点开头的特殊后缀，比如：.prevent 修饰符会告知 v-on 指令对触发的事件调用 event.preventDefault()\n&lt;div @submit.prevent=&quot;onSubmit&quot;&gt;&lt;/div&gt;\n\nv-htmlspan 的内容会被替换为 rawHtml 属性的值，其中的数据绑定会被忽略（注意：使用这种方法容易造成 XSS 漏洞）\n&lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;\n\nv-bind&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;&lt;!--简写--&gt;&lt;div :id=&quot;dynamicId&quot;&gt;&lt;/div&gt;\n\n动态绑定多个值const objOfAttrs = &#123;    id: &#x27;container&#x27;,    class: &#x27;wrapper&#x27;&#125;;\n\n&lt;div :objOfAttrs&gt;&lt;/div&gt;\n\n比如：动态 style class\n&lt;div :style=&quot;&#123;class1: isClass1, class2: isClass2&#125;&quot;&gt;&lt;/div&gt;\n\nv-on&lt;div v-on:click=&quot;onClick&quot;&gt;&lt;/div&gt;&lt;!--简写--&gt;&lt;div @click=&quot;onClick&quot;&gt;&lt;/div&gt;\n\nv-ifv-if, v-else-if, v-else\n注意：v-if 的优先级大于 v-for，二者不建议同时使用（详见 v-for）\ntemplate 上的 v-if如果想要切换不止一个元素，可以在元素外包一个 &lt;template&gt;，并用 v-if 控制（v-show 不能在 template 上使用）\n因为 &lt;template&gt; 是一个不可见的包装器元素，渲染的结果中不会包含该元素\nv-if &amp; v-show（1）原理：v-if 切换时，条件区块会被销毁与重建；v-show 切换时，只会切换 display 属性\n（2）惰性：v-if 是惰性的，如果初始为 false 则不渲染；v-show 初始始终会渲染\n（3）场景：v-if 初始渲染开销较好，不会频繁切换时使用；v-show 切换开销较小，频繁切换时使用\n","categories":["vue - 文档"],"tags":["vue"]},{"title":"vue3 依赖注入","url":"/2023/12/28/20-vue3%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/","content":"props 逐级透传深层子组件需要较远的祖先组件中的部分数据，使用 props 逐级传递很麻烦：\n\n\n\nprovide（提供）为组件后代提供数据，使用 provide() 函数：\n&lt;script setup&gt;import &#123; provide &#125; from &#x27;vue&#x27;;provide(/* 注入名 */&#x27;message&#x27;, /* 注入值 */&#x27;value&#x27;);&lt;/script&gt;\n\n","categories":["vue3 - 文档"],"tags":["vue3","vue"]},{"title":"浏览器输入url后发生了什么","url":"/2024/10/10/21-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/","content":"1. URL解析用户输入的URL（例如 https://www.example.com/index.html）首先被浏览器解析，该过程包括：\n\n提取协议（如HTTP或HTTPS）\n主机名（如www.example.com）\n端口\n路径（如&#x2F;index.html）\n查询参数\n锚点\n\n详见：\n\n浏览器解析url过程\n\n2. DNS 查询浏览器需要将域名转换为IP地址，以便进行网络通信。此时，浏览器会查找本地DNS缓存，如果没有找到，就会向系统的DNS服务器发送请求。DNS服务器将返回对应的IP地址。\n详见：\n\nDNS\nCDN\n\n3. TCP连接一旦获得了IP地址，浏览器通过TCP（传输控制协议）建立与目标服务器的连接。对于HTTPS请求，还需要进行SSL&#x2F;TLS握手，以确保安全性。这一过程包括：\n\n客户端向服务器发送连接请求\n服务器确认并建立连接\n进行SSL&#x2F;TLS证书验证以及协商加密算法\n\n4. 发送HTTP请求连接建立后，浏览器构建一个HTTP请求并发送到服务器。这个请求包含：\n\n请求行（例如 GET &#x2F;index.html HTTP&#x2F;1.1）\n请求头（例如用户代理、接受类型等信息）\n请求体（对于POST请求，可能包含数据）\n\n5. 服务器处理请求服务器接收到请求后，会根据请求的内容进行处理。它可能会查找文件、访问数据库或者执行其他逻辑，最终生成一个HTTP响应。\n6. 接收HTTP响应服务器发送回HTTP响应，包含状态码（如200表示成功，404表示未找到），响应头（如内容类型、内容长度等）和响应体（实际请求资源的内容，如HTML文档）。\n7. 渲染页面浏览器接收响应后，进行以下步骤：\n\n解析HTML文档，构建DOM树\n如果遇到CSS文件，发起请求以获取样式，并构建CSSOM树\n合并DOM和CSSOM，生成渲染树\n根据渲染树计算布局，决定每个元素的位置和大小\n绘制页面，将内容绘制到屏幕上\n\n8. 处理JavaScript如果HTML中包含JavaScript代码，浏览器会逐步执行这些脚本。JavaScript可以操作DOM，改变页面内容，进行AJAX请求等。\n9. 其它资源加载如果页面中包含其他资源（如图片、音频、视频），浏览器会并行请求这些资源，直至全部加载完成。\n案例说明假设用户在浏览器中输入https://www.example.com/index.html，整个过程如下：\n\n浏览器解析出协议为HTTPS，域名为www.example.com。\n发送DNS请求，获得IP地址93.184.216.34。\n与该IP地址建立TCP连接，并进行TLS握手。\n发送GET请求，请求&#x2F;index.html资源。\n服务器处理请求，返回200状态及index.html内容。\n浏览器解析HTML，构建DOM树，并抓取相关的CSS和JavaScript文件。\n最终呈现完整的网页给用户。\n\n","categories":["计算机网络 - 综合"],"tags":["面经","计算机网络","url"]},{"title":"浏览器解析url过程","url":"/2024/10/14/22-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90url%E8%BF%87%E7%A8%8B/","content":"1. URL的格式协议表示浏览器应当使用的访问方法，包括：”http：””ftp：””file：””mailto：”。比如访问Web服务器使用HTTP协议，访问本地服务器使用FILE协议，访问FTP服务器使用FTP协议。\n图1 列举了常见的几种URL，访问自标不同，URL的写法也不同。例如在访问Web服务器和FTP服务器时，URL中包含服务器的域名和要访问的文件的路径名等，而发邮件的URL则包含收件人的邮件地址。此外，URL还可能包含用户名、密码、服务器端口号等信息。\n图1.1：URL的各种格式\n2. URL的组成元素图1.2：Web浏览器解析url的过程\n图1.3：路径名为&#x2F;dir&#x2F;file1.html的文件\n3. 省略文件名的情况(a) 以”&#x2F;“结尾：lab.glasscom.com/dir/以”&#x2F;dir&#x2F;“结尾代表&#x2F;dir&#x2F;后面本应该有的文件名被省略了。我们会在服务器上事先设置好文件名省略时要访问的默认文件名，大多情况下是index.html或者default.htm。因此，像前面这样省略文件名时，服务器就会访问其中的默认文件。\n(b) 域名+”&#x2F;“：lab.glasscom.com/以”域名+&#x2F;“结尾表示访问一个名叫”&#x2F;“的目录（根目录）；由于省略了文件名，会访问&#x2F;index.html之类的文件。\n(c) 域名：lab.glasscom.com以域名结尾时，就代表访问根目录下事先设置的默认文件，也就是&#x2F;index.html之类的文件。\n(d) 路径结尾无”&#x2F;“：lab.glasscom.com/whatisthis先文件，后目录。如果Web服务器上存在名为whatisthis的文件，则将whatisthis作为文件名来处理；如果存在名为whatisthis的目录，则将whatisthis作为目录名来处理。\n备注\nURL：Uniform Resource Locator，统一资源定位符。\nFTP：File Transfer Protocol，文件传送协议。是在上传、下载文件时使用的协议（也指使用FTP协议传送文件的程序）。\nHTTP：Hypertext Transfer Protocol，超文本传送协议。\n根目录：”&#x2F;“目录 表示最顶层的目录 “根目录”。\n\n","categories":["计算机网络 - url"],"tags":["面经","计算机网络","url"]},{"title":"投放链接防重定向","url":"/2024/10/14/23-%E6%8A%95%E6%94%BE%E9%93%BE%E6%8E%A5%E9%98%B2%E9%87%8D%E5%AE%9A%E5%90%91/","content":"为了防止浏览器进行多次重定向，影响页面性能，投放链接应该以 https 开头，以 ‘&#x2F;‘ 结尾不用：http://lc.jr.jd.com/finance/fund/fundinvest/investZone使用：https://lc.jr.jd.com/finance/fund/fundinvest/investZone/\n不正确投放链接访问http://lc.jr.jd.com/finance/fund/fundinvest/investZone的请求过程：\n一、有缓存1. 协议变为 https浏览器把协议从http替换为https（使用307重定向，保证不改变请求方法GET）\n\n2. 本地缓存获取IP浏览器在本地缓存中获取到IP（远端地址）；重定向到补充末尾”&#x2F;“的规范URL\n\n返回304响应码，该GET请求的request header中包含（与缓存相关的）条件参数\n使用path相对路径进行重定向，因为nginx在server中设置了absolute_redirect off\n\n\n请求头中的条件参数（If-xxx）：\n3. 请求资源浏览器使用上述请求从本地缓存中获取的IP，向远端服务器GET资源，并成功\n二、无缓存无缓存时，第2步变为使用301重定向\n\n正确投放链接访问https://lc.jr.jd.com/finance/fund/fundinvest/investZone/的请求过程：\n一、有缓存服务器返回304响应码，表示可以使用客户端中之前缓存的副本\n\n该请求的request header中包含「与缓存相关」的条件参数\n\n\n二、无缓存普通请求，响应码为200\n","categories":["计算机网络 - url"],"tags":["面经","计算机网络","url","实践问题"]},{"title":"浏览器缓存与304状态码","url":"/2024/10/16/24-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E4%B8%8E304%E7%8A%B6%E6%80%81%E7%A0%81/","content":"总结出现304状态码的条件\n\n不禁止缓存\n不检查本地缓存是否过期；或者检查本地缓存、且未过期\n响应头有Etag（则下次的请求头中有If-None-Match）；或者响应头有Last-Modified（则下次的请求头中有If-Modified-since）\n缓存有效\n\n注意：下图中的Etag和Last-Modified之间不存在先后顺序\n\n一、304请求的交互过程假设用户通过浏览器访问某静态资源（比如图片image.png），且该资源之前已被浏览器缓存，现在分析两次请求的交互过程。\n第一次请求（初始加载）1、浏览器发送请求用户在浏览器中输入 URL，浏览器向服务器发送 GET 请求，获取 image.png。请求头可能如下：\nGET /image.png HTTP/1.1Host: example.comUser-Agent: Mozilla/5.0 ...Accept: image/webp,image/apng,image/*,*/*;q=0.8\n\n2、服务器响应服务器处理请求，并返回 200 OK 响应，同时附带以下响应头：\nHTTP/1.1 200 OKContent-Type: image/pngContent-Length: 123456Last-Modified: Mon, 01 Jan 2023 12:00:00 GMTETag: &quot;abc123&quot;Cache-Control: max-age=31536000\n\n\nLast-Modified：表示资源最后修改的时间\nETag：资源的唯一标识符\nCache-Control：指示浏览器可以缓存该资源的时长\n\n3、浏览器缓存资源浏览器接收响应后，将image.png缓存到本地，并根据响应头信息（如Last-Modified和ETag）记录该资源的状态\n第二次请求（缓存验证）1、浏览器发送条件请求当用户再次访问同一资源，浏览器会检查缓存，如果该资源仍然有效，就发送一个带条件的 GET 请求到服务器，请求头如下：\nGET /image.png HTTP/1.1Host: example.comIf-Modified-Since: Mon, 01 Jan 2023 12:00:00 GMTIf-None-Match: &quot;abc123&quot;User-Agent: Mozilla/5.0 ...\n\n\nIf-Modified-Since：告诉服务器，如果在指定日期之后资源被修改，则返回新的资源\nIf-None-Match：告诉服务器，如果资源的ETag与提供的值不匹配，则返回新的资源\n\n2、服务器处理请求服务器接收到条件请求后，检查该资源的状态：如果资源自Last-Modified时间以来未被修改，且ETag匹配，那么服务器不会返回新的内容，而是返回 304 Not Modified。\n服务器返回如下响应：\nHTTP/1.1 304 Not ModifiedDate: Mon, 02 Jan 2023 12:00:00 GMT\n\n注意：304 响应没有消息体，通常只包含必要的状态码和一些响应头。\n3、浏览器处理304响应当浏览器接收到 304 Not Modified 响应时，了解到之前缓存的 image.png 仍然有效，因此直接使用缓存中的版本，而无需重新下载。\n二、详细讨论1、是否禁止缓存禁止缓存：缓存中不得存储任何关于客户端请求和服务端响应的内容，客户端每次发起的请求都会下载完整的响应内容\n在请求头中，Cache-Control: no-store 与 Pragma: no-cache 都可以禁止缓存\n\nPragma: no-cache 可用于 http 1.0 和 http 1.1\nCache-Control: no-store 只能用于 http 1.1\n\n2、是否检查本地副本是否过期由 Cache-Control 的 no-cache 和 must-revalidate 两个可选值控制\n\nno-cache：告诉浏览器、缓存服务器，不管本地副本是否过期，使用资源副本前，必须到源服务器进行副本有效性校验\nmust-revalidate：告诉浏览器、缓存服务器，本地副本过期前，可使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验（如果没有该属性，若发生网络问题等情况，客户端可能直接使用本地缓存，而不会向服务器发起校验）\n\n3、检查本地副本是否过期与「缓存的过期机制」相关的响应头字段（优先级依次降低）：\n（1）max-age=&lt;seconds&gt;表示资源能被缓存的最大时间，通常和 must-revalidate 一起使用。\n本地副本过期前，可使用本地副本，缓存时间为60秒；如果本地副本已过期，则重新向服务器请求（要求必须进行有效性校验）：\nCache-Control: max-age=60, must-revalidate\n\n共享缓存（如代理服务器）将在60秒后失效，而个人用户的缓存则在120秒后失效：\nCache-Control: max-age=120, smax-age=60\n\n（2）Expires表示资源的过期时间。如果无max-age但有Expires，通过比较Expires和Date的值来判断是否缓存有效：\n\n（3）Last-Modified表示资源的最后修改时间。如果无max-age和expires但有Last-Modified，缓存的时长等于\n(Date - Last-Modified) / 10\n\n\n如果都没有，浏览器将不会对该需求进行缓存。\n4、本地副本没过期直接从缓存中读取资源，并返回200状态码。\n\n5、本地副本已过期进行「源服务器进行有效性校验」的前期准备：\n（1）If-None-Match首先，在请求头里寻找If-None-Match字段（其值为服务器上次返回的ETag响应头的值）\n\n（2）If-Modified-Since如果没有If-None-Match，则在请求头中寻找If-Modified-Since字段（其值为服务器上次返回的Last-Modified响应头中的日期值）\n\n如果If-None-Match与If-Modified-Since都没有，则直接向服务器请求数据\n6、去源服务器进行有效性校验如果请求头中有If-None-Match或If-Modified-Since，则到源服务器进行有效性校验。如果源服务器资源没有变化，则返回304；如果有变化，则返回200。\n7、上述流程的总结图\n三、意义\n避免了不必要的数据传输，提高了网络效率和用户体验；\n在频繁访问相同资源的情况下，可以显著降低带宽消耗和服务器负载。\n\n四、补充私有缓存和公共缓存在Cache-Control还有两个值：private与public：\n\npublic 表示该响应可被任何中间人（比如中间代理、CDN等）缓存。\nprivate 表示该响应是专用于某单个用户的，不能被中间人缓存，应该用于浏览器的私有缓存中，比如：带有HTTP验证信息（帐号密码）的页面 或 某些特定影响状态码的页面*。\n\n“某些特定影响状态码的页面”指具有特殊语义的状态码，比如：\n（1）401 Unauthorized当访问受保护的资源时，如果用户未通过身份验证，服务器可能返回401状态码。此时通常只应允许客户端缓存该响应，因为该内容对其他用户是不适用的。\n（2）403 Forbidden表示服务器理解请求但拒绝执行它。在某些情况下，公共内容也可能出于安全考虑而不被中间缓存，因此可标记为 private。\n（2）404 Not Found如果某资源不存在，虽然它是公开的，但可能在某些应用场景下不希望被中间缓存。\n（3）500 Internal Server Error表示服务器出现了问题，返回的内容可能不稳定，因此不应被中间缓存。\nprivate 使用场景（1）用户特定数据如个性化推荐、用户历史记录等，仅对特定用户合适，其他用户无法访问，即便返回成功状态，为了保护用户隐私，建议使用 private。\n（2）临时性数据如操作结果、表单提交后给予反馈的信息等，这类信息通常只需当前用户知道，对其他用户无意义，适合标记为 private。\n","categories":["计算机网络 - 状态码","计算机网络 - 浏览器"],"tags":["面经","计算机网络","url","状态码","浏览器"]},{"title":"DNS","url":"/2024/10/18/25-DNS/","content":"一、定义DNS 是：\n\n一个使得主机能够查询分布式数据库的应用层协议\n一个由分层的 DNS 服务器实现的分布式数据库\n\n（1）DNS 是一个分布式数据库，整个 DNS 系统由分散在世界各地的很多 DNS 服务器组成，每台服务器上都保存了一些数据，可以让我们最终查到主机名对应的 IP。\n（2）DNS 是一个应用层协议，发送一个包含所查询主机名的请求，它会返回该主机名对应的 IP。\n分布式： 世界上没有一台 DNS 服务器拥有因特网上所有主机的映射，每台 DNS 只负责部分映射。\n二、层次DNS 服务器有 3 种类型：\n\n根 DNS 服务器\n顶级域（Top-Level Domain, TLD）\nDNS 服务器\n权威 DNS 服务器\n\n\n1、根 DNS 服务器比如 www.baidu.com，其完整写法是 www.baidu.com.，最后的这个 . 就是根域名。\n通过询问根 DNS 服务器，可以知道它的下一级，也就是顶级域 DNS 服务器的 IP 是多少，从而继续向顶级域 DNS 服务器发起查询请求。\n2、顶级域 DNS 服务器除了前面提到的 com 是顶级域名，常见的顶级域名还有 cn、org、edu 等。顶级域 DNS 服务器，也就是 TLD，提供了它的下一级，也就是权威 DNS 服务器的 IP 地址。\n3、权威 DNS 服务器权威 DNS 服务器可以返回主机和IP之间的最终映射。\n三、本地 DNS 服务器每个 ISP（Internet Server Provider, 网络服务提供商）都有一台本地 DNS 服务器，比如一个居民区的 ISP、一个大学的 ISP、一个机构的 ISP，都有一台或多台本地 DNS 服务器。\n当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，本地 DNS 服务器起着代理的作用，并负责将该请求转发到 DNS 服务器层次结构中。\n严格来说，本地 DNS 服务器不属于 DNS 的层次结构。\n四、递归查询、迭代查询如下图，假设主机 m.n.com 想要获取主机 a.b.com 的 IP 地址，会经过以下几个步骤：\n\n（1）首先，主机 m.n.com 向它的本地 DNS 服务器发送一个 DNS 查询报文，包含期待被转换的主机名 a.b.com；\n（2）本地 DNS 服务器将该报文转发到根 DNS 服务器；\n（3）该根 DNS 服务器注意到 com 前缀，向本地 DNS 服务器返回 com 对应的顶级域 DNS 服务器（TLD）的 IP 地址列表。\n（4）本地 DNS 服务器则向其中一台 TLD 服务器发送查询报文；\n（5）该 TLD 服务器注意到 b.com 前缀，向本地 DNS 服务器返回权威 DNS 服务器的 IP 地址。\n（6）本地 DNS 服务器又向其中一台权威服务器发送查询报文；\n（7）该权威服务器返回了 a.b.com 的 IP 地址；\n（8）本地 DNS 服务器将 a.b.com 跟 IP 地址的映射返回给主机 m.n.com，m.n.com 就可以用该 IP 向 a.b.com 发送请求了。\n1、递归主机 m.n.com 向本地 DNS 服务器 dns.n.com 发出的查询就是递归查询，这个查询是主机 m.n.com 以自己的名义向本地 DNS 服务器请求想要的 IP 映射，并且本地 DNS 服务器直接返回映射结果给到主机。\n2、迭代而后继的三个查询是迭代查询，包括本地 DNS 服务器向根 DNS 服务器发送查询请求、本地 DNS 服务器向 TLD 服务器发送查询请求、本地 DNS 服务器向权威 DNS 服务器发送查询请求，所有的请求都是由本地 DNS 服务器发出，所有的响应都是直接返回给本地 DNS 服务器。\n3、另一种 DNS 查询从理论上讲，任何 DNS 查询既可以是递归的，也可以是迭代的。下图的所有查询就都是递归的，不包含迭代。\n\nTLD 一定知道权威 DNS 服务器的 IP 地址吗？不一定，有时 TLD 只是知道中间的某个 DNS 服务器，再由这个中间 DNS 服务器去找到权威 DNS 服务器。\n这种情况不仅增加了延迟，还使得网络上需要传输更多的数据包，也会产生更多的 DNS 报文。\n五、DNS 优化1、DNS 缓存DNS 存在多级缓存，从离浏览器的距离排序，有以下几种：浏览器缓存，系统缓存，路由器缓存，IPS 服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。\n\n在chrome浏览器中输入 chrome://net-internals/#dns，可以看到chrome浏览器的DNS缓存\n系统缓存主要存在 /etc/hosts （Linux系统）中\n\n缓存并不是永久的，每一条映射记录都有对应的生存时间，一旦过了生存时间，该条记录就会从缓存移出。\n2、DNS 负载均衡访问某网站的时候，每次响应的很可能不是同一个服务器（IP 地址不同），因为一般公司都有多台服务器来支撑访问，而 DNS 会返回一个合适的机器的 IP 给用户（根据每台机器的负载量、该机器和用户地理位置的距离等），这就是 DNS 负载均衡。\n","categories":["计算机网络 - DNS"],"tags":["面经","计算机网络","DNS"]},{"title":"CDN","url":"/2024/10/29/26-CDN/","content":"一、概念CDN 全称为 “Content Delivery Network”，即内容分发网络。CDN 是一种特殊的 DNS服务器。\n二、原理当使用域名访问某一个网站时（比如访问 www.baidu.com），分为两步：\n\n首先解析出该域名所对应的 IP地址（DNS 域名解析）\n然后将 Http请求包 路由到 IP地址 所对应的服务器\n\n（注：IP地址和网卡相绑定，一个服务器可以有多个网卡，即可能有多个IP地址）\n1、域名解析域名解析分为两种：\n\n将域名解析为IP地址\n将域名解析为另一个域名（CNAME）\n\n购买一个域名之后，需要去映射一个 IP地址，用 Map 表示：{域名：IP}。也可以给某域名取一个别名，比如给 www.baidu.com 取一个别名 test.baidu.com，用 Map 表示：{域名：CNAME}，这里的CNAME就是别名。\n域名解析，实际上就是解析出指定域名所对应的 IP地址，或该域名的一个 CNAME。\n没有CNAME的情况：\n有CNAME的情况：\n特别注意：在有 CNAME 的情况下，CNAME 在域名解析的过程中承担了代理的角色，这是 CDN 实现的关键。\n2、资源分类服务器上的资源分为两种：\n\n静态资源：这种资源通常很少变动，比如图片，视频，css，js 等等\n动态资源：这种资源不同用户不同时刻访问通常是不一样的，比如 ftl，jsp 等等。\n\n（1）集群（动态资源）在全国各地部署服务器，每个服务器上都有相同的动态资源，并且还需配置相应的数据库，这就涉及到数据同步等问题。这种做法专业一点就是集群，目前集群架构最多是三地五中心，因为全国多地集群成本太高。\n（2）CDN服务器（静态资源）在每个服务器上只部署静态资源是成本较低的方式，因为静态资源通常不涉及数据库，也能提高用户访问速度。\n现在有很多 CDN供应商，只要把系统接入并将静态资源传给 CDN服务，这些静态资源将会自动分布到世界各地。\n在访问静态资源时，DNS系统 进行域名解析的过程中，如何解析出离用户最近的 IP地址？这就需要使用 CDN服务器，该服务器知道用户当前所在位置，和用户访问的域名对应哪些 IP地址，及这些 IP地址 分别在哪。\n这样，只要用户在通过某域名访问静态资源时，配置自己电脑的 DNS地址 为 CDN专用DNS服务器，就可以解决问题了，但不能要求所有用户都去修改自己电脑的 DNS地址，这时就要利用 DNS 中的 CNAME 了。\n3、负载均衡和缓存（1）负载均衡系统如果没有返回 IP地址，本地DNS服务器 会向对应的 CDN服务器 再次发送请求，通过 CDN负载均衡系统 进行智能调度：\n\n看用户的 IP 地址，查表得知地理位置，找相对最近的边缘节点\n看用户所在的运营商网络，找相同网络的边缘节点\n检查边缘节点的负载情况，找负载较轻的节点\n其他，比如节点的“健康状况”、服务能力、带宽、响应时间等\n\n结合以上因素，得到最合适的边缘节点，并把该节点返回给用户，用户就能就近访问 CDN 的缓存代理。\n整体流程如下：\n\n（2）缓存代理缓存系统是 CDN 的另一个关键组成部分，缓存系统会缓存最常用的资源，有两个衡量 CDN服务质量 的指标：\n\n命中率：用户访问的资源恰好在缓存系统里，可直接返回给用户，命中次数与所有访问次数之比\n回源率：缓存里没有，必须用代理的方式回源站取，回源次数与所有访问次数之比\n\n缓存系统可以划分层次为：一级缓存节点和二级缓存节点，一级缓存直连源站，二级缓存直连用户。在回源时，二级缓存首先找一级缓存，一级缓存没有才回源站，可有效减少真正的回源。\n\n现在的商业 CDN命中率都在 90% 以上，相当于把源站的服务能力放大了 10 倍以上\n补充域名解析有多种记录类型，最常用的有：\n\nA记录：一个域名对应一个IP地址\nCNAME：一个域名对应另外一个域名\nNS：将子域名指定其他DNS服务器解析\n\n","categories":["计算机网络 - CDN"],"tags":["面经","计算机网络","CDN"]},{"title":"三次握手&四次挥手","url":"/2024/11/04/27-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B&%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/","content":"三次握手一、概念1、TCP 协议TCP（Transmission Control Protocol），即传输控制协议。TCP 协议是一个 面向连接的、可靠的、基于字节流 的 传输层协议。\nTCP 连接可以用于 保证可靠性 和 流量控制机制，包括 Socket、序列号及窗口大小。\n其中 Socket 是由 IP 加端口组成的，序列号是用来解决乱序问题的，而窗口大小则是用来做流量控制的。\n2、TCP 的特点\n面向连接：TCP 是通过服务端和客户端进行连接的协议。\n面向字节流：TCP 服务端和客户端之间的数据通讯是通过 字节流数据 传输的。\n可靠的：TCP 传输的可靠性得益于 TCP 会记录 信息的发送状态 和 数据的接收与否，对于丢包等发送不成功的情况，TCP 会重新发包，进而保证 TCP 的可靠性。\n\n3、TCP 三次握手\n\nSYN：Synchronize Sequence Numbers，同步序列号，表示发起一个新连接。\nACK：确认收到一个新连接。\nSEQ：序列号。\n\nTCP 三次握手执行过程：\n（1）第一次握手（在吗？）Client 将 SYN 发给 Server。Client 进入 SYN_SENT 状态，等待 Server 确认。\n（2）第二次握手（在的，有事？）Server 收到 SYN，将 SYN+ACK 发给 Client。Server 进入 SYN_RCVD 状态，等待 Client 确认。\n（3）第三次握手（需要数据传输）Client 收到 SYN+ACK，将 SYN 发给 Server。连接成功，Client 与 Server 进入 ESTABLISHED 状态，可以传输数据。\nTCP 为什么需要三次握手？为了防止已失效的请求报文段传送到服务端而产生连接的误判。\n假设是两次握手：\n当 A 发送一个连接请求给 B，但是该请求由于网络原因被阻塞了，一段时间后，A 未收到回复，会认为该消息丢失了，就会重新发送消息。\n当 A 和 B 通信完成后，这个被 A 认为已经丢失的请求到达了 B，B 会认为这是一个新的请求连接消息，就向 A 发送确认。\n但是 A 认为自己没有给 B 再次发送消息，所以不会理睬 B 的确认，但是 B 会一直等待 A 的消息，导致 B 的资源被浪费。\n这就是为什么不能两次握手。\n设计成三次握手的情况，客户端在接收到服务端 SEQ+1 的返回消息后，就会知道该连接是历史连接，接着发送报文告诉服务端。\n为了节省资源，也没必要设计成更多次的握手。\n四次挥手\n四次挥手的 6 种状态（1）FIN_WAIT_1主动方在 ESTABLISHED 状态的时候，想要主动关闭连接，向对方发送 FIN 报文，并进入 FIN_WAIT_1 状态。\n（2）FIN_WAIT_2当主动方收到被动方回复的 ACK 报文后，就进入了 FIN_WAIT_2 状态。\n当主动方进入 FIN_WAIT_2 时，表示半连接状态，即被动方还有数据要发过来。\n（3）CLOSE_WAIT当被动方接收到 FIN 时，会回复一个 ACK，并进入 CLOSE_WAIT 状态。\n在该状态中，被动方如果还有数据要发送，就继续发送，如果没有，就关闭连接，并发送一个 FIN 给对方。\n（4）TIME_WAIT当主动方接收到了 FIN 报文，就回复一个 ACK 报文，并进入 TIME_WAIT 状态。\n如果主动方在 FIN_WAIT_1 状态下，收到了对方的 FIN+ACK 报文，可以跳过 FIN_WAIT_2 直接进入 TIME_WAIT 状态。\n（5）LAST_ACK被动方发送了 FIN 报文后，最后等待对方的 ACK 报文时进入的状态。收到ACK报文后就可以进入CLOSED状态了。\n（6）CLOSED主动方进入 TIME_WAIT 状态后，再等待 2MSL 就会进入 CLOSED 状态。被动方在收到 ACK 报文后，立即进入 CLOSED 状态。\nTIME_WAIT 的意义如果没有 TIME-WAIT，主动方会直接进入 CLOSED 状态。此时如果因为网络原因最后一次 ACK 丢失了，服务端会重复发送 FIN 请求给客户端，所以就需要主动方发送最后一次 ACK 之后进入 TIME_WAIT 状态，等待 2MSL（两个报文最大生命周期），等待这段时间就是为了如果接收到了重发的 FIN 请求能够进行最后一次 ACK 回复。\n","categories":["计算机网络 - TCP"],"tags":["面经","计算机网络","TCP"]},{"title":"interface & type","url":"/2024/11/05/28-interface&type/","content":"一、相同点1、都可以描述对象和函数的类型但语法不一样，type 使用 &#x3D; 赋值\ninterface User &#123;    name: string    age: number&#125;interface SetUser &#123;    (name: string, age: number): void&#125;\n\ntype User = &#123;    name: string    age: number&#125;type SetUser = (name: string, age: number) =&gt; void\n\n2、都允许扩展（extends）并且 interface 和 type 可以互相扩展\n（1）interface 扩展 interfaceinterface Name &#123;    name: string&#125;interface User extends Name &#123;    age: number&#125;\n\n（2）type 扩展 typetype Name = &#123;    name: string&#125;type User = Name &amp; &#123;    age: number&#125;\n\n（3）interface 扩展 typetype Name = &#123;    name: string&#125;interface User extends Name &#123;    age: number&#125;\n\n（4）type 扩展 interfaceinterface Name &#123;    name: string&#125;type User = Name &amp; &#123;    age: number&#125;\n\n二、不同点1、type 可以，但 interface 不行（1）基本类型别名type Name = string\n\n（2）联合类型interface Dog &#123;    dogName: string&#125;interface Cat &#123;    catName: string&#125;type Pet = Dog | Cattype StringOrNumber = string | numbertype Text = string | &#123; text: string &#125;\n\n（3）元组具体定义数组每个位置的类型\ntype PetList = [Dog, List]\n\n（4）使用 typeof 获取实例的类型 对 type 进行赋值let divEle = document.createElement(&#x27;div&#x27;)type Div = typeof divEle\n\n2、interface 可以，但 type 不行interface 能够声明合并interface User &#123;    name: string&#125;interface User &#123;    age: number&#125;/** * User 接口为 &#123; *     name: string *     age: number * &#125; */\n\n三、总结优先用 interface，无法实现再用 type，因为 interface 具有更直观和易于理解的特点，并且能够进行声明合并。\n"},{"title":"TCP","url":"/2024/11/05/29-TCP/","content":"\n一、TCP 和 UDP 的区别TCP 和 UDP 都是传输层协议，不同点在于：\n\nTCP 是 面向连接的、可靠的、面向字节流 的\nUDP 是 面向无连接 的\n\nTCP 的三大核心特性\n1、面向连接在客户端和服务器互相通信之前，TCP 需要三次握手建立连接，而 UDP 不需要\n2、可靠性TCP 的可靠性体现在有状态、可控制。\n（1）有状态TCP 会记录发送的数据，以及其中被接收和未被接收的数据，并保证数据包按序到达\n（2）可控制当意识到丢包或网络不佳，TCP 会根据情况调整自身行为，控制发送速度或者重发\n3、面向字节流UDP 的数据传输是基于数据报的，这仅仅继承了 IP 层的特性；而 TCP 为了维护状态，将 IP 包变成了字节流\n二、TCP 三次握手过程 &amp; 为什么是三次1、流程发送与接收方需要确认双方的两种能力：发送和接收，于是会有三次握手的过程:\n\n（1）服务器变为 LISTEN起初双方都处于 CLOSED 状态。服务端开始监听某个端口，进入 LISTEN 状态（2）客户端变为 SYN-SENT客户端主动发起连接，发送 SYN，并进入 SYN-SENT 状态其中 seq&#x3D;x，表示客户端告诉服务端，我发送的首个数据包 序列号从 x 开始\n（3）服务端变为 SYN-REVD服务端接收到，返回 SYN 和 ACK（对应客户端发来的 SYN），并进入 SYN-REVD 状态其中 seq&#x3D;y，ack&#x3D;x+1，seq&#x3D;y 表示服务端的初始序列号是 y ，ack&#x3D;x+1 表示服务端告诉客户端：已收到从序列号 x 开始的数据包，期望下次发送从序列号 x+1 开始的数据包\n（4）客户端变为 ESTABLISHED客户端再发送 ACK 给服务端，并进入 ESTABLISHED 状态其中 seq&#x3D;x+1 ，ack&#x3D;y+1 。seq&#x3D;x+1 表示客户端按照服务端的期望，从序列号 x+1 开始发送数据包，ack&#x3D;y+1 表示客户端告诉服务端：已收到从序列号 y 开始的数据包，期望下次发送从序列号 y+1 开始的数据包\n服务端收到 ACK 之后，也进入 ESTABLISHED 状态注意：凡是需要对端确认的，一定会消耗 TCP 报文的序列号。SYN 需要对端的确认，而 ACK 不需要，因此 SYN 消耗一个序列号，下次发送对应的 ACK 序列号要加 1，而 ACK 不需要。\n2、为什么不是两次握手根本原因：没有第三次握手，服务端无法确认客户端的接收能力\n如果是两次，客户端发送 SYN 报文试图和服务端建立连接，但是这个包发生了滞留；一段时间后，客户端未收到服务端响应，以为丢了包，于是重传，两次握手建立好了连接。\n但是在连接关闭后，如果滞留的包到达了服务端，这时由于是两次握手，服务端只要接收到、并给客户端发送了相应的数据包，就默认建立连接，但是此时客户端已经断开，这就带来了资源的浪费。\n3、三次握手过程中可以携带数据么第三次握手可以携带数据，前两次握手不能携带\n如果前两次握手能够携带数据，一旦有人想攻击服务器，只需要在第一次握手中的 SYN 报文中放大量数据，服务器势必会消耗更多的时间和内存空间去进行处理，增大了服务器被攻击的风险\n第三次握手时，客户端已处于 ESTABLISHED 状态，并且能够确认服务器的接收、发送能力正常，这时相对安全，可以携带数据\n三、TCP 四次挥手的过程","categories":["计算机网络 - TCP"],"tags":["面经","计算机网络","TCP"]},{"title":"vue3 响应式","url":"/2023/11/06/3-vue3%E5%93%8D%E5%BA%94%E5%BC%8F/","content":"ref()ref() 返回一个包含属性 value 的对象\nimport &#123; ref &#125; from &#x27;vue&#x27;;export default &#123;    setup() &#123;        const count = ref(0);        function increment() &#123;            count.value++;        &#125;        return &#123;            count,            increment        &#125;    &#125;&#125;\n\n&lt;button @click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;\n\n原理ref 的 .value 属性使得 Vue 可以检测其何时被访问或修改\n当一个组件首次渲染时，Vue 会追踪在渲染过程中使用的每一个 ref；当一个 ref 被修改时，它会触发 追踪它的组件 的重新渲染\n// 伪代码const myRef = &#123;    _value: 0,    get value() &#123;        track(); // 追踪渲染过程中使用的每一个 ref        return this._value;    &#125;,    set value(newValue) &#123;        this._value = newValue;        trigger(); // 触发追踪它的组件的重新渲染    &#125;&#125;\n\n&lt;script setup&gt;使用 &lt;script setup&gt; 简化代码\n&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;;const count = ref(0);function increment() &#123;    count.value++;&#125;&lt;/script&gt;&lt;template&gt;    &lt;button @click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;\n\nDOM 更新时机DOM 更新后，立即执行回调函数\nimport &#123; nextTick &#125; from &#x27;vue&#x27;;async function increment() &#123;    count.value++;    await nextTick();    callback();&#125;\n\n或者\nimport &#123; nextTick &#125; from &#x27;vue&#x27;;function increment() &#123;    count.value++;    nextTick(() =&gt; callback());&#125;\n\nreactive()reactive() 使对象本身具有响应性，当 ref 的值是一个对象时，会在内层调用 reactive\n原理reactive() 返回原始对象的 proxy，允许 Vue 拦截和定义基本操作的行为（如属性查找、赋值、删除等）\nreactive() 的返回值和原始对象不相等\nconst raw = &#123;&#125;;const proxy = reactive(raw);console.log(raw === proxy); // false\n\nreactive() 的局限性（1）有限的值类型：只能用于对象类型（对象、数组、Map、Set），不能用于原始类型；\n（2）不能替换整个对象：替换整个对象会导致响应式连接丢失；\n（3）对解构操作不友好：解构后的变量会丢失响应式连接。\nref 解包ref 作为 reactive 对象属性ref 作为响应式对象的属性时，就像一个普通的属性\nconst count = ref(0);const state = reactive(&#123; count &#125;);console.log(state.count); // 0state.count = 1;console.log(state.count); // 1\n\n在模板中解包在模板渲染上下文中，只有顶级的 ref 才会被解包\n第二个不符合预期是因为，obj.id 未被解包，仍是一个 ref 对象\nconst count = ref(0);const obj = &#123;    id: ref(1)&#125;;\n\n&lt;!-- 符合预期 —— 2 --&gt;&#123;&#123; count + 1 &#125;&#125;&lt;!-- 不符合预期 —— [object Object]1 --&gt;&#123;&#123; obj.id + 1 &#125;&#125;\n\n为了解决该问题，需要将 id 结构为顶级属性\nconst &#123; id &#125; = obj;\n\n&lt;!-- 符合预期 —— 2 --&gt;&#123;&#123; id + 1 &#125;&#125;\n","categories":["vue3 - 文档"],"tags":["vue3","vue"]},{"title":"北大-区块链技术与应用1-简介","url":"/2025/01/02/30-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-%E7%AE%80%E4%BB%8B/","content":"本课程主要讲：比特币和以太坊 两种加密货币\n视频链接：\nhttps://www.bilibili.com/video/BV1Vt411X7JF/?spm_id_from=333.337.search-card.all.click&amp;vd_source=69ac93649ea21c4726fe85f272b6d968\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3"]},{"title":"北大-区块链技术与应用2-密码学基础","url":"/2025/01/02/31-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/","content":"Crypto-currency（加密货币）\n区块链和比特币主要用到：哈希函数 和 数字签名\n一、Cryptographic Hash Function（哈希函数）区块链用到了哈希函数的 抗碰撞性 和 隐私性；比特币除了这两个性质，还要求 谜题友好性\n（1）Collision resistance（抗碰撞） x≠y, H(x)≠H(y) 给定一个x，没有高效的方法找到一个y，满足H(x)&#x3D;H(y)，可以用 brute-force（蛮力破解）\n Message digest（信息摘要）：给定一个消息m，用H(m)检测对消息的篡改 对m’≠m，H(m’)≠H(m)\n MD5已经可以被人为地制造碰撞\n（2）Hiding（隐私性）&#x2F; Not invertable（单向不可逆） x –&gt; H(x)，没有高效的方法从H(x)得到x，除了 brute-force\n（3）Puzzle friendly（谜题友好） 不知道如何选定x，使H(x)落在某个区间内，Exp. 00…0XXX…X（以k个0开始）\n 挖矿过程：找一个nonce，和区块块头中的其他信息和在一起作为输入，哈希过后的值要小于等于目标域值，即H(block header) ≤target 其谜题友好意味着，挖矿的过程不存在捷径，只能靠 brute-force，所以该过程才能作为 power of work（pow，工作量证明） 设置 mining puzzle 的原则：Difficult to solve, but easy to verify\nExample 1比特币中用到的哈希函数是 SHA-256（Secure Hash Algorithm），满足以上三个性质\nExample 2Digital commitment（数字承诺），又名 Digital Equivalent of a Sealed Envelope（密封信封的数字等价物），允许一方将某个值（秘密或消息）“承诺”给另一方（验证者）\n结合了哈希函数的抗碰撞和隐私性Hiding：公开m&#x3D;H(x)，给定x’，如果H(x’)&#x3D;m，即可保证x’&#x3D;x\n扩大输入空间的方法：选取nonce（number once）随机数，H(x||nonce)\n二、Digital Signature（数字签名）不同于银行的开户流程，比特币是去中心化的，只要在本地创建一个公私钥对（public key，private key），就代表一个比特币账户，来源于非对称加密体系（asymmetric encryption algorithm）\n在比特币系统中，公私钥用于签名：发布者用自己的私钥对交易进行签名，接受者通过发布者的公钥验签\n生成公私钥、以及签名 都需要 a good source of randomess\n总结在比特币系统中，通常对一个message取哈希，然后再对该哈希值进行签名\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","密码学"]},{"title":"北大-区块链技术与应用3-数据结构","url":"/2025/01/02/32-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","content":"一、Hash Pointers（哈希指针）哈希指针除了地址之外，还要保存地址的哈希值，用于检测结构体的内容是否被篡改\nBlock chain is a linked list using hash pointers.\n\n区块链中的第一个区块叫 genesis block（创世区块），其 height（高度）为 0；最后一个区块叫 most recent block\n后一个区块中的哈希指针是对前一区块的整体取哈希（包含前一区块中储存的哈希指针），可以实现 tamper-evident log（篡改证明记录）\n修改一个区块，会导致其后所有区块的哈希发生改变。所以只需保存和比对最后一个哈希值，就能检测出对区块链中任何部位的修改\n二、Merkle Tree（默克尔树）Merkle tree 和 Binary tree 对比，就是把普通指针换成哈希指针\n\n只要记录并比对 root hash（根哈希值），就能检测出整个树中任何部位的修改\n区块结构每个区块包含 block header（块头） 和 block body（块身）\n1、块头：包含 该区块的所有交易组成的 Merkle tree 的根哈希值，但没有具体的交易内容2、块体：包含具体的交易列表\n比特币节点比特币中的节点分为：\n\nfull node, or fully validationg node（全节点）\nlight node, or light-weight node（轻节点）\n\n1、全节点：保存整个区块的内容，包括块头和块体（包含 tansaction list，即交易的具体信息）；会验证每一笔交易\n2、轻节点：比如手机上的比特币钱包的APP，只保存块头；无法独立验证交易的合法性\n\nMerkle proof 指从交易发生到根哈希值的路径，可以向轻节点证明某笔交易写入了区块链，流程如下：\n（1）轻节点向全节点请求图3中红色的哈希值\n（2）然后根据交易和红色的哈希值，自底向上算出绿色的哈希值，直至算出根哈希值\n（3）最后将算出的根哈希值，与轻节点块头中的哈希指针比较，一致则证明该交易发生在此区块\n上述方法也叫做 proof of membership 或 proof of inclusion假设最底层的交易数为n，验证交易存在的时间复杂度为：θ(log(n))\n对于无序的 Merkle tree，proof of non-membership（验证交易不存在）的时间复杂度为线性 θ(n)，即一个一个试对于 Sorted Merkle tree（对交易取哈希，并且按哈希值大小排序），上述验证的时间复杂度为 θ(log(n))，与二分法一致：只需要对其大小相邻的两个交易进行哈希值的校验，如果和根哈希一致，则证明该交易不存在\n由于区块链中不需要做不存在证明，所以比特币中的 Merkle tree 不要求排序\n除了区块链 和 Merkle tree，哈希指针还可以用在其他无环的链表中\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","数据结构"]},{"title":"北大-区块链技术与应用4-共识协议","url":"/2025/01/02/33-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE/","content":"一、Double spending attack（双花攻击）双花攻击指同一笔资金被重复支付的情况，也是数字货币面临的主要挑战\n中心化解决方案：数字货币上添加唯一编号，并由央行维护一个数据结构，展示每个编号的货币由谁持有；如果付费方的货币在表中对应的持有人与此人不符，则证明该货币已支付给其他人\n去中心化的解决方案：比特币\n关注：货币的发行（挖矿）、交易的有效性验证（防范双花攻击）\n二、交易的有效性验证通过一个由所有用户共同维护的数据结构——区块链 来实现\n三、区块链简易结构Note：以下为简易版的区块链，每个区块都只有一个交易，实际上每个区块的交易记录都构成一个 Merkle tree\n\n存在两种哈希指针：将区块串联成链表的指针，和指向前面某个交易的指针（为了说明币的来源，避免凭空捏造和重复交易）\n1、用户A 具有发行货币的权利（铸币权，mint 铸币），并发行了10个比特币（coin base transaction，铸币交易）\n2、用户A 分别给 用户B、用户C 5个比特币\n3、用户B 分别给 用户C 2个比特币、用户D 3个比特币\n4、用户C 转给 用户E 7个比特币\n5、假设用户B 继续给 用户F 5个比特币，通过区块的回溯，校验出其已经在先前的交易中支付过了，所以交易不合法（避免双花攻击）\n在 用户A 向 用户B 的交易中，需要记录 「输入」A的公钥、A的签名 和 「输出」B的地址（通过B的公钥取哈希等操作得到，可类比为银行卡账号）A 需要 B的公钥 知道向哪里转账，所有节点都 需要 A的公钥 来验签\nBitCoin Scripts交易中的A的公钥（该交易的输入脚本），需要与 币的来源的A的公钥的哈希（前一交易的输出脚本） 相符（两脚本拼在一起能顺利执行）；否则说明币的来源有问题，A被冒名顶替了\n四、区块结构1、Block header包含区块的宏信息，比如：version（协议版本）、hash of privious block header（前一区块头的哈希）、merkle root hash（Merkle树 根哈希），还有和挖矿相关的 target（挖矿的难度目标域值）、nonce（随机数）\nNote：\n（1）hash of privious block header 取的只是前一区块头的哈希，不包含块体\n（2）Merkle树 根哈希 保证了块体中的交易列表不会被篡改\n（3）target 满足 H(block header)≤target，块头中存的是该目标域值的编码 nBits（nBits 是用于表示难度的参数，用于判断区块头是否有效）\nnBitsnBits 是一个包含了目标值信息的编码，通常以十六进制形式存储并表示为一个 4 字节（32 位）的数该编码包含两个部分：\n\n难度指数（Exponent）：前 1 个字节（8 位）\n目标哈希的有效值（Coefficient）：后 3 个字节（24 位）目标值越小，挖掘新区块的难度就越大。这允许系统灵活地调整挖矿的难度，并以压缩的方式存储信息\n\n2、Block body包含 transaction list（交易列表）\n五、Distributed consensus（分布式共识）账本的内容要取得分布式的共识\n1、共识的例子：Distributed hash table（分布式哈希表）达成共识的是 key-value pairs（键值对）\n2、Impossibility result（不可能结论）Example：FLP impossibility result在 asynchronous system（异步系统）中，即使只有一个成员是 faulty（有故障的），那么也无法取得共识\nCAP Theorem\n（1）Consistency（一致性）\n（2）Availability（可用性）：即使某些节点不可用，系统仍然能够提供服务\n（3）Partition tolerance（分区容忍性）：分区是指在网络中，若干节点之间的通信链路发生故障时形成的网络割裂，这意味着某些节点无法与其他节点进行交互\n不可能三角：任何一个分布式系统，只能满足以上两个性质，不可能三个性质都满足\n3、分布式共识的著名协议：Paxos该协议能保证一致性，但是有可能一直达不成共识（可能性比较小）\n六、Consensus in BitCoin（比特币中的共识）1、基于投票的共识方案基于投票的方案需要确认投票权的 membership，比如联盟链的协议 hyperledger fabric（超分类账结构）。常规的投票方案会带来 sybil attack（女巫攻击），即通过超级计算机生成超半数的比特币账户以获取控制权\n2、验证过程H(block header) ≤ target，block header 中包含 4 bytes 的随机数 nonce，组装好区块后就开始尝试不同的 nonce，直到哈希值落在 target 内。如果某节点找到了符合要求的 nonce，即具备了记账权（在去中心化账本中写入&#x2F;发布下一个区块的权利），发布后即由其他区块进行验证：\n1、验证 block header 中的几项\n2、看 block body 中的交易列表，验证每个交易都是合法的：（1）要有合法的签名；（2）以前没有被交易过\n3、Forking attack（分叉攻击）但是不同的链上可能发生重复交易（forking attack），解决方案是以 longest valid chain（最长合法链）为准，因此只有扩展最长合法链的区块才是合法的\n\n当两个矿工同时创造新区块时，其他节点按照接收时间来选择接受哪个区块，等长的临时性的分叉会维持一段时间，直到其中一条链胜出（先找到下一个区块）；而另一条链就变成了 orphan block（孤儿区块） &#x2F; stale block，被丢弃掉，也就没有出块奖励\n4、Block reward（区&#x2F;出块奖励）获得记账权的节点，在发布的区块里可以进行 coinbase transaction（铸币交易），发布一定数量的比特币\n一开始，每个发布的区块可以产生 50 BTC；21万个区块以后，出块奖励会减半为 25 BTC；再过21万个区块，会变成 12.5 BTC（现在）\n平均出块时间为10分钟，出块奖励减半的时间：21w * 10min &#x2F; (60min * 24h * 365d) ≈ 4年\n5、基于 hash rate 的共识方案Hash rate（计算 nonce 哈希的速度）决定了投票的权重，hash rate 越高，获得记账权并得到出块奖励的概率越大\n避免 sybil attack（女巫攻击）：创建多个账户不会增加 hash rate，也不会增加投票权重\n七、类比挖矿：mining\n比特币：digital gold\n矿工（争夺记账权的节点）：minner\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","共识协议"]},{"title":"北大-区块链技术与应用5-BTC系统的实现","url":"/2025/01/12/34-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-BTC%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/","content":"比特币采用 transaction-based ledger（基于交易的账本）模式，每个区块中记录交易信息（转账交易、铸币交易），系统上不记录交易信息\n一、UTXO比特币的全节点要维护一个数据结构 UTXO（Unspent Transaction Output，所有未被花出去的交易的输出 组成的集合）\n一个交易可能有多个输出，即用户可以在一次交易中同时向多人转账（可以节省手续费）\n比如：A 给 B 交易 5 BTC，B 将其交易出去；A 给 C 交易 3 BTC，但未交易出去。这是两个输出，但是只有 A 给 C 的交易在 UTXO 中\n\nUTXO 中的每个元素要给出产生这个输出的交易的哈希值（可理解为交易的ID），以及它在这个交易里是第几个输出，这两个信息可以定位一个 UTXO 中的输出\nUTXO 的用途：在交易发生前，检查即将花出去的币是否在 UTXO 中，在才是合法的，快速校验双花攻击和凭空捏造\n每笔交易会消耗掉 UTXO 中的一些输出，同时在 UTXO 中产生新的输出，total inputs &#x3D; total outputs（所有输入的金额 等于 所有输出的金额）\ntotal inputs ≈ total outputs    1 BTC         0.99 BTC\n\nTransaction fee（交易费）：发布区块的节点（矿工）之所以会把他人的交易打包到新区块里，是因为 BTC 系统的第二个激励机制——交易费。通过把他人的交易打包到区块里，矿工会收取一些交易费（费用高的交易优先级就更高）\n目前矿工挖矿、争夺记账权，主要目的还是为了获取出块奖励，但是随着出块奖励的减少；多年后，交易费可能会变成矿工的主要收益\n二、Account-based ledger（基于账户的账本）和比特币 transaction-based ledger（基于交易的账本）模式不同，以太坊采用 account-based ledger（基于账户的账本）模式，在这种模式中，系统需要显式地记录每个账户有多少币，查询更方便（不需要说明币的来源），但是隐私保护性不如比特币\n三、Block ExampleBlock header 的详细字段：https://developer.bitcoin.org/reference/block_chain.html\n其中，nonce 和 merkle root hash 是可以改变的，通过改变 coinbase message 来改变 merkle root hash（coinbase message 可以看做 extra nonce）\n\n在比特币的 POW（Power of work，工作量证明机制）中，矿工需要不断尝试不同的 nonce 和 coinbase message 组合，以找到一个满足目标哈希值的区块头，共有两层循环：\n外层循环调整 coinbase 域 的 extra nonce，算出 block header 里的根哈希值之后，内层循环再调整 header 里的 nonce\n\n在比特币系统中，验证交易的合法性，就是通过将交易的 input scripts 和 output scripts 配对后执行来完成的。注意：不是把同一个交易的输入脚本和输入脚本配对，而是把这个交易里的输入脚本 和 前一个提供币来源的交易里的输出脚本配对。如果拼接在一起可以顺利执行，那么该交易就是合法的\n四、挖矿概率分析Bernoulli trial（伯努利试验）：A random experiment with binary outcome，比如：掷硬币\nBernoulli process（伯努利过程）：A sequence of independent Bernoulli trials\nPorsson process（泊松过程）：试验次数很多，成功概率很小\n伯努利过程的性质之一是 memoryless（无记忆性）&#x2F; progress free（与过程无关）：前面的实验结果对后面的实验结果无影响。由于挖矿的成功概率很小，所以可以用泊松过程近似\n出块时间服从 Exponential distribution（指数分布），纵轴是 probability density（概率密度），横轴是 time to next block（出块时间）。注意这是整个系统的出块时间，不是每个具体矿工的出块时间，具体到每一个矿工，出块时间取决于矿工的算力占系统总算力的百分比\n\n如果不满足 progress free 这个性质，那么算力强的矿工会获得不成比例的优势，比如：A算力是B算力的10倍，但是A获得记账权的概率超过B的10倍。该性质正是挖矿公平性的保证\n五、比特币的总量产生的比特币数量构成一个 geometric series（几何序列）：21w * 50 + 21w * 25 + 21w* 12.5 + … &#x3D; 21w * 50 * (1 + 1&#x2F;2 + 1&#x2F;4 + …) &#x3D; 2100w\n挖矿的过程对于维护比特币系统的安全性是至关重要的：Bitcoin is secured by mining，对于一个去中心化的系统，挖矿提供了一个凭借算力投票的有效手段，只要大部分算力掌握在诚实的节点手里，系统的安全性就能得到保证\n六、比特币的安全性1、偷币偷币是不可能的，因为系统以最长链合法链为准，恶意节点产生的区块会变成孤儿区块被丢弃，并且恶意节点还会损失本应得的出块奖励\n2、双花攻击可以通过 forking attack（分叉攻击）实现。区块插入的位置在刚开始挖矿的时候就决定，因为设置的 block header 里需要填写前一个区块的哈希值。\n分叉攻击：首先制造等长的合法链，比如，M 向 A 转账交易，产生了不可逆的外部效果（如购买实体商品）；然后再将该交易回滚，留下 M 向自己转账的区块，则 M 可从中不当获利\n\n如何防范分叉攻击？多等几个区块 &#x2F; confirmation（确认），M 向 A 转账的交易刚写入区块的时候，叫 one confirmation，后面的区块类推。比特币协议中缺省的设置是：等待 6 个 confirmation 之后，才认为前面的交易是不可篡改的（大约1小时）\n\n区块链是 Irrevocable ledger（不可篡改的账本），这种不可篡改性只是一种概率上的保证，刚刚写入区块链的内容还是比较容易被改变的，随着后续 confirmation 的增加，被篡改的概率会指数级大幅度下降\nZero confirmation：转账交易发布出去了，但是还未被写入区块链中。这种方式在实际应用中比较普遍，因为（1）比特币协议缺省的设置是 节点接收最先听到的那个交易，所以上述例子中 M 转给自己的交易大概率不会被诚实的节点接受；（2）很多购物网站从支付成功到发货天然是有时间间隔的\n3、恶意节点故意不把合法交易写入因为总有诚实的节点愿意发布这些交易，所以合法交易总是可以被写到下一个区块里\n在正常工作的情况下，也可能出现合法交易未被包含进去的情况，比如近期交易的数目太多。比特币协议中规定，每个区块的大小是有限制的，最多不能超过一兆字节，如果交易的数目太多，可能就只能等到下一个区块再发布\nSelfish mining（自私挖矿）正常情况下，挖到一个区块就立即发布，防止别人发布后自己的区块作废、丧失出块奖励\nSelfish mining：挖到多个区块，但是都藏着不发布，攒够6个之后同时发布。这种攻击的前提是，有恶意的节点需要占据很大一部分算力（比如至少51%）\nSelfish mining 的好处：如果个人算力较强，可以减少挖后续区块的竞争\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","BTC"]},{"title":"北大-区块链技术与应用6-BTC网络","url":"/2025/01/13/35-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-BTC%E7%BD%91%E7%BB%9C/","content":"一、网络层级顶层是 application layer，运行着 BitCoin 和 Block chain 协议；底层是 network layer，运行着 P2P Overlay Network\n比特币的 P2P 网络很简单，所有节点都是平等的，不像有的网络有 super node &#x2F; master node\n二、加入&#x2F;离开网络加入网络前，需要和 seed node（种子节点）联系，它会告知网络中的其他节点，节点之间通过 PCP 通信，有利于穿透防火墙；离开时不需要做任何操作，只需退出应用程序，其他节点会将一段时间未接收到消息的节点删除\n比特币网络设计的原则是：simple, robust, but not efficient（简单、鲁棒，而不是高效）\n三、等待上链的集合每个节点维护一个邻居节点的集合，消息传播在网络中采取 flooding（泛洪）的方式。节点第一次听到某个消息的时候，把它传播给其他所有的邻居节点，并记录已收到该消息，下次再收到时就不会再次转发。邻居节点的选取是随机的，不考虑底层的拓扑结构，这样设计可以增强鲁棒性，但牺牲了效率\n比特币系统中，每个节点需要维护一个等待上链（写入区块链）的集合。第一次听到某个交易的时候，把交易加入该集合，并把该交易转发给邻居节点，下次就不再转发。转发的前提是交易是合法的：签名合法，之前未被花过\n如果同时有两个冲突的交易被广播到网络上，比如：A 转钱给 B，A 又转钱给 C（双花），以首先被写入到区块链上的交易为准，交易被写入到区块链中即被等待上链的集合删除\n四、Best effort比特币网络的传播属于 best effort（尽最大努力），一个交易发送到比特币网络上，不一定所有节点能收到，且顺序也不一定，节点也不一定按照规则传播\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","BTC"]},{"title":"北大-区块链技术与应用7-挖矿难度","url":"/2025/01/13/36-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/","content":"一、挖矿难度和目标域值H(block header) ≤ target\n调整挖矿难度，就是调整目标空间 在整个输出空间中所占的比例，通俗地说，就是哈希值的前面有多少 0\n比特币使用的哈希算法是 SHA-256，整个输出空间是 2^256 个可能的取值\n挖矿难度和目标域值成反比：\n\ndifficulty_1_target：挖矿难度等于1时，对应的目标域值（挖矿难度最小就是1），此时的目标域值很大\n二、出块时间太短的后果系统的总算力越强，安全性就越高，因为发动 51% attack（考虑2个分叉）的成本就更高\n出块时间太短，但是传播速度较慢，很容易导致过多的 forking（分叉），系统的总算力就被分散了，更容易造成 forking attack，因为可以通过较小的算力（100%&#x2F;分叉数+1%）实现攻击\n以太坊的出块时间是15s，出块速度是比特币的40倍，因此以太坊设计了新的共识协议 ghost，其中产生的 orphan block 就不能简单的丢弃，而是要给一些奖励（uncle reward）\n三、调整挖矿难度比特币协议规定每个2016个区块，需要调整目标域值，2016*10/(60*24)≈14天\n调整目标域值的公式：\n\n其中，expected time（预期时间）是 2016*10，actual time（实际时间）是系统近期产生2016个区块所花费的时间。在实际代码中，上调和下调分别有4倍和1&#x2F;4的限度\n如何让所有的矿工同时调整域值？block header 中存储的 nBits 是目标域值编码的版本（将 target 的256字节 压缩到4字节）。如果有矿工不调整，那么校验就不会被通过\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","BTC"]},{"title":"北大-区块链技术与应用8-BTC挖矿","url":"/2025/01/13/37-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-BTC%E6%8C%96%E7%9F%BF/","content":"一、全节点1、一直在线2、在本地硬盘上维护完整的区块链信息3、在内存里维护 UTXO 集合，以便快速检验交易的正确性UTXO（unspent transaction output）\n4、监听比特币网络上的交易信息，验证每个交易的合法性（1）是否有合法的签名\n（2）是不是 double spending\n5、决定哪些交易会被打包到区块里缺省状态下，只要是合法交易、并且交易费符合要求，就会被打包\n6、 监听别的矿工挖出来的区块，验证其合法性（1）区块中的每个交易都要合法，包括铸币交易，比如是否篡改了出块奖励、发布的难度是否符合要求（block header 取哈希后，前面是否有足够多的 0；block header 里的难度目标域值是否设置正确）\n（2）全节点是否每两周调整挖矿难度\n（3）检查该区块是否在延伸最长合法链\n7、挖矿（1）决定沿着哪条链挖下去？缺省情况下沿着最长合法链挖下去\n（2）当出现等长的分叉的时候，选择哪一个分叉？缺省情况下选择最先听到的分叉\n二、轻节点轻节点也叫做 spv client（simplified payment verification）\n1、不是一直在线2、不用保存整个区块链，只要保存每个区块的块头大约是全节点的 1&#x2F;1000\n3、不用保存全部交易，只保存与自己相关的交易4、无法检验大多数交易的合法性，只能检验与自己相关 的那些交易的合法性5、无法检测网上发布的区块的正确性6、可以验证挖矿的难度因为挖矿的时候，计算哈希值只用到了块头的信息\n7、只能检测哪个是最长链，不知道哪个是最长合法链因为无法检测这条链上所包含的交易都是合法的（不过可以检测每个区块是否符合难度要求）\n三、挖矿的注意事项比特币网络中大部分节点都是轻节点，如果只想进行转账，而不进行挖矿，就不需要运行全节点、只需使用轻节点\n在挖矿过程中，如果监听到别人发布了一个区块，需要重新组装区块（block header 和 交易内容都有变化）、重新开始挖\n四、比特币的安全性保证1、密码学恶意节点拿不到私钥，就无法伪造签名，也就无法偷币\n2、好节点占大部分算力前提是系统中大部分算力的矿工是遵守协议的\n五、挖矿趋势一：设备从通用到专用1、CPU最早是用普通的 CPU &#x2F; 通用计算机 挖矿，但是这种方式无法充分利用内存\n2、GPUGPU 用于大规模的并行计算，比如深度学习大量的矩阵乘法，但也部分部件也无法充分利用（比如浮点数运算）\n3、ASIC 芯片ASIC（Application Specific Integrated Circuit，专用集成电路），ASIC 芯片是专门为比特币挖矿计算哈希值而设计，性价比最高\n但是同一个芯片只能用于一种币的挖矿，除非两种币使用同一个 mining puzzle。有些新开发的币会使用已有币的 mining puzzle，进而吸引更多矿工，这叫做 merge mining\n购买 ASIC 矿机的时机很重要，因为过时得很快，现在一般需要提前预定。不良厂商可能会在矿机生产后的黄金两个月先自己挖矿，然后才卖给用户\n有些新型货币，设计的是 alternative mining puzzle，出发点是 ASIC resistance，目的是让通用计算机也能参与挖矿过程\n六、挖矿趋势二：大型矿池的出现矿池的出现是为了解决单个矿工收入不稳定的问题。矿池把矿工组织起来作为一个整体，其架构是：一个全节点驱动多个矿机\n一个矿池一般有一个 pool manager（矿主），下面连着很多 minner（矿工），矿工只负责通过 ASIC 芯片计算哈希值，全节点的其他职责都由矿主承担（比如监听网络上的交易，并将其打包成一个候选区块，同时监听是否有其他节点抢先发布区块）\n矿池的收益分配矿池一般有两种组织形式：\n（1）类似大型数据中心，所有矿机属于同一个机构\n（2）分布式的，矿工和矿主不在同一个地方，矿工加入矿池，是通过矿池规定的通讯协议和矿主进行联系。矿主把要计算的哈希值的任务分配给矿工，矿工计算完成后把结果返回给矿主，有出块奖励时一起参与分红\n通过工作量证明，按照矿工的贡献大小分配收益：降低挖矿难度（减少目标域值前0的数量），符合条件的叫一个 share（almost valid block），挖到合法区块、得到出块奖励之后，矿主按照矿工 share 的数量来分配收益\n1、矿工是否能偷出块奖励？矿工不可能挖到一个合法区块自己偷偷发布，因为矿工的任务由矿主分配，矿主负责组装区块，并把不同的 coinbase parameter 所对应的 nonce，交给不同的矿工尝试，而 coinbase transaction 里的收款人地址填的是矿主的地址\n2、矿工是否能捣乱？是可以的，比如 矿工正常提交 share，但是挖到合法区块之后就丢弃掉\n3、矿池的弊端恶意方可能吸引到足够多的矿工（不明真相的群众）加入，然后发动 51% attack：\n（1）Forking attack：制造分叉，因为算力高，迟早能赶超6个区块；\n（2）Boycott：制裁对象一挖出区块，就分叉，因为算力高，更容易使制裁对象的区块作废\n类似于云计算中的 on demand computing，平时不用自己去维护很大的计算集群，需要用的时候可以随时召唤，对于矿池来说就是 on demand mining\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","BTC"]},{"title":"北大-区块链技术与应用9-BTC脚本","url":"/2025/01/14/38-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-BTC%E8%84%9A%E6%9C%AC/","content":"本节课较多用到 PPT 上的动画，视频链接如下：\nhttps://www.bilibili.com/video/BV1Vt411X7JF?spm_id_from=333.788.player.switch&amp;vd_source=69ac93649ea21c4726fe85f272b6d968&amp;p=9\n比特币使用的编程语言很简单，内存空间只有一个通用的堆栈\n\n上述的输入脚本包含2个操作：分别把2个很长的数压入栈里\n输出脚本有2行，分别对应上面的2个输出，每个输出有自己单独的脚本\nBTC 脚本校验方式假设 A-&gt;B，B-&gt;C，下面对 B 交易时币的来源做校验，有两种校验方式\n\n1、P2PK（Pay to Public Key）input script:    PUSHDATA(Sig)output script:    PUSHDATA(PubKey)    CHECKSIG\n\n1、PUSHDATA(Sig)：把 B 的签名入栈——来自输入脚本\n2、PUSHDATA(PubKey)：把 B 的公钥入栈——来自输出脚本\n3、CHECKSIG：弹出栈顶的两个元素（公钥和签名），用公钥验签，通过则返回 TRUE\n2、P2PKH（Pay to Public Key Hash）——最常用P2PKH 与 P2PK 的区别是：输出脚本给出的不是公钥，而是公钥的哈希值；输入脚本除了签名外，还需要给出公钥\ninput script:    PUSHDATA(Sig)    PUSHDATA(PubKey)output script:    DUP    HASH160    PUSHDATA(PubKeyHash)    EQUALVERIFY    CHECKSIG\n\n1、PUSHDATA(Sig)：把 B 的签名入栈——来自输入脚本\n2、PUSHDATA(PubKey)：把 B 的公钥入栈——来自输入脚本\n3、DUP：把栈顶的元素复制一遍（即 B 的公钥）\n4、HASH160：把栈顶元素弹出，并取哈希（即对 B 的公钥取哈希），然后把得到的哈希再压入栈\n5、PUSHDATA(PubKeyHash)：把 B 的公钥哈希入栈——来自输出脚本\n6、EQUALVERIFY 是弹出栈顶的两个元素（哈希值），并比较它们是否相等\n7、CHECKSIG：弹出栈顶的两个元素（公钥和签名），用公钥验签，通过则返回 TRUE\n3、P2SH（Pay to Script Hash）——最复杂P2SH 的特点是 input script 要提供一个 redeem script（赎回脚本）\nP2SH 常见的应用场景是对 multiple signature（多重签名，即一个输出要求多个签名才能把钱取出，目前已不推荐）的支持\n验证分为两个阶段：第一阶段按照输入脚本和输出脚本的顺序执行；第二阶段执行赎回脚本\n具体略，有点复杂，可简单理解为把 P2PKH 中的 PUSHDATA(PubKey) 和 CHECKSIG 提取成一个赎回脚本\n4、Proof of Burnoutput script:    RETURN        [Zero or more ops or text]\n\n这种类型的输出被称为：Provably Unspendable（可证明不可花费） &#x2F; Prunable Outputs（可删减输出）\n这个脚本是证明销毁掉比特币的一种方法，有两种应用场景：（1）有些小的币种要求销毁一定数量的比特币才能够得到该币，这种币叫做 AltCoin（Alternative Coin）；（2）往区块链中写入一些内容，比如 digital commitment，把知识产权取哈希放在 return 后面，可以证明在某个时间点知道某个知识，任何用户都可以通过销毁少量比特币（将币转到不存在的地址）、换取向区块链写入的机会（不提倡，因为该交易会永久保留在 UTXO 中，浪费资源）\n注意：以上的 CHECKSIG 全称是 OP_CHECKSIG，DUP 全程是 OP_DUP\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","BTC"]},{"title":"北大-区块链技术与应用10-BTC分叉","url":"/2025/01/14/39-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-BTC%E5%88%86%E5%8F%89/","content":"一、State fork（状态分叉）State fork：对比特币当前的状态有分歧造成的分叉，比如两个区块几乎同时生成，造成的分叉\nForking attack 也属于 state fork，但是是人为故意的，所以也叫做 deliberate fork（故意分叉）\n二、Protocol fork（协议分叉）Protocol fork：比特币的协议发生改变（通过软件升级），有些节点由于各种原因可能暂时没有升级，从而造成的分叉\n根据对协议修改的内容的不同，可以分为 hard fork（硬分叉）和 soft fork（软分叉）\n1、Hard fork新节点发布的区块，旧节点可能不认\n1个交易约为250字节，一个区块约有 1000,000字节&#x2F;250字节&#x3D;4000个交易，每秒约有 4000&#x2F;(60*10)≈7个交易，数量过少\n假设 Block size limit 从 1M 更新到 4M，大多数算力的节点更新了软件，但少部分未更新。只要仍有部分节点未更新软件，该分叉就不会消失\nExample：ETH &amp; ETC2016年，以太坊的 DAO（去中心化自治组织）遭到黑客攻击，导致大量ETH被盗。部分成员支持通过硬分叉回滚交易、恢复被盗资金，而另一些成员认为这会破坏区块链的不可篡改性\n最终社区实施硬分叉，恢复到攻击前的状态，这条新链称为 Ethereum（ETH）；而反对硬分叉的用户继续使用原链，称为 Ethereum Classic（ETC），从此两种货币独立发展（通过chain ID 区分两条链）\n2、Soft fork新节点发布的区块，旧节点仍会认可\n假设 Block size limit 从 1M 更新到 0.5M，大多数算力的节点更新了软件，但少部分未更新。如果有节点不更新软件，可能会经常产生孤儿区块，所以最终所有节点都会更新，分叉不会继续延展\nExample：P2SH（Pay to Script Hash）P2SH 的验证分为两步：（1）验证输入脚本给出的赎回脚本，和前一个交易的输出脚本给出的 赎回脚本的哈希值 对得上；（2）执行赎回脚本，验证输入脚本给出的签名是合法的\n对于旧节点来说，只会进行第一阶段的认证；所以新节点认为合法的区块，旧节点仍然会认可\n3、总结（1）Soft fork：只要系统有半数以上的节点更新，就不会有永久的分叉\n（2）Hard fork：如果不是所有的节点都更新了，就会有永久的分叉。根本原因是旧节点不认可新链（不是合法最长链），所以会按照旧链执行\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","BTC"]},{"title":"vue3 计算属性","url":"/2023/11/07/4-vue3%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/","content":"基础computed() 方法接受一个 getter 函数，返回一个计算属性 ref\n因为 ref 会在模板中自动解包，所以在表达式中引用无需 .value\n&lt;script setup&gt;import &#123; reactive, computed &#125; from &#x27;vue&#x27;;const author = reactive(&#123;    name: &quot;Zoella&quot;,    books: [&#x27;vue2&#x27;, &#x27;vue3&#x27;, &#x27;vue4&#x27;]&#125;);const hasBookPublished = computed(() =&gt; &#123;    return author.books.length &gt; 0 ? &#x27;yes&#x27; : &#x27;no&#x27;;&#125;);&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;span&gt;&#123;&#123; author.name &#125;&#125;&lt;/span&gt; has published books:     &lt;span&gt;&#123;&#123; hasBookPublished &#125;&#125;&lt;/span&gt;  &lt;/div&gt;&lt;/template&gt;\n\n计算属性缓存 VS 方法&lt;p&gt;&#123;&#123; calculateBooksMessage() &#125;&#125;&lt;/p&gt;\n\nfunction calculateBooksMessage() &#123;  return author.books.length &gt; 0 ? &#x27;yes&#x27; : &#x27;no&#x27;;&#125;\n\n计算属性比方法节省性能。\n将与上述相同的函数定义为方法，结果和计算属性相同，然而 计算属性值会基于其响应式依赖被缓存，只要author.books不变，就不会重复执行 getter 函数。但是方法总会在重渲染发生时再次执行函数。\n可写计算属性计算属性默认为只读。特殊场景下会用到“可写”的计算属性。\n&lt;script&gt;import &#123; ref, computed &#125; from &#x27;vue&#x27;;const firstName = ref(&#x27;John&#x27;);const lastName = ref(&#x27;Doe&#x27;);const fullName = computed(&#123;  // getter  get() &#123;    return firstName.value + &#x27; &#x27; + lastName.value;  &#125;,  // setter  set(newValue) &#123;    [firstName.value, lastName.value] = newValue.split(&#x27;&#x27;);  &#125;&#125;)&lt;/script&gt;\n\n当运行 fullName.value = &#39;Zoella Wang&#39; 时，setter会被调用，firstName 和 lastName 会随之更新。\n","categories":["vue3 - 文档"],"tags":["vue3","vue"]},{"title":"北大-区块链技术与应用11-课堂回答","url":"/2025/01/15/40-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-%E8%AF%BE%E5%A0%82%E5%9B%9E%E7%AD%94/","content":"略（基本没有新东西），详情可参考课程视频：\nhttps://www.bilibili.com/video/BV1Vt411X7JF?spm_id_from=333.788.videopod.episodes&amp;vd_source=69ac93649ea21c4726fe85f272b6d968&amp;p=11\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3"]},{"title":"北大-区块链技术与应用12-BTC的匿名性","url":"/2025/01/15/41-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-BTC%E5%8C%BF%E5%90%8D%E6%80%A7/","content":"一、比特币的匿名性anonimity（匿名性）、privacy（隐私性）\n比特币使用的是 pseudonymity（假名）\nExample：一个人通过自己的两个账户 addr1 和 addr2，向商家账户转账 addr3，然后把零钱转入自己的另一个账户 addr4\nInputs: addr1, addr2\nOutputs: addr3, addr4\n1、破坏比特币匿名性的方法：（1）比特币不同账户之间可以进行关联\n（2）比特币可以和实体世界相关联\n2、Silk road（丝路）Silk road 是一个非法交易平台，被称为 eBay for illegal drugs，支付手段采用比特币，底层路由采用 TOR（洋葱路由），提供匿名邮寄服务，后被封禁\n这说明比特币的匿名性并没有那么好\n3、如何提高自己比特币的匿名性？（1）Network layer采用多路由转发，比如 TOR（洋葱路由）\n（2）Application layerCoin mixing（混币交易），即把不同人的币混起来。交易所天然具有 coin mixing 的性质，前提是交易所不会泄露任何交易记录\n二、Zero-knowledge proof（零知识证明）零知识证明：指证明方向验证者证明一个陈述是正确的，而无需泄露额外的任何信息\n同态隐藏（1）不会碰撞：如果 x, y 不同，那么它们的加密函数值 E(x) 和 E(y) 也不相同，其逆否命题也成立（2）隐私性：给定 E(x) 的值，很难反推出 x 的值（3）给定 E(x) 和 E(y) 的值，我们可以很容易地计算出某些关于 x, y 的加密函数值\n同态加法：通过 E(x) 和 E(y) 计算出 E(x+y) 的值\n同态乘法：通过 E(x) 和 E(y) 计算出 E(xy) 的值\n扩展到多项式\n\n三、零币和零钞零币（zerocoin）和零钞（zerocash）融合了匿名化处理，但仍未解决与实体世界相关联导致的隐私泄露问题\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","BTC"]},{"title":"北大-区块链技术与应用13-BTC引发的思考","url":"/2025/01/15/42-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-BTC%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/","content":"一、哈希指针指针保存的是本地的内存地址，区块链中的哈希指针是如何传递的？其实区块中保存的只有哈希，没有指针（只是形象化的说法）。全节点会把区块以 (key, value) 存储在数据库（level DB）中，且只保存最近的几千个区块\n二、区块恋双方把私钥截成两段，每方保存一段不可取，有两点问题：\n\n蛮力攻击更加容易\n永久占据 UTXO，浪费资源\n\n建议采取 MULTISIG（多重签名）\n三、比特币中的稀缺性比特币的总量是确定的，这种“稀缺”的东西不适合作为货币，一个好的货币需要有通货膨胀的功能；否则随着社会财富的增加，总量一定的货币会越来越值钱，先来者躺平，后来者买不起（类比国内房地产）\n四、量子计算量子计算技术离使用还差的很远，就算有一天量子计算能够破解现有的加密体系，首先冲击的是传统金融业；并且后面还会有量子加密算法\n比特币并没有直接暴露账户的公钥，而是把公钥取哈希得到一个地址。假设量子计算使得从公钥推出私钥变为可能，比特币还有另一层防护：使用的是公钥哈希，首先需要通过地址推出公钥，而取哈希是不可逆的，因为取哈希的过程中存在信息丢失（比如任意长度的公钥都能通过 SHA-256 压缩成 256位）\n从 安全性 和 隐私保护 的角度看，比特币的一个地址一旦用过后，就不要再用了，每次从一个地址取钱时，最好把所有钱都取走，除了支付的钱，剩下的转给自己的另外一个账户\n如果担心量子计算的威胁，即使是公钥也不要随意泄露\n","categories":["Web3 - 北大肖臻-区块链技术与应用"]},{"title":"北大-区块链技术与应用14-ETH概述","url":"/2025/01/15/43-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-ETH%E6%A6%82%E8%BF%B0/","content":"比特币被称为 区块链1.0，以太坊被称为 区块链2.0\n一、以太坊和区块链的对比1、出块时间以太坊的出块时间从比特币的 10分钟 降低到了十几秒\n2、共识机制以太坊设计了新的 ghost 共识机制\n3、mining puzzle以太坊设计了新的 mining puzzle：比特币的 mining puzzle 是计算型的，比拼的是算力；而以太坊的 mining puzzle 是 memory hard，对内存的要求很高，从而限制了 ASIC 芯片的使用（ASIC resistance）\n4、证明机制以太坊用 POS（proof of stake，权益证明） 来替代 POW（proof of work，工作量证明）\n5、智能合约以太坊增加了对 smart contract（智能合约）的支持\n（1）BitCoin：decentralized currency（去中心化货币）在跨国转账方面，fiat currency（法定货币）不如比特币\n（2）Etherem：decentralized contract（去中心化协议）类似的，在跨国协议方面，去中心化协议也有优势\n6、最小单位比特币的最小单位是 Satoshi（聪）；而以太坊的货币叫做 Ether（以太），最小单位是 Wei\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","ETH"]},{"title":"北大-区块链技术与应用15-ETH的账户","url":"/2025/01/15/44-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-ETH%E8%B4%A6%E6%88%B7/","content":"一、比特币——基于交易的账本比特币用的是 transaction-based ledger（基于交易的账本），系统没有显示地记录账户的金额，需要通过 UTXO 计算，这种方式隐私性好，但不便于使用\n二、以太坊——基于账户的账本以太坊用的是 account-based ledger（基于账户的账本），转账时不需要说明币的来源\n1、好处不会出现 double spending attack（双花攻击——花钱的人不诚实）\n2、缺点需要预防 replay attack（重放攻击——收钱的人不诚实），一次交易被恶意节点广播多次\n通过增加一个计数器 nonce，用来记录某账户交易的次数，转账时交易次数要成为交易内容的一部分，都受到发布交易者签名的保护；如果发起重放攻击，交易中 nonce 的值和计数器的值相等，会被校验为不合法（合法的应该比计数器大 1）\n\n三、以太坊的账户类型1、Extranally owned account（外部账户）外部账户类似于比特币的账户，通过公私钥控制，也叫做普通账户。一个外部账户的状态有 balance（账户余额）和 nonce（计数器）\n2、Smart contract account（合约账户）合约账户不是通过公私钥对控制，不能主动发起交易（只有外部账户可以）。合约账户除了 balance（账户余额），nonce（计数器），还有 code（代码） 和 storage（状态&#x2F;存储）\n合约账户如何调用？创建合约时，会返回一个地址，知道合约的地址，就能调用合约，调用过程中状态会发生变化，但是代码是不变的\n以太坊的创始人是 Vitalik。现在有人提出用智能合约生成一些 financial derivative（金融衍生品），比如：期权、期货\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","ETH"]},{"title":"北大-区块链技术与应用16-ETH中的状态树","url":"/2025/01/15/45-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-ETH%E7%8A%B6%E6%80%81%E6%A0%91/","content":"从账户地址到账户状态的映射：addr -&gt; state\n以太坊中的账户地址是 160 bits，也就是 20字节，一般表示为 40个 16进制的数；比特币和以太坊的地址格式、长度都不同，但是以太坊中的地址也是由公钥转换来的（公钥取哈希、进行截取，并只保留后面）\n在比特币中，merkle tree 除了证明账户上有多少钱之外，还可以维护各个全节点之间状态的一致性\n以太坊的状态树结构以太坊采用的数据结构是 MPT（‌Merkle Patricia Tree，默克尔前缀树&#x2F;压缩前缀树），基于 trie（单词查找树）\n一、Trie\n1、优点（1）Trie 每个节点的分支数目，取决于 key 每个元素的取值范围，以太坊的 branching factor 是 17（0~f，加结束位）\n（2）Trie 的查找效率取决于 key 的长度，越长查找次数越多，以太坊 key 值的长度都是 40\n（3）比起 key-value 对，trie 不会出现哈希碰撞\n（4）Trie 生成的树和插入顺序无关\n（5）Trie 中的更新操作具有局部性\n2、缺点一脉单传，存储浪费空间，于是就引入了 MPT\n二、MPT\nMPT 对树的高度进行压缩，访问内存的次数减少，提高效率。路径压缩在键值分布比较稀疏的情况下，效果比较好\n以太坊中的地址是 160 bits，地址空间为 2^160，因此以太坊账户地址的键值分布非常稀疏。地址这么长的原因是防止哈希碰撞（不同公钥哈希后的值相同）\nMerkle tree 比起 binary tree，把普通指针换成哈希指针；同样的，MPT 比起 PT，也是把普通指针换成哈希指针，最后计算出根哈希值\n1、根哈希值的作用（1）防止篡改\n（2）merkle proof，证明账户余额\n（3）和 sorted merkle tree 一样，可以证明账户是否存在\n2、Modified MPT以太坊用的是 modified MPT\n\n以太坊之所以会保留历史状态，是为了便于回滚\n\n三、状态树的数据结构\n\n\n四、状态树中的状态状态树中保存的是 (key, value)，value（账户的状态）是通过 RLP（Recursive Length Prefix，递归长度前缀，特点是极简）序列化之后存储在账户中的\nProtobuf（protocol buffer）是一个做数据序列化的常用库，只支持一种类型：nested array of bytes（嵌套字节数组）\n以太坊中的所有其它类型（整数、哈希），最终都要变成嵌套字节数组，实现 RLP 比嵌套字节数组容易很多\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","ETH"]},{"title":"北大-区块链技术与应用17-ETH中的交易树和收据树","url":"/2025/01/16/46-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-ETH%E4%BA%A4%E6%98%93%E6%A0%91&%E6%94%B6%E6%8D%AE%E6%A0%91/","content":"以太坊中的交易树和收据树也是 MPT，其好处是支持查找操作，查找的键值是交易在发布的区块中的序号（即排第几），其顺序由发布交易的区块确定\n交易树和收据树都是只把当前区块发布的交易组织起来，而状态树是把系统中所有账户的状态都包含进去（原因是：便于查找账户余额，尤其是很久没发生过交易的区块，更重要的是无法找到新账户）\n上节课讲到，多个区块的状态树是共享节点的；而每个区块的交易树和收据树是独立的\n交易树和收据树的用途是：提供 Merkle proof，交易树可以证明某个交易被打包到区块里，收据树的可以证明某个交易的执行结果\n1、Bloom filter（布隆过滤器）以太坊的收据树包含一个 Bloom filter\nBloom filter 可以支持高效的查找某元素是否在某个大的集合。通过将大的集合中的元素做哈希，映射到一个小的数组，该数组元素初始全为0，最终如果有元素映射到该位置，则置为1\n用 Bloom filter 检测元素是否在某个集合中，可能会出现 false positive（假阳性），即 实际不在、但是检测结果在，但检测结果在、实际一定在。且 Bloom filter 不支持删除元素\nBloom filter 在以太坊中的用途是支持复杂查询操作，比如：找到过去10天所有 和某个智能合约有关 &#x2F; 众筹 &#x2F; 发布新币的交易\n每个交易执行后会形成一个收据，收据里包含一个 Bloom filter，记录该交易的类型、地址和其他信息。发布的区块在块头里也有一个总的 Bloom filter，是区块里所有交易 Bloom filter 的并集\n轻节点只有块头信息，可以通过 Bloom filter 过滤掉很多区块，只保留符合条件的（即可能含有该交易的）区块，然后向全节点获取进一步的信息\n以太坊的运行过程，可以看做一个 transaction-driven state machine（交易驱动的状态机），状态是所有账户的状态，交易是每次发布的区块中的交易，执行交易会驱动系统转移到下一个状态\n比特币也可以看做一个交易驱动的状态机，其状态是 UTXO\n2、交易树、收据树、叔父数组 源码有点复杂，暂时没搞明白，详见以下课程链接（从29分开始）：\nhttps://www.bilibili.com/video/BV1Vt411X7JF?spm_id_from=333.788.player.switch&amp;vd_source=69ac93649ea21c4726fe85f272b6d968&amp;p=17\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","ETH"]},{"title":"北大-区块链技术与应用18-GHOST协议","url":"/2025/01/16/47-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-GHOST%E5%8D%8F%E8%AE%AE/","content":"以太坊出块时间的显著降低，使得更容易出现分叉（甚至多个分叉），大型矿池有优势，尤其对个体矿工不公平\n因为当出现分叉时，所有个体矿工的算力是分散的，而矿池中的所有算力会集中在其挖出的区块，导致矿池挖出的区块更容易成为最长合法链，造成 mining centralization，这种情况也叫做 centralization bias（中心化带来的不成比例的优势）；再加上矿池会在网络的多个地方有接口，所以其发布的区块可能更早被其他节点收到\n一、叔父区块GHOST 协议不是以太坊发明的，是以太坊对其做了改进。核心思想是给予孤儿区块（在以太坊中叫做 uncle block，叔父区块）一定的奖励（7&#x2F;8 的出块奖励），而打包叔父区块的区块可以获得额外的 1&#x2F;32 的出块奖励（一个区块最多包含 2 个叔父区块）\n以太坊一开始的出块奖励是 5个以太币，后来改为 3个以太币，现在变为 2个以太币（和挖矿难度相关）\n\nGHOST 的这种设计有利于鼓励系统中出现分叉后及时进行合并（解决系统中的临时性分叉）\n但是可能存在矿池恶意竞争，故意不包含叔父区块\n二、Uncle reward（叔父区块的奖励）最长合法链上的后续区块，仍然能包含前面区块未打包的叔父区块，但是叔父区块距离越远，奖励越小（7&#x2F;8, 6&#x2F;8, 5&#x2F;8, 4&#x2F;8, 3&#x2F;8, 2&#x2F;8），最长不能超过六代\n\n叔父区块的定义：必须和当前区块在七代以内有共同的祖先（at most seven generations）\n设计七代以内辈分的原因是：如果不限制备份，全节点需要维护的状态就太多了；七代以内辈分 uncle reward 逐级递减的原因是：有利于鼓励出现分叉后尽早进行合并\n在比特币和以太坊中，把 block reward 叫做 static reward（静态奖励）\n在比特币中，tx fee 叫做 dynamic reward（动态奖励）；而在以太坊中，在执行区块中包含的智能合约时，可以得到 gas fee（汽油费），叔父区块是得不到汽油费的\n比特币被比喻为数字黄金，是用来储值的；以太币被比喻为石油，是用来消耗的（不太恰当，因为以太币本身不会消失）\n打包叔父区块时不应该执行叔父区块中的交易，因为叔父区块中可能存在有冲突的交易（执行完父区块的交易，再执行叔父区块的交易就会非法）；而是会通过 block header 检查叔父区块是不是一个合法发布的区块（是否符合挖矿难度要求）\n叔父区块后面的节点不能给予奖励，否则分叉攻击就变得太简单了：如果成功，可以回滚交易；不成功，也可以合并获得 uncle reward\n\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","ETH"]},{"title":"北大-区块链技术与应用19-ETH挖矿算法","url":"/2025/01/18/48-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-ETH%E6%8C%96%E7%9F%BF%E7%AE%97%E6%B3%95/","content":"Block chain is secured by mining（挖矿保障了区块链的安全性），比特币的挖矿算法是一个天然的 bug bounty（悬赏找bug），如果能找到漏洞或挖矿的捷径（shortcut）就能获取很大的利益\n很多人认为，挖矿设备的专业化 和比特币的去中心化理念是相违背的（one cpu, one vote），普通人能够参与挖矿有利于分散算力，预防 51% attack。所以后续的加密货币设计 mining puzzle 的一个理念是 ASIC resistance\n设计 ASIC resistance 的 mining puzzle 的常用做法是：增加 puzzle 对内存访问的需求，即 memory hard mining puzzle，因为 ASIC 芯片计算能力强，但是在内存访问的性能上没有很大的优势\n一、LiteCoin &amp; Scrypt一个早期的例子是 LiteCoin（莱特币），曾经是市值仅次于比特币的加密货币，其 mining puzzle 基于 scrypt\nScrypt 是一个对内存要求很高的哈希函数，设计思想是：开设一个很大的数组，按照顺序填充一些伪随机数；具体过程是：按照一个 seed 的值，运算出一个数填在第一个位置，后面每个位置都是前一个位置取哈希得到的；其特点是里面的取值是有前后依赖关系的；求解 puzzle 时，按照伪随机的顺序从数组中读取一些数（通过对当前数运算得到下一个读取顺序，模拟随机）；好处是：如果数组开得足够大，对于矿工来说就是 memory hard 的，有的矿工可能保存一部分内存区域的内容，比如只保留奇数位置的数，需要读取到偶数再算，这也叫做 time-memory trade off（时间换空间）\n其坏处是：对于轻节点验证来说也是 memory hard，不符合 difficult to solve, but easy to verify。所以其实际使用过程中，数组只有 128k，不足以对 ASIC 芯片造成遏制，但该理念对其冷启动有很大帮助（需要冷启动是因为，参与挖矿的人太少很容易遭受恶意攻击），所以莱特币现在仍然是主流货币\n莱特币的出块时间是两分半，速度是比特币的四倍，其他部分和比特币基本相同\n二、以太坊 memory hard以太坊的挖矿算法叫做 ethash，矿工挖矿需要 1G 的内存，和莱特币的 128k 比，大了 8000 多倍，光是 cashe 就大了 100 多倍；更别说现在内存要求还在增长\n以太坊使用一大一小两个数据集：16M 的 cache 和 1G 的dataset，轻节点只要保存 cache，矿工才需要保存 1G 的大数据集\n1、具体算法算法太复杂了，没完全搞明白，具体算法的伪代码可参考课程视频（28分）：\nhttps://www.bilibili.com/video/BV1Vt411X7JF?spm_id_from=333.788.player.switch&amp;vd_source=69ac93649ea21c4726fe85f272b6d968&amp;p=19\ncache 的生成方式和 scrypt 类似，但是不同于莱特币从数组中按照伪随机的顺序读取并进行运算，以太坊是需要先生成一个更大的数组（dataset 要大得多），而且 cache 和 dataset 是定期增长的，因为计算机的内存容量也在增长\ndataset 中的每个元素都是从 cache 中按照伪随机的顺序读取一些元素（和莱特币类似），一共读 256 次，用这 256 个数算出一个数，作为 dataset 的第一个元素，后续元素也一样\n求解 puzzle 时只使用 dataset 中的数，按照伪随机的顺序，从大数据集中读取 128 个数：一开始根据区块的块头、包括其中的 nonce 值，算出一个初始的哈希，然后根据该哈希映射到这个大数据集中的某个位置，将其中的数读取出来（同时将其相邻的元素读取出来），然后进行一些运算算出下一个位置，总共进行 64 次循环，共读取 128 个数。最后算出一个哈希值，和挖矿难度的目标域值比较，看是否符合要求，如果不符合，更换 nonce 之后再重新计算\n2、矿工保存 dataset 的原因由于矿工需要验证非常多的 nonce，如果每次都从 16M 的 cache 中重新生成，挖矿的效率就太低了，并且其中有大量的重复计算（因为随机选取的 dataset 的元素中有很多是重复的，可能是之前尝试别的 nonce 时用过的）。所以矿工采取空间换时间的策略，保存整个 dataset\n3、轻节点只保存 cache 的原因轻节点由于只验证一个 nonce，验证时直接生成要用到的 dataset 中的元素即可\n和比特币相比，以太坊中验证一个 nonce 的计算量要大很多，但也在可接受范围内\n目前以太坊挖矿还是以 GPU 为主，所以起到了 ASIC resistance\n三、以太坊 POS以太坊没有出现 ASIC 矿机的另一个原因是，以太坊2.0（或以太坊合并）已经于 2022年 从 POW 转向 POS（Power of Stake，权益证明），即按照所占的权益进行投票从而形成共识，而不是挖矿，类似于股份制公司按照股份多少来投票\n这对于 ASIC 厂商是很大的威胁，因为其研发周期很长（1年都算快的），并且研发成本也很高，如果后续不挖矿了，那么所有投入都白费了\n四、预挖矿以太坊采用了 pre-mining（预挖矿），在当初发行货币的时候，预留一部分货币给以太坊的开发者，类似创业公司留一部分股票给创始人和早期员工；而比特币没有采用 pre-mining 的模式，都是挖矿挖出来的\nPre-sale（预售） 就是把 pre-mining 中预留的币，通过出售的方法来换取一些资产，用于加密货币的开发工作\n但有一些人认为，让通用计算设备参与挖矿反而是不安全的，用 ASIC 芯片挖矿才是最安全的，因为购买矿机需要大量的资金，并且只能用于一种加密货币，成本较高\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","ETH"]},{"title":"北大-区块链技术与应用20-ETH挖矿难度调整","url":"/2025/01/18/49-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-ETH%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6%E8%B0%83%E6%95%B4/","content":"比特币是每隔 2016 个区块会调整挖矿难度，目标是维持出块时间在十分钟左右；以太坊是每个区块都可以修改挖矿难度\n一、难度调整公式\n基础部分的作用是维持出块时间在 15秒 左右\nε 是难度炸弹，为了以太坊从 POW 逐步过渡到 POS\n1、基础部分\nx 是难度调整的力度，为父区块的难度除以 2048，再向下取整\n一次性下调难度最多是父区块难度的 99&#x2F;2048\n\n2、难度炸弹\n二、以太坊发展的四个阶段Frontier（前沿）、Homestead（家园）、Metropolis（大都会）和 Serenity（宁静）\n其中 Metropolis 分为 两个子阶段：Byzantium（拜占庭） 和 Constantinople（君士坦丁堡），难度炸弹的回调发生在 Byzantium 阶段\nSerenity（宁静）即以太坊2.0，从 POW 转向 POS\n\nEIP（Ethereum Improvement Proposal）：以太坊改进提案\nBitCoin Improvement Proposal）：比特币改进提案\n三、具体代码实现略，没特别明白，可以参考课程视频（20分）：\nhttps://www.bilibili.com/video/BV1Vt411X7JF?spm_id_from=333.788.player.switch&amp;vd_source=69ac93649ea21c4726fe85f272b6d968&amp;p=20\n比特币中讲过最长合法链，而对于以太坊来说是最难合法链\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","ETH"]},{"title":"为什么 vue 组件添加 scoped 后，某些组件样式不生效","url":"/2023/11/14/5-%E4%B8%BA%E4%BB%80%E4%B9%88vue%E7%BB%84%E4%BB%B6%E6%B7%BB%E5%8A%A0scoped%E5%90%8E%E6%9F%90%E4%BA%9B%E7%BB%84%E4%BB%B6%E6%A0%B7%E5%BC%8F%E4%B8%8D%E7%94%9F%E6%95%88/","content":"简述在父组件中修改子组件的某些样式，发现不生效，删去&lt;style scoped&gt;&lt;/style&gt;中的 scoped 后生效。\n原因scoped 实现样式隔离的原理为：\n编译时，父组件的所有标签、子组件的根标签、以及所有的样式 都会加上特殊的标识；\n因为子组件内部的标签都没有此种标识，所以样式就不会生效。\n实例不添加 scoped&lt;!-- 父组件 --&gt;&lt;template&gt;  &lt;div class=&quot;parent&quot;&gt;    &lt;p&gt;Here is parent component&lt;/p&gt;    &lt;TestScoped /&gt;    &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.parent &#123;  color: deepskyblue;&#125;&lt;/style&gt;\n\n&lt;!-- 子组件 --&gt;&lt;template&gt;  &lt;div class=&quot;son&quot;&gt;    &lt;p&gt;Here is son component&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;\n\n编译后：\n&lt;div class=&quot;parent&quot;&gt;    &lt;p&gt;Here is parent component&lt;/p&gt;    &lt;div class=&quot;son&quot;&gt;        &lt;p&gt;Here is son component&lt;/p&gt;    &lt;/div&gt;&lt;/div&gt;\n\np &#123;  color: deepskyblue;&#125;\n\n添加 scoped编译后：\n&lt;div data-v-7ba5bd90 class=&quot;parent&quot;&gt;    &lt;p data-v-7ba5bd90&gt;Here is parent component&lt;/p&gt;    &lt;div data-v-7ba5bd90 class=&quot;son&quot;&gt;        &lt;!-- 没有标识，所以不生效 --&gt;        &lt;p&gt;Here is son component&lt;/p&gt;    &lt;/div&gt;&lt;/div&gt;\n\np[data-v-7ba5bd90] &#123;    color: deepskyblue;&#125;\n\n解决方法深度作用选择器使用 &#x2F;deep&#x2F; 或者 ::v-deep\n/deep/ p &#123;  color: deepskyblue;&#125;/* 或者 */::v-deep p &#123;  color: deepskyblue;&#125;\n\n编译后：\nhtml 结果不变，样式代码变化\n[data-v-7ba5bd90] p &#123;  color: deepskyblue;&#125;\n\n使用无 scoped 的 style&lt;style scoped&gt;p &#123;  color: deepskyblue;&#125;&lt;/style&gt;&lt;style&gt;/* 生效样式代码 */&lt;/style&gt;\n","categories":["vue - 样式"],"tags":["vue","实践问题"]},{"title":"北大-区块链技术与应用21-权益证明","url":"/2025/01/19/50-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-POS/","content":"POW（Proof of work，工作量证明）受到的普遍批评是浪费电\n以太坊交易的能耗比比特币低，是因为出块时间更短\n一、POS 基本思想POS（Proof of Stake，权益证明）的基本思想是：按照每个人投入资金的多少来决定收益的分配，这也叫做 virtual mining（虚拟挖矿）\n采用权益证明的货币，在发行前一般会预留一部分货币给开发者，也会出售一部分货币来换取开发所需的资金。将来按照的权益证明的共识机制，按照每个人持有货币的数量进行投票\n二、POS 的好处（1）省去了挖矿的过程，也避免了由此带来的能耗和对环境的影响\n（2）如果有人想发动恶意攻击，需要设法获得该币种一半以上的份额，即发动攻击的资源只能从加密系统内部获得，形成一个闭环。如果有人在初期大量买入，币价大涨，早期投资者可能会跑卖出路（类似于股份制公司遭受恶意收购）\n基于 POW 的共识系统，从某种意义上来说，维护区块链安全的资源不是一个闭环，因为 Block chain is secured by mining. 而 mining 所需的 equipment 是由法币买来的（即加密货币的生态系统之外得到的），这就带来一个问题：虽然加密货币的总市值有了很大的增长，但是和世界经济总量相比仍然是微乎其微的，也就是说发动 51% attack 攻击的资源可以从外界得到、并且是有可能达到的，尤其对于刚发行的小的币种 AltCoin（Alternative coin），这叫做 AltCoin Infanticide（杀婴）\n有些加密货币采用的是一种混合模型，即仍然需要挖矿，但是挖矿难度和占有权益（持有币的数量）相关。这样会导致，系统中持有币数量最多的人，每次挖矿都最容易，所以有些加密货币要求，投入的币会被锁定一段时间，不能重复使用（比如：挖矿时投入一些币降低挖矿难度，等区块发布出来后，投入的币就会被锁定一段时间，下次再挖就不能用了，过一定区块才能继续用），这叫做 Proof of Deposit（存款证明）\n三、早期 POS 遭遇的问题Nothing at stake（两边下注）：参与者通过持有并锁定一定数量的加密货币、而不需要消耗资源（如算力）来生成区块，因此可以同时支持多个分叉上的区块而没有损失\n四、Casper 协议Casper 是以太坊采用的 POS 协议\nCasper the Friendly Finality Gadget（CFG，Casper 友好的最终性工具）：在过渡阶段，需要和工作量证明混合使用，为工作量证明提供 finality，它是一种最终的状态，包含在其中的交易不会被取消\n单纯基于挖矿的交易时可能被回滚的，比如某个交易被写入区块链里，但是有人从前面的区块开始分叉，挖出一条更长的分叉链\nCasper 引入了 validator（验证者）的概念，validator 必须投入一定数量的以太币作为保证金，保证金会被锁定。Validator 的作用是推动系统达成共识，投票决定哪条链是最长合法链，投票权重取决于保证金的数目大小\n具体做法类似于数据库中的 two-phase commit（两阶段提交），第一阶段是 prepare message，第二阶段是 commit message\n每挖出 100个 区块，就作为一个 epoch（纪元），要决定其能否成为 finality 需要进行投票，Casper 规定每一轮投票都要得到 2&#x2F;3 以上验证者（按照保证金金额大小）同意才能通过\n\n实际系统中不区分 prepare message 和 commit message，而且把 epoch 从原来的 100个 区块，减少到了 50个 区块就作为一个 epoch，每个 epoch 只需要一轮投票，投票结果对于上一个区块是 commit message，对于下一个区块是 prepare message，需要连续两轮投票（2个 epoch）都得到 2&#x2F;3 以上的通过，才算有效\n\n验证者参与该过程的好处是，如果其履行职责，可以得到相应的奖励；相反，如果验证者有不良行为被发现，会受到相应的处罚，比如：该投票时不投票，导致系统迟迟无法达成共识，这种情况会扣除其一部分保证金；比如乱投票，给两个有冲突的分叉都投票（两边下注），这种情况会没收其所有保证金（所有扣除或没收都是销毁的模式）\n每个验证者有一定的任期，任期满后会有一个等待期，该等待期是为了让其他节点检举或揭发其是否有不良行为。如果等待期过了，验证者就可以取回当初的保证金和应得的奖励\n五、关于 Casper 的思考Casper 在挖矿的过程中，对其状态做一个 check point（检查点），这是否安全；或者说通过验证者投票达成的 finality 是否可能被推翻？\n假设某个有恶意的组织想发动攻击，如果组织仅仅是矿工，那么就无法推翻已经达成的 finality，因为它是验证者投票的结果；如果组织是验证者，由于需要连续两轮投票都得到 2&#x2F;3 以上的通过才算有效，那么至少有 1&#x2F;3 的验证者两边下注了：正常链得到至少 2&#x2F;3 的票数，非法链也得到至少 2&#x2F;3 的票数，那么至少一共是 2&#x2F;3+2&#x2F;3&#x3D;4&#x2F;3 的票数，即至少 4&#x2F;3-1&#x3D;1&#x2F;3 的验证者都参与了两条链的投票。这 1&#x2F;3 的验证者被发现后，会被没收所有的保证金\nEOS 加密货币（俗称柚子），采用的是 DPOS（Delegated Proof of Stake）协议，先用投票的方式选出 21个 超级节点，再由这些超级节点产生区块，现在已经凉了\n六、POW 的争论很多人认为 POW 挖矿的好处是，提供了把多余电能转化为钱的一种手段，可以有效地化解过剩产能，带动当地经济的发展。因为电能是很难存储、很难传输的，很多大型数据中心要建在电比较便宜的地方，就是因为传输数据比传输电容易，很多比特币的矿场都是建在电力资源丰富的地方\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","ETH","POS"]},{"title":"北大-区块链技术与应用22-智能合约","url":"/2025/01/19/51-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/","content":"一、智能合约概念Smart contract（智能合约）是运行在区块链上的一段代码，代码的逻辑定义了合约的内容\n智能合约的账户保存了合约当前的运行状态\n\nbalance 当前余额\nnonce 交易次数\ncode 合约代码\nstorage 存储，数据结构是一颗 MPT\n\nSodility 是智能合约最常用的语言，语法上与 JavaScript 很接近\n二、Sodility 数据结构\n其中，bid() 后面的 payable 说明该合约账户能接受外部转账。该函数是用来进行竞拍出价的，在出价时需要把以太币发送并存储到合约里，锁定到拍卖结束，因此该函数需要有能接受外部转账的能力\nwithdraw() 函数是在拍卖结束后，未中标的账户可调用该函数，把出价时锁定在智能合约中的以太币取回来\n三、智能合约调用1、一个账户调用一个智能合约外部账户调用智能合约，和转账类似：假设 A 发起一个交易转账给 B，如果 B 是普通用户，则为普通交易；如果 B 是合约账户，那么该调用实际是对 B 合约的调用，具体调用函数是在 data 域中进行说明\n2、一个合约调用另一个合约以太坊中规定，一个交易只有外部账户才能发起，一个合约账户不能主动发起交易。所以在实际中，有两种调用方式\n（1）直接调用通过一个普通账户调用合约 B 中的函数，然后这个函数再调用合约 A 中的函数\n\n（2）使用 address 类型的 call() 函数这种调用和上述不同的是：对于错误处理的不同。在直接调用中，如果被调用的合约执行发生错误，会导致发起调用的合约也跟着一起回滚；而 addr.call() 的方法，如果被调用的合约发生异常，addr.call() 会返回 flase，但发起调用的合约不会抛出异常，而是会继续执行\n\n（3）代理使用 delegatecall()和 call() 很像，区别是 delegatecall() 不需要切换到被调用的合约的环境中去执行，而是在当前合约的环境中执行\n\n3、fallback() 函数\nA 调用 B 的合约，要在转账交易里的 data 域说明调用的是 B 中的哪个函数。如果 A 给合约 B 转了一笔钱，没有说明掉的是哪个函数（或者调的函数在 data 域中不存在），此时缺省就调用 fallback() 函数\n在交易中，转账金额可以为 0，但是汽油费不能为 0，因为没有汽油费，发布该区块的矿工就不会将该笔交易打包进去\n四、智能合约的创建和运行智能合约是由某个外部账户发起一个转账交易，转给 0X0 地址，转账金额为 0，然后把要发布的合约的代码放到 data 域里\n\nJVM 的目的是增强可移植性，EVM 也是类似的思想，通过加一层虚拟机，对智能合约的运行提供一个一致性的平台，所以 EVM 有时叫做 world wide computer，EVM 的寻址空间非常大，为 256 位\n五、汽油费比特币的设计理念很简单，功能有限（比如不支持循环）；而以太坊需要提供一个 Turing-complete Programming Model（图灵完备的编程模型），包含条件控制、循环和递归、数据存储、基本的算术运算功能，但也可能带来问题，比如出现死循环\n一个全节点收到一个对智能合约的调用，不知道该调用执行起来是否会导致死循环，这叫做 Halting Problem（停机问题），这个问题是不可解的，不是 NPC 问题（Non-deterministic Polynomial 的问题，即多项式复杂程度的非确定性问题，NPC 是可解的，只是没有多项式时间的解法）\n以太坊引入了汽油费机制，发起一个对智能合约的调用，就要支付相应的汽油费\n\n当一个全节点收到一个对智能合约的调用时，先按照调用中给出的 gasLimit，算出可能花掉的最大汽油费，然后一次性把汽油费从发起调用的账户上扣除，然后再根据实际执行的情况，算出实际花了多少汽油费（多退）\n不同的指令消耗的汽油费不同，简单的指令（比如加减法），消耗的汽油费是很少的，复杂的指令消耗的汽油费就比较多（比如取哈希）；除了计算量，需要存储状态的指令消耗的汽油费也比较大；只需读取公共指令的命令是免费的\n六、错误处理以太坊中的交易执行起来具有原子性，一个交易要么全部执行、要么完全不执行，不会只执行一部分，既包含普通的转账交易，也包含对智能合约的调用。所以如果在执行智能合约的过程中，出现任何错误，会导致整个交易的执行回滚，退回到开始执行前的状态\n1、出现错误的情况（1）交易执行结束后，没有达到当初的 gas limit，多余的汽油费会被退回到这个账户里；相反的，如果执行一半，gas limit 已经都用完了，这时合约的执行会退回到开始执行之前的状态，且已经消耗掉的汽油费是不退的\n（2）抛出错误的语句 assert（通常判断内部条件），require（通常判断外部条件，比如函数输入是否符合要求），revert（无条件抛出异常，原来是 throw）。sodility 当中没有 try catch 这种结构\n2、嵌套调用如果嵌套调用，一个智能合约调用另外一个智能合约，被调用的智能合约出现错误，不一定会导致发起调用的智能合约也跟着一起回滚，即连锁式回滚\n这取决于调用智能合约的方式，如果这个智能合约是直接调用，就会触发连锁式回滚；如果用 call() 的方式，就不会连锁回滚，而是返回一个 false\n如果只是向一个账户里转账，但该账户为合约账户，该操作就有可能触发对函数的调用，因为如果没有指明哪个函数，仍会调用 fallback() 函数\n七、Block headergasUsed 是该区块里所有交易所消耗的汽油费的总和\n发布区块需要消耗一定的资源，需要对消耗的资源有一个限制（类似比特币区块大小不能超过一兆），gasLimit 是该区块里所有交易实际能够消耗汽油的上限\n比特币区块一兆大小的限制是固定的，但是以太坊的 gasLimit 也有一个上限，但是每个矿工发布区块时，可以对 gasLimit 进行微调，即在上一个区块 gasLimit 的基础上 上调或下调 1&#x2F;1024\n八、思考1、先挖矿还是先执行前置知识：任何对状态的修改，都是在改本地的数据结构，只有当合约执行完了，发布到区块链之后，这些本地的修改才会变成外部可见的、变成区块链上的共识\n假设某个全节点要打包一些交易到一个区块里，这些交易里有一些是对智能合约的调用，那么全节点是先把这些智能合约都执行完再去挖矿，还是应该先挖矿、获得记账权之后，再执行合约？\n答案是先执行智能合约，因为不先执行，更新三颗树（状态、交易、收据），就无法得到三颗树的根哈希，也就无法通过 block header 去挖矿\n2、是否会存在故意不验证的全节点汽油费的设置是对于矿工执行智能合约所消耗资源的一种补偿，但是这种补偿只有最终挖到矿的矿工才能得到\n如果某个区块不验证新发布的交易，不去执行新发布的区块，也就没办法更新本地的三棵树，以后就没办法再发布区块\n3、合约执行错误能否上链如果智能合约执行的过程中出现了错误，也要发布到区块链上，否则汽油费扣不掉。也就是说发布到区块链上的交易不一定都是成功执行的\n4、智能合约是否支持多线程多核处理器很普遍，但是智能合约不支持多核并行处理，sodility 没有支持多线程的语句，原因是：以太坊是一个交易驱动的状态机，状态机必须是完全确认性的，给定同一组输入，产生的输出&#x2F;转移到的下一个状态必须是完全确定的。因为所有的全节点都得执行同一组操作，达到同一个状态，如果不确定的话，三个树的根哈希值根本对不上。多线程的问题是多个核对内存访问顺序不同的话，执行结果有可能不确定\n除了多线程之外，其他可能造成执行结果不确定的操作也都不支持，比如：产生随机数，所以以太坊中的智能合约没办法产生真正意义下的随机数，只能用伪随机数\n九、收据树下面是 Receipt 的数据结构：\n\n每个交易执行完之后会形成一个收据，status 表示交易的执行情况\n十、智能合约可以获得的信息1、智能合约可以获得的区块信息\n2、智能合约可以获得的调用信息\nmsg.data 说明了调用哪个函数，和该函数的参数取值\nmsg.gas 是剩余的汽油费，决定了还能做那些操作，想要再调用其他合约，前提是有足够的汽油费剩余\nmsg.sig 是 msg.data 的前四个字节，即函数标识符，表示调用的是哪个函数\nnow 是当前区块的时间戳，等同于图区块信息中的 block.timestamp\n消息发送者 msg.sender 和 交易发起者 tx.origin 是不一样的\n\n比如上述交易，对于 f2，msg.sender 是 C1，但是 tx.origin 是 A\n3、地址类型\naddr.balance 是成员变量，剩余的都是成员函数\naddr.transfer(amount) 是当前合约往地址 addr 转入 amount 以太币，转入的地址是 addr，转出的地址是该合约地址\naddr.call() 合约账户发起对 addr 这个合约的调用\n4、三种发送 ETH 的方式addr.transfer(amount)addr.send(amount) return (bool)addr.call.value(amount)()\n\n（1）transfer 会导致连锁性的回滚；失败时抛出异常；为要调用的合约提供 2300 汽油费（少量）\n（2）send 在失败时会返回一个 false；不会导致连锁式回滚；为要调用的合约提供 2300 汽油费（少量）\n（3）call 在失败时会返回一个 false；不会导致连锁式回滚；会将当前调用剩下的所有汽油都发送给要调用的合约，合约后续会执行什么操作当前账户无法控制\n十一、智能合约拍卖实例这部分结合智能合约拍卖实例，讲述可能存在的安全漏洞（比如重组攻击），代码截图较多，视频链接如下（1小时31分25秒）：\nhttps://www.bilibili.com/video/BV1Vt411X7JF/?spm_id_from=333.788.player.switch&amp;vd_source=69ac93649ea21c4726fe85f272b6d968&amp;p=22\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","ETH","智能合约"]},{"title":"北大-区块链技术与应用23-The DAO","url":"/2025/01/21/52-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-The%20DAO/","content":"\nDAO（Decentralized Autonomous Organization）\nDAC（Decentralized Autonomous Corporation）\n\nThe DAO 事件是以太坊历史上一个重要的里程碑，涉及到智能合约的漏洞、重组攻击、以及随后的硬分叉。这一事件导致以太坊网络分裂成了两个不同的区块链：以太坊（ETH）和以太坊经典（ETC）\n1、背景The DAO 是一个基于以太坊的去中心化投资基金，旨在为各种项目提供资金，在 2016年4月 成功筹集了超过 1.5亿美元 的以太币，成为当时最大的众筹项目。然而，其智能合约存在一个安全漏洞，并终导致了黑客的攻击\n拆分（splitDAO），用于建立子基金（childDAO），一般用于小众项目，会将这些账户中的代币全部换回以太币、并打入子基金中。极端情况下，单个投资者可以成立一个子基金，用于取回个人的收益（注意：成立的子基金具有 28天 的锁定期）\n2、漏洞与重组攻击有问题的代码段如下所示：\n\n正确的操作顺序是先把账户清零 balance[msg.sender]=0，然后再把钱还给调用该函数的人 withdrawRewardFor(msg.sender)，并对 The DAO 中的总金额减少相应的数量 totalSupply -= balances[msg.sender]\n攻击者利用该漏洞进行了重组攻击，通过递归调用（Reentrancy）的机制，在第一次调用合约未完成之前 再次调用原合约，从而重复提取资金，导致约 5000万美元 被转移到攻击者的合约账户中\n3、尝试修复：软分叉在 28天 的锁定期内尝试修复，第一步锁定黑客的账户，第二步清退 The DAO 基金上的钱\n以太坊发布了软件升级，新增了一条规则：凡是和 The DAO 基金上的账户相关的，不许做任何交易。大多数矿工都升级了该软件\n这属于软分叉，因为新节点不认（包含和 The DAO 基金账户相关的交易）旧节点，而旧节点认可新节点\n但是升级后的软件存在另一个 bug：判断和 The DAO 基金上的账户相关的交易都是非法交易，不予执行，此时没有收取汽油费。这导致了 Denial-of-service Attack（DOS 攻击）：造成大量恶意攻击者不断发放非法交易，浪费矿工的资源\n4、硬分叉的实施以太坊发布了软件升级，把 The DAO 上的所有基金强行转到另一个新的智能合约上，该智能合约的唯一功能就是退钱（将代币退回为以太币）\n这属于硬分叉，因为本来转账需要有合法的签名，但是用该合约规定，挖到第 192万 个区块时，自动执行该转账交易，不需要任何签名。因此旧矿工不会认可该区块，因为没有合法签名属于非法交易\n5、分裂成 ETH 和 ETC硬分叉之后的新链仍然称作 ETH，旧链上挖出的币叫做 ETC（Etherum Classic）\n后来由于新旧链并行会引发重放攻击，在两条链上分别加上了不同的 Chain ID 用于区分\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","ETH","智能合约"]},{"title":"北大-区块链技术与应用24-反思","url":"/2025/01/21/53-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%8F%8D%E6%80%9D/","content":"一、智能合约Is smart contract really smart?\nSmart contract is anything but smart.\n有人认为应该把智能合约叫做自动合约，ATM 就是一种自动合约，实际上来说，智能合约是一种代码合同\n二、不可篡改性Irrevocability is a double edged sword（区块链的不可篡改性是一把双刃剑）\n三、真的不可篡改不存在Nothing is irrevocable.\n四、Sodility 语言Is sodility the right programming language?\n有人建议使用函数式编程语言，杜绝 fallback() 函数的问题\n五、开源Many eyeball fallacy（错误认识），表示开源代码仍然存在安全漏洞\n六、去中心化What does decentralization mean?\n以太坊的硬分叉能够实现，不是因为团队强迫，而是因为绝大多数矿工升级了软件；并且还有少部分矿工留在旧链，这也是他们的自由\n所以去中心化不是全自动化，也不是说制定的规则不能修改，而是说对规则的修改要用去中心化的方法来完成，在区块链的世界里是用挖矿进行投票\n七、分叉分叉不一定是坏事，分叉是去中心化和民主的一种体现\n八、decentralized ≠ distributed\n一个去中心化的系统一定是分布式的，但是分布式的系统不一定是去中心化的，比如：Google 的 search engine 背后有几十万台服务器。在一个分布式的平台上，可以运行中心化的应用，也可以运行去中心化的应用\n比特币和以太坊都是交易驱动的状态机（state machine），其特点是，让系统中几千台机器重复做同一套动作、付出很大的代价，来维持状态的一致性\n这并不是分布式系统常用的工作模式，大多数分布式系统是让每台机器做不同的事情，再把各台机器的工作结果汇总、得到最后的结果，目的是使处理速度更快\n而 state machine 的目的不是为了处理速度快，而是为了容错。状态机最早的应用场景是 mission critical application（关键任务应用，比如：airtraffic control, stock exchange, space shuttle），代价是效率很低\n不要把以太坊上的智能合约、EVM 平台 当作是大规模计算或存储的服务，这么做不仅速度很慢，而且汽油费很贵。智能合约是编写控制逻辑的，只有那些需要在互不信任的实体中间建立共识的操作，才需要写在智能合约里\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","ETH","智能合约"]},{"title":"北大-区块链技术与应用25-美链","url":"/2025/01/21/54-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-%E7%BE%8E%E9%93%BE/","content":"BeautyChain（美链）\nIPO（Initial Public Offering）\nICO（Initial Coin Offering，首次发行的货币），它们没有自己的区块链，而是以智能合约的形式运行在以太坊的 EVM 平台上。以太坊平台的出现，为各种代币的发行提供了很大的方便\n发行代币的智能合约对应的是以太坊状态树中的一个节点，该节点有其账户余额，相当于该智能合约一共有多少个以太币；该账户中有多少代币，保存为智能合约账户的存储树上的变量，账户中代币的发行、转让、销毁都是通过调用智能合约中的函数实现的。它不像以太坊那样需要通过挖矿来维护一个底层的基础链，每种代币可以制定自己的发行规则\nERC 20（Ethereum Request for Comments，以太坊征求意见）是以太坊上发行代币的一个标准，规范了所有发行代币的合约应该实现的功能和遵循的接口\n美链被攻击的示例，告诉我们：在计算时，一定要考虑溢出的问题，sodility 有一个专门的 safeMath 库，计算时会检测是否溢出\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","ETH"]},{"title":"北大-区块链技术与应用26-课程总结","url":"/2025/01/22/55-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/","content":"Information can flow freely on the Internet, but payment cannot.\nSoftware is eating the world.\nDemocracy is the worst form of Government except for all those other forms that have been tried from time to time.\nDecentralization isn’t always a good thing.\nIf the business model is bad, it’s still bad on the Internet.\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","ETH"]},{"title":"React1","url":"/2025/01/22/56-React1/","content":"一、项目的创建1、创建方式（1）使用官方的脚手架npx create-react-app &lt;projectname&gt;\n\n只做 React 基本的搭建和构建，没有路由和状态管理，项目使用 Webpack 构建\n（2）使用一些市场上的集成脚手架官方脚手架提供的项目模板非常简单，因此也有很多集成的脚手架，比如：umi\n这类脚手架创建的项目会集成很多功能，比如：路由、mock\n2、两个核心库（1）React创建一个 React 对象，提供 React 的各个功能\n（2）React-dom提供一些 DOM 操作方法，用于把 React 创建出来的 React 对象 挂载到真正的 html DOM 中，或者从 HTML DOM 中卸载，作用类似于 Vue 的 mount\n二、React 组件 和 JSX1、组件分类（1）函数组件function Hello() &#123;    return &lt;div&gt;hello&lt;/div&gt;&#125;\n\nclass 组件（老版本）class Hello extends React.Component &#123;    render () &#123;        return &lt;div&gt;hello&lt;/div&gt;    &#125;&#125;\n\n2、JSX 特点（1）直接在 JS 中混用React 项目利用 Babel 做了对 JS 的编译，所以能直接在 JS 里写 JSX\n（2）写法接近 JSJSX 几乎和 JS 一样，不同点在于，可以在 JS 里写 HTML，且写在 JS 里的 HTML 最后会被编译成一个 JS 对象，也可以用 React 自带 createElement 创建这个对象\nfunction FnHello() &#123;  // return &lt;div&gt;hello&lt;/div&gt;  return React.createElement(&quot;div&quot;, [], &quot;Hello&quot;)&#125;\n\n3、JSX 里面渲染不同内容的区别（1）字符串、数字：直接渲染\n（2）对象：只能渲染 element 对象，否则会报错\n（3）数组：把数组中的每一项单独渲染\n（4）表达式：运行表达式\n（5）方法：无法渲染\n（6）布尔值，undifined, null：不渲染\nimport React from &#x27;react&#x27;;function App() &#123;  // 新版本 - vue3 组合式 API  // 首字母一定要大写，区分组件和方法  function FnHello() &#123;    // return &lt;div&gt;hello&lt;/div&gt;    return React.createElement(&quot;div&quot;, [], &quot;Hello&quot;)  &#125;  // 老版本 - vue2 选项式 API  class ClassHello extends React.Component &#123;    constructor(props) &#123;      super(props)    &#125;    render() &#123;      return &lt;div&gt;hello class&lt;/div&gt;    &#125;  &#125;  console.log(&quot;FnHello&quot;, FnHello) // 方法  console.log(&quot;&lt;FnHello/&gt;&quot;, &lt;FnHello/&gt;) // React element（虚拟 DOM）    let eleObj = FnHello()  let com1 = &lt;ClassHello&gt;&lt;/ClassHello&gt;    let obj = &#123; a: 123 &#125;  let arr = [com1, 5, &#x27;abc&#x27;]  return (    &lt;div className=&quot;App&quot;&gt;      &lt;FnHello&gt;&lt;/FnHello&gt;      &lt;ClassHello&gt;&lt;/ClassHello&gt;      -------      &#123;eleObj&#125;      &#123;com1&#125;      -------      &#123;&quot;Hello Str&quot;&#125;      &#123;123&#125;      &#123;/* &#123;obj&#125; 报错 */&#125;      &#123;/* &#123;FnHello&#125; 报错 */&#125;      &#123;arr&#125;      &#123;1+2+3+4&#125;      &#123;true?&lt;FnHello&gt;&lt;/FnHello&gt;:&#x27;123&#x27;&#125;      &#123;/* &#123;false&#125; 不展示 */&#125;      &#123;/* &#123;undefined&#125; 不展示 */&#125;      &#123;/* &#123;null&#125; 不展示 */&#125;    &lt;/div&gt;  );&#125;export default App;\n\n三、React 的时事件绑定1、规则模式（1）类似于原生，on+方法名（首字母大写，为了和原生区分）\n（2）一定要赋值给事件一个方法\n2、特别注意的问题（1）不作处理的情况下，this 会指向 undefined\n（2）事件绑定的必须是一个方法，不要直接调用方法，否则只会在页面初次渲染时执行\n3、事件绑定其他操作（1）传递参数\n（2）获取事件对象\n（3）阻止默认行为，冒泡等\nimport React from &#x27;react&#x27;;class App extends React.Component &#123;  /**   * 1、方法调用使用 bind 规定 this（可以）   * 2、写成一个匿名箭头函数   * 3、方法本身写成箭头函数（可以）   */  f1() &#123;    console.log(&quot;this&quot;, this) // 不用 bind 的话，默认指向 undefined  &#125;  f2 = () =&gt; &#123;    console.log(&quot;this&quot;, this) // 使用箭头函数  &#125;  f3(a, b) &#123;    console.log(&quot;a + b =&quot;, a + b)  &#125;  f4 = (a, b) =&gt; &#123;    console.log(&quot;a + b =&quot;, a + b)  &#125;  f5(a) &#123;    console.log(&quot;a&quot;, a)  &#125;  f6(a, b, e) &#123;    // 不是原生的事件对象（在 nativeEvent 中），而是合成的事件对象    console.log(&quot;e&quot;, e)    /**     *     event.stopPropagation(); // 原生阻止冒泡     *     event.preventDefault(); // 原生阻止默认     */    e.stopPropagation(); // 阻止冒泡    e.preventDefault(); // 阻止默认  &#125;  render() &#123;    return &lt;div className=&quot;App&quot;&gt;      &lt;div onClick=&#123;() =&gt; &#123;        console.log(1)      &#125;&#125;&gt;123&lt;/div&gt;      &lt;div onClick=&#123;this.f1.bind(this)&#125;&gt;456&lt;/div&gt;      &lt;div onClick=&#123;this.f2&#125;&gt;789&lt;/div&gt;      &#123;/* 不能传方法的调用 */&#125;      &lt;div onClick=&#123;this.f2()&#125;&gt;error&lt;/div&gt;      &#123;/* 箭头函数改变 this 指向 */&#125;      &lt;div onClick=&#123;() =&gt; &#123;        console.log(&quot;this&quot;, this)      &#125;&#125;&gt;匿名1&lt;/div&gt;            &#123;/* 普通函数不行 */&#125;      &lt;div onClick=&#123;function () &#123;        console.log(&quot;this&quot;, this)      &#125;&#125;&gt;匿名2&lt;/div&gt;      &#123;/* 事件传参 */&#125;      &#123;/* 1、普通函数.bind() + 普通函数 */&#125;      &lt;div onClick=&#123;this.f3.bind(this, 1, 2)&#125;&gt;传参1&lt;/div&gt;      &#123;/* 2、箭头函数 + 箭头函数 */&#125;      &lt;div onClick=&#123;() =&gt; this.f4(1, 2)&#125;&gt;传参2&lt;/div&gt;      &#123;/* 获取事件对象 */&#125;      &#123;/* 1、不传参 */&#125;      &lt;div onClick=&#123;this.f5.bind(this)&#125;&gt;事件1&lt;/div&gt;      &#123;/* 2、传参 */&#125;      &lt;div onClick=&#123;this.f6.bind(this, 1, 2)&#125;&gt;事件2&lt;/div&gt;    &lt;/div&gt;  &#125;&#125;export default App;\n\n四、React 中的响应式数据1、类组件响应式数据响应式数据定义在类的 state 属性中\nclass ClassState extends React.Component &#123;    constructor(props) &#123;        super(props)        this.state = &#123;            // 这里写响应式数据，类似 vue 的 data 方法返回的对象            a: 123        &#125;    &#125;&#125;\n\n2、React 响应式原理（1）React 不能像 Vue 一样直接修改触发更新\n（2）React 修改能改值，但无法触发更新，因为 React 不像 Vue 监听了 get 和 set，而是在调用 setState 时调用 React 的更新操作\n3、setState 关键点（1）通过浅合并来修改数据\n（2）调用 setState 方法会触发更新，修改 state 不会触发更新\n（3）setState 方法是异步的，如果要获取修改后的值，需要在 setState 的第二个参数里获取\n（4）setState 方法多次修改，会合并为一次，统一更新\n（5）setState 返回会触发更新，不管是否有修改，这导致：重复修改为相同的值也会让组件更新\n（6）一定不要在 render 里直接 setState\n4、PureComponent 下对于对象和数组的修改PureComponent 会根据 state 是否改变来决定是否更新，而对于对象、数组这种引用类型判断是否改变的原理是看内存地址，而不是内容\n因此在 PureComponent 下修改对象和数组，需要声明一个新对象赋值。所以一般不直接操作原对象，而是先拷贝一份，再进行操作\nimport React from &#x27;react&#x27;;// 解决了普通 component 的一些问题，比如：更新为同一个值仍然重新渲染class App extends React.PureComponent &#123;  // 老写法  // constructor(props) &#123;  //   super(props)  //   this.state = &#123;  //     ...  //   &#125;  // &#125;  // 新写法  state = &#123;    a: 0,    b: 1,    c: &#123;      c1: 123,      c2: 999    &#125;,    arr: [1, 2, 3]  &#125;  addA = () =&gt; &#123;    // 常用    this.setState(&#123;      a: this.state.a + 1    &#125;)    // 也可以更新    // this.state.a += 1    // this.setState(&#123;&#125;)    // 函数形式，不常用    // this.setState((state) =&gt; &#123;    //   return &#123;    //     a: state.a + 1    //   &#125;    // &#125;)    this.setState(&#123;      a: this.state.a + 1    &#125;)    console.log(&quot;this.state.a&quot;, this.state.a)  &#125;  merge = () =&gt; &#123;    // 浅合并，只合并外层    // 为异步操作    this.setState(&#123;      a: 1,      b: 2,      c: &#123;        ...this.state.c,        c1: 9      &#125;    &#125;, () =&gt; &#123;      // 回调中才能获取更新后的值      console.log(&quot;this.state0&quot;, this.state)    &#125;)    console.log(&quot;this.state1&quot;, this.state)  &#125;  refresh = () =&gt; &#123;    this.setState(&#123;      a: 1    &#125;)    this.setState(&#123;      b: 2    &#125;)    // 以上等同于    // Object.assign(this.state, &#123;a: 1&#125;, &#123;b: 2&#125;)  &#125;  // 数组和对象，是通过内存地址判断是否改变的  addArr = () =&gt; &#123;    let arr_ = [...this.state.arr]    arr_.push(4)    this.setState(&#123;      // arr: this.state.arr      arr: arr_    &#125;, () =&gt; &#123;      console.log(&quot;this.state.arr&quot;, this.state.arr)    &#125;)    this.setState(&#123;      c: &#123;        ...this.state.c,        c1: 8888      &#125;    &#125;, () =&gt; &#123;      console.log(&quot;this.state.c&quot;, this.state.c)    &#125;)  &#125;  render() &#123;    console.log(123)    // 不能在 render 中使用 this.setState，会死循环    return &lt;div className=&quot;App&quot;&gt;      &#123;this.state.a&#125;      &lt;button onClick=&#123;() =&gt; this.addA()&#125;&gt;加1&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; this.merge()&#125;&gt;合并&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; this.refresh()&#125;&gt;更新&lt;/button&gt;      &#123;this.state.arr&#125;      &lt;button onClick=&#123;() =&gt; this.addArr()&#125;&gt;数组增加&lt;/button&gt;    &lt;/div&gt;  &#125;&#125;export default App;\n\n五、条件渲染和列表循环React 没有 Vue 一样的指令，一切操作本质上是通过运算生成不同的内容，再渲染得到不同的页面\nimport React from &#x27;react&#x27;;class App extends React.PureComponent &#123;  state = &#123;    show: true,    originArr: [1, 2, 3] // [1, 2, 3] =&gt; [&lt;div&gt;1&lt;/div&gt;, &lt;div&gt;2&lt;/div&gt;, &lt;div&gt;3&lt;/div&gt;]  &#125;  f1() &#123;    if(this.state.show) &#123;      return &lt;div&gt;div1&lt;/div&gt;    &#125;    return &quot;&quot;  &#125;  getArr() &#123;    let newArr = []    this.state.originArr.forEach((item) =&gt; &#123;      newArr.push(&lt;div&gt;&#123;item&#125;&lt;/div&gt;)    &#125;)    console.log(&#x27;newArr&#x27;, newArr)    return newArr  &#125;  addData = () =&gt; &#123;    let _arr = [...this.state.originArr]    _arr.push(Math.random() * 10)    this.setState(&#123;      originArr: _arr    &#125;)  &#125;  render() &#123;    return &lt;div className=&quot;App&quot;&gt;      &lt;div&gt;条件渲染&lt;/div&gt;      &#123;/* &#123;this.state.show ? &lt;div&gt;div1&lt;/div&gt;: &quot;&quot;&#125; */&#125;      &#123;this.f1()&#125;      &lt;button onClick=&#123;() =&gt; &#123;        this.setState(&#123;          show: !this.state.show        &#125;)      &#125;&#125;&gt;&#123;this.state.show ? &quot;隐藏&quot; : &quot;显示&quot;&#125;&lt;/button&gt;      &lt;div&gt;列表渲染&lt;/div&gt;      &#123;/* &#123; this.getArr() &#125; */&#125;      &#123;        this.state.originArr.map((item) =&gt; &#123;          return &lt;div key=&#123;item&#125;&gt;&#123;item&#125;&lt;/div&gt;        &#125;)      &#125;      &lt;button onClick=&#123;() =&gt; this.addData()&#125;&gt;添加&lt;/button&gt;    &lt;/div&gt;  &#125;&#125;export default App;\n\n六、表单绑定React 中很多思路都是按原生的操作去做的，表单绑定也是如此\n原生表单获取表单输入值，可以通过监听 input、change 等事件，然后获取 e.target.value\n如果要设置表单的值，通常设置 value 属性，如果是选择框则是 checked 属性\nimport React from &#x27;react&#x27;;class App extends React.PureComponent &#123;  state = &#123;    inputValue: &quot;&quot;,    checkedArr: [&quot;c2&quot;]  &#125;  handleChecked = (e) =&gt; &#123;    let arr = [...this.state.checkedArr]    if(e.target.checked) &#123;      arr.push(e.target.value)    &#125;    else &#123;      arr.splice(arr.indexOf(e.target.value), 1)    &#125;    this.setState(&#123;      checkedArr: arr    &#125;)  &#125;    render() &#123;    return &lt;div className=&quot;App&quot;&gt;      &#123;/* &lt;input onBlur=&#123;&#125; /&gt; */&#125;      &#123;/* &lt;input onChange=&#123;&#125; /&gt; */&#125;      &lt;input value=&#123;this.state.inputValue&#125; onInput=&#123;(e) =&gt; &#123;        this.setState(&#123;          inputValue: e.target.value        &#125;)      &#125;&#125; /&gt;      &#123; this.state.inputValue &#125;      &#123;/* checkbox */&#125;      &lt;input checked=&#123;this.state.checkedArr.indexOf(&quot;c1&quot;)!==-1&#125; type=&quot;checkbox&quot; value=&quot;c1&quot; name=&quot;choose&quot; onChange=&#123;this.handleChecked&#125; /&gt;      &lt;input checked=&#123;this.state.checkedArr.indexOf(&quot;c2&quot;)!==-1&#125; type=&quot;checkbox&quot; value=&quot;c2&quot; name=&quot;choose&quot; onChange=&#123;this.handleChecked&#125; /&gt;      &lt;input checked=&#123;this.state.checkedArr.indexOf(&quot;c3&quot;)!==-1&#125; type=&quot;checkbox&quot; value=&quot;c3&quot; name=&quot;choose&quot; onChange=&#123;this.handleChecked&#125; /&gt;      &#123; this.state.checkedArr &#125;    &lt;/div&gt;  &#125;&#125;export default App;\n\n七、props 和组件间传值、插槽props 是 React 中的核心，一切写在组件上的属性和子节点都被划为 props\nReact 父子传值，插槽全都基于 props，不像 Vue 有事件监听、emit、专门的插槽 这类东西\n/* App.js */import React from &#x27;react&#x27;;import Son from &#x27;./Son&#x27;;class App extends React.PureComponent &#123;  state = &#123;    // msg: 123 // 抛出类型错误    msg: &quot;app message&quot;  &#125;  changeMsg = (sonMsg) =&gt; &#123;    console.log(&quot;sonMsg&quot;, sonMsg)    this.setState(&#123;      msg: sonMsg    &#125;)  &#125;    render() &#123;    return &lt;div className=&quot;App&quot;&gt;      I&#x27;m App.      &lt;br&gt;&lt;/br&gt;      &#123;/* 具名插槽 */&#125;      &#123;/* 在插槽中显示子组件内容 */&#125;      &#123;/* &lt;Son msg=&#123;this.state.msg&#125; a=&#123;&lt;div&gt;I&#x27;m slot2&lt;/div&gt;&#125; scopeslot=&#123;(scope) =&gt; &#123;        return &lt;div&gt;scope: &#123;scope&#125;&lt;/div&gt;      &#125;&#125;&gt;        &lt;div&gt;I&#x27;m slot&lt;/div&gt;      &lt;/Son&gt; */&#125;      &lt;Son msg=&#123;this.state.msg&#125; changeMsg=&#123;this.changeMsg&#125;&gt;      &lt;/Son&gt;    &lt;/div&gt;  &#125;&#125;export default App;\n\n/* Son.js */import React from &quot;react&quot;import proptypes from &quot;proptypes&quot;class Son extends React.PureComponent &#123;    // constructor(props) &#123;    //     super(props)    //     this.state = &#123;    //         sonMsg: &quot;hello&quot;    //     &#125;    // &#125;    state = &#123;        sonMsg: &quot;son message&quot;    &#125;    render() &#123;        // console.log(&quot;this.props&quot;, this.props)        // return &lt;div&gt;        //     &#123;/* 具名插槽 */&#125;        //     &#123;this.props.a&#125;        //     &#123;&quot;this.props.msg: &quot; + this.props.msg&#125;        //     &lt;br&gt;&lt;/br&gt;        //     &#123;&quot;this.state.sonMsg: &quot; + this.state.sonMsg&#125;        //     &lt;br&gt;&lt;/br&gt;        //     I&#x27;m Son.        //     &#123;this.props.children&#125;        //     &#123;/* 在插槽中显示子组件内容 */&#125;        //     &#123;this.props.scopeslot(this.state.sonMsg)&#125;        // &lt;/div&gt;        return &lt;div&gt;            &#123;this.props.msg&#125;            &lt;button onClick=&#123;() =&gt; this.props.changeMsg(&quot;hello, father&quot;)&#125;&gt;修改&lt;/button&gt;        &lt;/div&gt;    &#125;&#125;// Son.propTypes = &#123;//     msg: function(props) &#123;//         if (typeof props.msg !== &quot;string&quot;) &#123;//             throw new Error(&quot;msg must be a string&quot;)//         &#125;//     &#125;// &#125;// proptypes 库Son.propTypes = &#123;    msg: proptypes.string&#125;Son.defaultProps = &#123;    msg: &quot;default&quot;&#125;export default Son;\n\n八、React 样式设置1、class 类名设置（1）必须写为 className\n（2）类名和样式写在 css 文件里\n（3）必须接受一个字符串\n2、style 内联不能像原生一样写成字符串，必须写成对象\n/* App.js */import &#x27;./App.css&#x27;;import React from &#x27;react&#x27;;import Son from &#x27;./Son&#x27;;class App extends React.PureComponent &#123;  state = &#123;    msg: &quot;app message&quot;  &#125;    render() &#123;    return &lt;div&gt;      &lt;div className=&quot;father&quot; style=&#123;        &#123;          background: &quot;yellow&quot;,          fontSize: &quot;25px&quot;        &#125;      &#125;&gt;father&lt;/div&gt;      &lt;Son&gt;&lt;/Son&gt;    &lt;/div&gt;  &#125;&#125;export default App;\n\n/* Son.js */import React from &quot;react&quot;import proptypes from &quot;proptypes&quot;// import &quot;./Son.css&quot;import sonStyle from &quot;./Son.module.css&quot;// console.log(&quot;sonStyle&quot;, sonStyle)// 组件名 - .module.css// vue style scoped// import classnames from &quot;classnames&quot; // 非模块化import classnames from &quot;classnames/bind&quot; // 模块化let bindClassnames = classnames.bind(sonStyle) // 模块化方法let str = classnames(&#123;    son: true,    son1: true&#125;)console.log(&quot;str&quot;, str)// 更方便操作类名的库 - classnames// 本质是生成一个字符串class Son extends React.PureComponent &#123;    state = &#123;        sonMsg: &quot;son message&quot;,        hasSon1: false    &#125;    render() &#123;        return &lt;div&gt;            &#123;/* 取出新的 class 名 */&#125;            &lt;div className=&#123;sonStyle.son + &quot; &quot; + sonStyle.son1&#125;&gt;son1&lt;/div&gt;                        &#123;/* classnames 库 */&#125;            &#123;/* 非模块化 */&#125;            &lt;div className=&#123;classnames(&#123;                son: true,                son1: this.state.hasSon1            &#125;)&#125;&gt;son2&lt;/div&gt;            &#123;/* 模块化 */&#125;            &lt;div className=&#123;bindClassnames(&#123;                son: true,                son1: this.state.hasSon1            &#125;)&#125;&gt;son3&lt;/div&gt;        &lt;/div&gt;    &#125;&#125;// proptypes 库Son.propTypes = &#123;    msg: proptypes.string&#125;Son.defaultProps = &#123;    msg: &quot;default&quot;&#125;export default Son;\n\n/* App.css */.father &#123;  color: red&#125;\n\n/* Son.module.css */.son &#123;    color: blue&#125;.son1 &#123;    background-color: bisque;&#125;\n\n九、React 生命周期1、生命周期图示\n2、严格模式严格模式只在开发模式下生效，生产上线时会去除，作用如下：\n（1）检测危险操作（比如：使用已经废弃 api 和不推荐的 api）\n（2）把生命周期执行两次，来检测额外副作用（比如：render）\n/* index.js */const root = ReactDOM.createRoot(document.getElementById(&#x27;root&#x27;));root.render(  // 严格模式  &lt;React.StrictMode&gt;    &lt;App /&gt;  &lt;/React.StrictMode&gt;);\n\n3、React 和 Vue 更新（1）VueVue 是在 get 和 set 里触发更新，在 get 部分会进行依赖收集的操作\n在更改数据后，只会更新用到该数据的地方，做到最小的更新范围\n（2）ReactReact 的更新是调用方法时触发的，没有依赖收集的过程\n所以会更新整个组件树、同时更新子组件，即使更新的数据和子组件没有关系\n/* App.js */import &#x27;./App.css&#x27;;import React from &#x27;react&#x27;;import Son from &#x27;./Son&#x27;;class App extends React.Component &#123;  constructor(props) &#123;    super(props)    this.state = &#123;      msg: &quot;app message&quot;    &#125;    console.log(&quot;constructor&quot;)  &#125;  // derived 派生的  static getDerivedStateFromProps(props, state) &#123;    console.log(&quot;derived&quot;)    console.log(&quot;derived-props&quot;, props)    console.log(&quot;derived-state&quot;, state)    return null  &#125;  // 优化生命周期（只能在 React.Component 中使用，因为 PureComponent 已经实现了）  shouldComponentUpdate(props, state) &#123;    console.log(&quot;shouldUpdate&quot;)    // console.log(&quot;shouldUpdate-props&quot;, props)    console.log(&quot;shouldUpdate-this.state 修改前&quot;, this.state)    console.log(&quot;shouldUpdate-state 修改后&quot;, state)    // 实现 PureComponent 优化    for(let item in this.state) &#123;      if(this.state[item] != state[item]) &#123;        return true      &#125;    &#125;    return false  &#125;    // 一定不要修改数据  render() &#123;    console.log(&quot;render&quot;)    return &lt;div&gt;      &lt;div className=&quot;father&quot;&gt;        &lt;div&gt;&#123;this.state.msg&#125;&lt;/div&gt;        &lt;button onClick=&#123;() =&gt; &#123;          this.setState(&#123;            msg: &quot;hello&quot;          &#125;)        &#125;&#125;&gt;修改msg&lt;/button&gt;        &lt;Son&gt;&lt;/Son&gt;      &lt;/div&gt;    &lt;/div&gt;  &#125;  // 类似 Vue mounted  componentDidMount() &#123;    console.log(&quot;didMount&quot;)  &#125;  // 类似 Vue updated  componentDidUpdate() &#123;    console.log(&quot;didUpdate&quot;)  &#125;  // 类似 Vue unmounted  componentWillUnmount() &#123;    console.log(&quot;willUnmount&quot;)  &#125;&#125;export default App;\n\n/* Son.js */import React from &quot;react&quot;import proptypes from &quot;proptypes&quot;// 如果使用 Component，父组件更新会导致子组件更新，即使子组件数组没变化class Son extends React.Component &#123;    state = &#123;        sonMsg: &quot;son message&quot;,        hasSon1: false    &#125;    render() &#123;        console.log(&quot;son render&quot;)        return &lt;div&gt;        &lt;/div&gt;    &#125;&#125;// proptypes 库Son.propTypes = &#123;    msg: proptypes.string&#125;Son.defaultProps = &#123;    msg: &quot;default&quot;&#125;export default Son;\n","categories":["React - 基础课程"],"tags":["React"]},{"title":"React2","url":"/2025/01/24/57-React2/","content":"十、实战-制作一个增删改查列表/* App.js */import &quot;./App.css&quot;;import React from &quot;react&quot;;import axios from &quot;axios&quot;;import Pop from &quot;./Pop&quot;;// 状态列表let arr = [  &#123;    text: &quot;进行中&quot;,    color: &quot;blue&quot;,  &#125;,  &#123;    text: &quot;已完成&quot;,    color: &quot;green&quot;,  &#125;,  &#123;    text: &quot;已延期&quot;,    color: &quot;red&quot;,  &#125;,];class App extends React.Component &#123;  state = &#123;    tableArr: [],    searchParams: &#123;      dateValue: &quot;&quot;,      nameValue: &quot;&quot;,      statusValue: 0,    &#125;,    popForm: &#123;      dateValue: &quot;&quot;,      nameValue: &quot;&quot;,      statusValue: 0,    &#125;,    popShow: false,    popTitle: undefined,    // confirmFn: undefined,  &#125;;  componentDidMount() &#123;    this.getList();  &#125;  // 查询列表  getList(params) &#123;    axios(&#123;      url: &quot;http://localhost:8000/list&quot;,      method: &quot;get&quot;,      params,    &#125;).then((res) =&gt; &#123;      console.log(&quot;res&quot;, res);      this.setState(&#123;        tableArr: res.data.data,      &#125;);    &#125;);  &#125;  // 展示状态文字  showStatus(status) &#123;    return (      &lt;span        style=&#123;&#123;          color: arr[status]?.color,        &#125;&#125;      &gt;        &#123;arr[status]?.text&#125;      &lt;/span&gt;    );  &#125;  // 搜索  searchData() &#123;    this.getList(&#123;      date: this.state.searchParams.dateValue,      name: this.state.searchParams.nameValue,      status: this.state.searchParams.statusValue,    &#125;);  &#125;  // 重置  resetData() &#123;    this.setState(      &#123;        searchParams: &#123;          dateValue: &quot;&quot;,          nameValue: &quot;&quot;,          statusValue: 0,        &#125;,      &#125;,      () =&gt; &#123;        this.getList();      &#125;    );  &#125;  // 新增  addFn() &#123;    axios(&#123;      url: &quot;http://localhost:8000/addOrder&quot;,      method: &quot;post&quot;,      data: this.state.popForm,    &#125;).then((res) =&gt; &#123;      console.log(&quot;addFn res&quot;, res);      this.setState(&#123;        popShow: false,      &#125;);      this.getList();    &#125;);  &#125;  // 编辑  updateFn() &#123;    axios(&#123;      url: &quot;http://localhost:8000/updateOrder&quot;,      method: &quot;post&quot;,      data: this.state.popForm,    &#125;).then((res) =&gt; &#123;      console.log(&quot;updateFn res&quot;, res);      this.setState(&#123;        popShow: false,        popForm: &#123;          dateValue: &quot;&quot;,          nameValue: &quot;&quot;,          statusValue: 0,        &#125;,      &#125;);      this.getList();    &#125;);  &#125;  // 删除  deleteFn(id) &#123;    axios(&#123;      url: &quot;http://localhost:8000/updateOrder&quot;,      method: &quot;post&quot;,      data: &#123;        id      &#125;,    &#125;).then((res) =&gt; &#123;      console.log(&quot;deleteFn res&quot;, res);      this.getList();    &#125;);  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;div&gt;          &lt;label&gt;日期&lt;/label&gt;          &lt;input            value=&#123;this.state.searchParams.dateValue&#125;            onInput=&#123;(e) =&gt; &#123;              this.setState(&#123;                searchParams: &#123;                  ...this.state.searchParams,                  dateValue: e.target.value,                &#125;,              &#125;);            &#125;&#125;          /&gt;          &lt;label&gt;订单名&lt;/label&gt;          &lt;input            value=&#123;this.state.searchParams.nameValue&#125;            onInput=&#123;(e) =&gt; &#123;              this.setState(&#123;                searchParams: &#123;                  ...this.state.searchParams,                  nameValue: e.target.value,                &#125;,              &#125;);            &#125;&#125;          /&gt;          &lt;label&gt;订单状态&lt;/label&gt;          &lt;select            value=&#123;this.state.searchParams.statusValue&#125;            onChange=&#123;(e) =&gt; &#123;              this.setState(&#123;                searchParams: &#123;                  ...this.state.searchParams,                  statusValue: e.target.value,                &#125;,              &#125;);            &#125;&#125;          &gt;            &#123;arr.map((item, index) =&gt; &#123;              return (                &lt;option value=&#123;index&#125; key=&#123;index&#125;&gt;                  &#123;item.text&#125;                &lt;/option&gt;              );            &#125;)&#125;          &lt;/select&gt;          &lt;button onClick=&#123;() =&gt; this.searchData()&#125;&gt;搜索&lt;/button&gt;          &lt;button onClick=&#123;() =&gt; this.resetData()&#125;&gt;重置&lt;/button&gt;        &lt;/div&gt;        &#123;/* 新增按钮 */&#125;        &lt;div&gt;          &lt;button            onClick=&#123;() =&gt; &#123;              this.setState(&#123;                popShow: true,                popTitle: &quot;新增&quot;,                // confirmFn: this.addFn.bind(this),              &#125;);            &#125;&#125;          &gt;            新增          &lt;/button&gt;        &lt;/div&gt;        &#123;/* 表格 */&#125;        &lt;table&gt;          &lt;thead&gt;            &lt;tr&gt;              &lt;td&gt;日期&lt;/td&gt;              &lt;td&gt;订单名&lt;/td&gt;              &lt;td&gt;订单状态&lt;/td&gt;              &lt;td&gt;操作&lt;/td&gt;            &lt;/tr&gt;          &lt;/thead&gt;          &lt;tbody&gt;            &#123;this.state.tableArr.map((item) =&gt; &#123;              return (                &lt;tr key=&#123;item.id&#125;&gt;                  &lt;td&gt;&#123;item.date&#125;&lt;/td&gt;                  &lt;td&gt;&#123;item.name&#125;&lt;/td&gt;                  &lt;td&gt;&#123;this.showStatus(item.status)&#125;&lt;/td&gt;                  &lt;td&gt;                    &lt;button                      onClick=&#123;() =&gt; &#123;                        this.setState(&#123;                          popShow: true,                          popTitle: &quot;编辑&quot;,                          popForm: &#123;                            dateValue: item.date,                            nameValue: item.name,                            statusValue: item.status,                          &#125;,                          // confirmFn: this.updateFn.bind(this)                        &#125;);                      &#125;&#125;                    &gt;                      编辑                    &lt;/button&gt;                    &lt;button onClick=&#123;() =&gt; this.deleteFn(item.id)&#125;&gt;删除&lt;/button&gt;                  &lt;/td&gt;                &lt;/tr&gt;              );            &#125;)&#125;          &lt;/tbody&gt;        &lt;/table&gt;        &#123;/* 弹窗 */&#125;        &#123;this.state.popShow ? (          &lt;Pop            title=&#123;this.state.popTitle&#125;            confirm=&#123;              this.state.popTitle === &quot;新增&quot;                ? this.addFn.bind(this)                : this.updateFn.bind(this)            &#125;            cancel=&#123;() =&gt; &#123;              this.setState(&#123;                popShow: false,              &#125;);            &#125;&#125;          &gt;            &lt;div&gt;              &lt;div&gt;                &lt;label&gt;日期&lt;/label&gt;                &lt;input                  value=&#123;this.state.popForm.dateValue&#125;                  onInput=&#123;(e) =&gt; &#123;                    this.setState(&#123;                      popForm: &#123;                        ...this.state.popForm,                        dateValue: e.target.value,                      &#125;,                    &#125;);                  &#125;&#125;                /&gt;              &lt;/div&gt;              &lt;div&gt;                &lt;label&gt;订单名&lt;/label&gt;                &lt;input                  value=&#123;this.state.popForm.nameValue&#125;                  onInput=&#123;(e) =&gt; &#123;                    this.setState(&#123;                      popForm: &#123;                        ...this.state.popForm,                        nameValue: e.target.value,                      &#125;,                    &#125;);                  &#125;&#125;                /&gt;              &lt;/div&gt;              &lt;div&gt;                &lt;label&gt;状态&lt;/label&gt;                &lt;select                  value=&#123;this.state.popForm.statusValue&#125;                  onChange=&#123;(e) =&gt; &#123;                    this.setState(&#123;                      popForm: &#123;                        ...this.state.popForm,                        statusValue: e.target.value,                      &#125;,                    &#125;);                  &#125;&#125;                &gt;                  &#123;arr.map((item, index) =&gt; &#123;                    return (                      &lt;option value=&#123;index&#125; key=&#123;index&#125;&gt;                        &#123;item.text&#125;                      &lt;/option&gt;                    );                  &#125;)&#125;                &lt;/select&gt;              &lt;/div&gt;            &lt;/div&gt;          &lt;/Pop&gt;        ) : null&#125;      &lt;/div&gt;    );  &#125;&#125;export default App;\n\n/* Pop.js */import React from &quot;react&quot;;import popStyle from &quot;./Pop.module.css&quot;;class Pop extends React.PureComponent &#123;  render() &#123;    return (      &lt;div className=&#123;popStyle.cover&#125;&gt;        &lt;div className=&#123;popStyle.content&#125;&gt;          &lt;div className=&#123;popStyle.title&#125;&gt;            &#123;/* &#123;this.props.title ? this.props.title : &quot;标题&quot;&#125; */&#125;            &#123;this.props.title&#125;          &lt;/div&gt;          &#123;/* &lt;div&gt;&#123;this.props.content&#125;&lt;/div&gt; */&#125;          &lt;div&gt;&#123;this.props.children&#125;&lt;/div&gt;          &lt;div&gt;            &lt;button onClick=&#123;() =&gt; this.props.confirm()&#125;&gt;确定&lt;/button&gt;            &lt;button onClick=&#123;() =&gt; this.props.cancel()&#125;&gt;取消&lt;/button&gt;          &lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;    );  &#125;&#125;Pop.defaultProps = &#123;  title: &quot;标题&quot;,&#125;;export default Pop;\n\n/* Pop.module.css */.cover &#123;    position: fixed;    top: 0;    bottom: 0;    left: 0;    right: 0;    background-color: rgba(0, 0, 0, 0.6);&#125;.content &#123;    width: 500px;    margin: 200px auto;    background-color: #fff;&#125;.title &#123;    padding: 30px;    border-bottom: 1px solid #000;&#125;\n\n十一、ref 和 context1、ref用于获取真实 DOM，和 Vue 中的 ref 类似，注意：\n（1）ref 必须在挂载后才能获取，通常在 componentDidMount\n（2）ref 只能获取类组件，不能获取函数组件\n2、context类似 Vue 的 provider 和 injected，用于嵌套很深的爷孙组件之间传值，注意：\n子组件使用父组件创建的 context 对象，不能自己创建\n/* App.js */import React from &quot;react&quot;;import Son from &quot;./Son&quot;;let div1 = React.createRef()let sonComp = React.createRef();// 是一个组件export let Context1 = React.createContext();class App extends React.PureComponent &#123;  state = &#123;    msg: &quot;父组件&quot;,    passMsg: &quot;传递消息&quot;  &#125;  // div1 = React.createRef()  componentDidMount() &#123;    // 真实 DOM    console.log(&quot;div1.current&quot;, div1.current)    //     console.log(&quot;sonComp.current&quot;, sonComp.current)  &#125;  render() &#123;    return (      // 类似 Vue 中的 template      &lt;&gt;        &lt;div className=&quot;App&quot; ref=&#123;div1&#125;&gt;&#123;this.state.msg&#125;&lt;/div&gt;                &#123;/* 只能使用 value 这一个 props */&#125;        &lt;Context1.Provider value=&#123;this.state.passMsg&#125;&gt;          &lt;Son ref=&#123;sonComp&#125;&gt;&lt;/Son&gt;        &lt;/Context1.Provider&gt;      &lt;/&gt;    );  &#125;&#125;export default App;\n\n/* Son.js */import React from &quot;react&quot;;import GrandSon from &quot;./GrandSon&quot;;class Son extends React.PureComponent &#123;  state = &#123;    sonMsg: &quot;子组件&quot;,  &#125;;  render() &#123;    return (      &lt;&gt;        &lt;div className=&quot;Son&quot;&gt;&#123;this.state.sonMsg&#125;&lt;/div&gt;        &lt;GrandSon&gt;&lt;/GrandSon&gt;      &lt;/&gt;    );  &#125;&#125;export default Son;\n\n/* GrandSon.js */import React from &quot;react&quot;;import &#123; Context1 &#125; from &quot;./App&quot;;class GrandSon extends React.PureComponent &#123;  state = &#123;    grandsonMsg: &quot;孙子组件&quot;,  &#125;;  render() &#123;    return (      &lt;&gt;        &lt;div className=&quot;Son&quot;&gt;&#123;this.state.grandsonMsg&#125;&lt;/div&gt;        &lt;Context1.Consumer&gt;          &#123;            (value) =&gt; &#123;              console.log(value);              return &lt;div&gt;&#123;value&#125;&lt;/div&gt;            &#125;          &#125;        &lt;/Context1.Consumer&gt;      &lt;/&gt;    );  &#125;&#125;export default GrandSon;\n\n十二、函数组件 和 hook1、函数组件和类组件的区别（1）函数组件没有生命周期\n（2）函数组件没有 this\n（3）函数组件通过 hook 来完成各种操作\n（4）函数组件本身的函数体相当于 render 函数\n（5）props 在函数的第一个参数接受\n2、useEffect()不传第二个参数 &#x3D; componentDidMount 和 componentDidUpdate\n第二个参数传空数组 &#x3D; componentDidMount\n第二个参数数组里放某个数据 &#x3D; watch 监听\n3、useMemo()让一段计算在开始运行一次，后续只有依赖的数据发生变化时才重新运算，作用：\n（1）类似于 Vue 的一个计算属性的效果\n（2）缓存一个数据，让其不会重新创建\n4、 useCallback()缓存一个方法，让方法不会每次更新都重新创建\n5、其他 hooksuseRef：函数组件中使用 ref\nuseContext：更方便解析 context 的 provider 的数据\n/* App.js */import Son from &quot;./Son&quot;;// vue3 - ref, reactiveimport &#123; useState, useEffect, useMemo, useCallback, useRef, createContext &#125; from &quot;react&quot;;export let Context1 = createContext();function App() &#123;  // 相当于 render  // return 的内容相当于组件的 html  let [msg, setMsg] = useState(&quot;hello&quot;);  let [msg2, setMsg2] = useState(&quot;hello2&quot;);  let [arr, setArr] = useState([1, 2, 3]);  let dom1 = useRef();  // 想要第二次更新不会运行，第二个参数需要传监听的数组  let all = useMemo(() =&gt; &#123;    console.log(&quot;recount&quot;);    let _all = 0;    arr.forEach((item) =&gt; &#123;      _all += item;    &#125;);    return _all;  &#125;, [arr]);  // useEffect, useMemo, useCallback 第二个参数的作用一样  let changeMsg = useCallback(() =&gt; &#123;    setMsg(&quot;1&quot;);  &#125;, []);  function changeArr() &#123;    let _arr = [...arr];    _arr.push(4);    setArr(_arr);  &#125;  // // 第一个参数是回调函数 - 必填  // // 不传第二个参数 = componentDidMount 和 componentDidUpdate  // useEffect(() =&gt; &#123;  //   console.log(&quot;effect&quot;)  // &#125;)  // // 第二个参数传空数组 = componentDidMount  // useEffect(() =&gt; &#123;  //   console.log(&quot;effect&quot;)  // &#125;, [])  // 第二个参数传非空数组 = watch 监听  // 一开始就会执行  useEffect(() =&gt; &#123;    console.log(&quot;effect&quot;);  &#125;, [msg]);  useEffect(() =&gt; &#123;    console.log(&quot;dom1&quot;, dom1);  &#125;, []);  return (    &lt;&gt;      &lt;div&gt;this is App&lt;/div&gt;      &lt;div&gt;&#123;msg&#125;&lt;/div&gt;      &lt;div&gt;&#123;msg2&#125;&lt;/div&gt;      &lt;div&gt;&#123;all&#125;&lt;/div&gt;      &lt;div&gt;&#123;arr&#125;&lt;/div&gt;      &lt;button ref=&#123;dom1&#125; onClick=&#123;changeMsg&#125;&gt;        修改msg      &lt;/button&gt;      &lt;button        onClick=&#123;() =&gt; &#123;          setMsg2(&quot;2&quot;);        &#125;&#125;      &gt;        修改msg2      &lt;/button&gt;      &lt;button onClick=&#123;changeArr&#125;&gt;修改arr&lt;/button&gt;      &lt;Context1.Provider value=&quot;I&#x27;m context msg&quot;&gt;        &lt;Son fatherMsg=&quot;I&#x27;m father&quot;&gt;&lt;/Son&gt;      &lt;/Context1.Provider&gt;    &lt;/&gt;  );&#125;export default App;\n\n/* Son.js */import &#123; useContext &#125; from &quot;react&quot;;import &#123; Context1 &#125; from &quot;./App&quot;;function Son(props) &#123;  console.log(&quot;props&quot;, props);  let value = useContext(Context1);  console.log(&quot;value&quot;, value);  return &lt;div&gt;this is son&lt;/div&gt;;&#125;export default Son;\n\n十三、高阶组件如果是 UI 内容和操作的复用是使用组件，但如果是单纯逻辑的复用，可以使用高阶组件\n可以类比于 Vue 中的 Mixin 和自定义指令\n什么时候用高阶组件（1）组件组件既包含了 UI 界面的复用，也包含了逻辑的复用\n（2）高阶组件高阶组件只是复用操作逻辑、运算。类似 Vue 中 Mixin 的用途\n/* App.js */import &#123; useState &#125; from &quot;react&quot;;import Son from &quot;./Son&quot;;// import TestHoc from &quot;./TestHoc&quot;;import MemoHoc from &quot;./MemoHoc&quot;;// let HocSon = TestHoc(Son);let MemoSon = MemoHoc(Son);function App() &#123;  let [num, setNum] = useState(0);  return (    &lt;&gt;      &#123;/* 鼠标位置监听 */&#125;      &#123;/* &lt;HocSon&gt;&lt;/HocSon&gt; */&#125;      &lt;MemoSon&gt;&lt;/MemoSon&gt;      &lt;div&gt;num: &#123;num&#125;&lt;/div&gt;      &lt;button        onClick=&#123;() =&gt; &#123;          setNum(1);        &#125;&#125;      &gt;        修改数字      &lt;/button&gt;    &lt;/&gt;  );&#125;export default App;\n\n/* TestHoc.js */import React from &quot;react&quot;;// 抛出一个 返回匿名类组件的方法// 复用了其中的 state 数据 和 fn1 方法export default function TestHoc(UserComp) &#123;  return class extends React.PureComponent &#123;    state = &#123;    //   a: 123,      x: 0,      y: 0,    &#125;;    // fn1 = () =&gt; &#123;    //     console.log(&quot;this.state.a&quot;, this.state.a)    // &#125;    componentDidMount() &#123;      window.addEventListener(&quot;mousemove&quot;, (e) =&gt; &#123;        let x = e.clientX;        let y = e.clientY;        this.setState(&#123;          x,          y,        &#125;);      &#125;);    &#125;    render() &#123;      return (        &lt;&gt;          &#123;/* &lt;UserComp f1=&#123;this.fn1&#125; &#123;...this.props&#125; /&gt; */&#125;          &#123;/* 鼠标位置监听 */&#125;          &lt;UserComp x=&#123;this.state.x&#125; y=&#123;this.state.y&#125; &#123;...this.props&#125; /&gt;        &lt;/&gt;      );    &#125;  &#125;;&#125;\n\n/* MemoHoc.js */import React from &quot;react&quot;;export default function MemoHoc(UserComp) &#123;  return class extends React.Component &#123;    shouldComponentUpdate(props, state) &#123;        for(let item in props) &#123;            if(this.props[item] !== props[item]) &#123;                return true;            &#125;        &#125;        for(let item in state) &#123;            if(this.state[item] !== state[item]) &#123;                return true;            &#125;        &#125;        return false    &#125;    render() &#123;      return (        &lt;&gt;          &lt;UserComp &#123;...this.props&#125;&gt;&lt;/UserComp&gt;        &lt;/&gt;      );    &#125;  &#125;;&#125;\n\n/* Son.js */function Son(props) &#123;  // props.f1()  console.log(&quot;son render&quot;);  return (    &lt;&gt;      &lt;div&gt;高阶组件的使用&lt;/div&gt;      &#123;/* 鼠标位置监听 */&#125;      &#123;/* &lt;div&gt;x: &#123;props.x&#125;&lt;/div&gt;      &lt;div&gt;y: &#123;props.y&#125;&lt;/div&gt; */&#125;    &lt;/&gt;  );&#125;export default Son;\n\n十四、React 性能优化1、React 性能问题React 最大的性能问题就是：某个组件的更新 会连带其子组件一起更新，所以需要：\n（1）源码层面上尽量弥补这个问题\n（2）让子组件只做合理的更新\n2、React 时间切片Vue 有依赖收集，做到了最小的更新范围\n而 React 没有，所以 React 要更新，会有大量的 diff 算法比对和计算工作，可能会阻塞浏览器的工作，导致页面长时间白屏\nReact 为解决该问题选择了一种策略——时间切片，也就是先计算一部分更新，接着让渡给渲染进程渲染，然后再进行下一步更新\n\n为支持这种切片，React 设计了数据结构 fiber\n每个组件会被转化为一个 fiber 结构的对象，组成一个个单元，并且能够恢复上次中断的计算进度\n\n3、减少无意义的组件更新（1）避免父组件数据更改导致子组件更新\n类组件：PureComponent，函数组件：React.memo\n（2）避免 state 的导致的无畏更新\n类组件：PureComponent，函数组件：本来就会判断\n（3）props\n如果组件使用了 PureComponent 或者 React.Memo，已经做到了如果父组件传的 props 没变，就不会更新\n但需要特别注意父组件传入的引用数据类型：方法、对象、数组\n\n用 useCallback 包裹传给子组件的方法\n非 state 对象、数组数据，要用 useMemo 包裹\n\n/* App.js */import &#123; useMemo, useCallback &#125; from &quot;react&quot;;import Son from &quot;./Son&quot;;// React.memo 也是一种高阶函数let MemoSon = React.memo(Son);function App() &#123;  // 内部数据更新 -&gt; App 组件更新 -&gt; 重新执行 App 函数 -&gt; 重新定义 obj 和 f1 -&gt; 更新 MemoSon 子组件  // let obj = &#123;  //     a: 1  // &#125;  let obj = useMemo(() =&gt; &#123;    return &#123;      a: 1,    &#125;;  &#125;, []);  // function f1() &#123;  //     console.log(123)  // &#125;  let f1 = useCallback(() =&gt; &#123;    console.log(123);  &#125;, []);  return (    &lt;&gt;      &lt;MemoSon obj=&#123;obj&#125; f1=&#123;f1&#125;&gt;&lt;/MemoSon&gt;    &lt;/&gt;  );&#125;\n","categories":["React - 基础课程"],"tags":["React"]},{"title":"React3","url":"/2025/01/25/58-React3/","content":"十五、React-router 使用1、React-router 的三个版本（1）React-router服务端渲染使用\n（2）React-router-dom浏览器端渲染使用（常用）\n（3）React-router-nativeReact-native 混合开发使用\n2、React-router 使用步骤（1）通过 BrowserRouter 或者 HashRouter 包裹要使用路由的根组件\n（2）使用 Routes 组件，定义路由显示区域\n（3）使用 Route 组件，定义具体路由规则\n（4）使用 NavLink 或者 Link 组件，定义跳转链接\n3、React-router 其他组件（1）Navigate：路由重定向\n（2）Outlet：嵌套路由的子路由显示处\n4、获取路由参数（1）Params 参数\nV5：useParams\nV6：this.props.match.params\n\n（2）Query 参数\nV5：useSearchParams\nV6：this.props.location.search\n\n（3）Location 信息\nV5：useLocation\nV6：this.props.location.state\n\n5、js 控制跳转地址\nV6：useNavigate 创建跳转方法、然后跳转\nV5：this.props.history.push()\n\n6、React 异步路由React 做异步路由，要配合 React 的方法 lazy 和 组件 suspense\n/* index.js */import React from &quot;react&quot;;import ReactDOM from &quot;react-dom/client&quot;;import &quot;./index.css&quot;;import App from &quot;./App&quot;;import reportWebVitals from &quot;./reportWebVitals&quot;;import &#123; BrowserRouter, HashRouter &#125; from &quot;react-router-dom&quot;;const root = ReactDOM.createRoot(document.getElementById(&quot;root&quot;));root.render(  &lt;React.StrictMode&gt;    &#123;/* history 模式，路径为 .../page1 */&#125;    &lt;BrowserRouter&gt;      &#123;/* hash 模式，路径为 .../#/page1 */&#125;      &#123;/* &lt;HashRouter&gt; */&#125;      &lt;App /&gt;      &#123;/* &lt;/HashRouter&gt; */&#125;    &lt;/BrowserRouter&gt;  &lt;/React.StrictMode&gt;);reportWebVitals();\n\n/* App.js */import &quot;./App.css&quot;;import &#123; Routes, Route, NavLink, Link, Navigate &#125; from &quot;react-router-dom&quot;;import Page1 from &quot;./Page1&quot;;import Page2 from &quot;./Page2&quot;;import Page3 from &quot;./Page3&quot;;import Page4 from &quot;./Page4&quot;;import Page2Son1 from &quot;./Page2Son1&quot;;import Page2Son2 from &quot;./Page2Son2&quot;;// 异步路由（懒加载）import &#123; lazy, Suspense &#125; from &quot;react&quot;;let LazyPage4 = lazy(() =&gt; &#123;  return import(&quot;./Page4&quot;);&#125;);function App() &#123;  let _token = localStorage.getItem(&quot;token&quot;);  return (    &lt;&gt;      &#123;/* 菜单 */&#125;      &lt;div&gt;        &#123;/* NavLink 有 active 类 */&#125;        &lt;NavLink to=&quot;/page1&quot;&gt;page1&lt;/NavLink&gt;        &lt;NavLink to=&quot;/page2&quot;&gt;page2&lt;/NavLink&gt;        &lt;NavLink to=&quot;/page3&quot;&gt;page3&lt;/NavLink&gt;        &lt;NavLink to=&quot;/page4&quot;&gt;page4&lt;/NavLink&gt;        &lt;NavLink to=&quot;/lazyPage4&quot;&gt;lazyPage4&lt;/NavLink&gt;        &#123;/* Link 没有 active 类 */&#125;        &#123;/* &lt;Link to=&quot;/page1&quot;&gt;page1&lt;/Link&gt;        &lt;Link to=&quot;/page2&quot;&gt;page2&lt;/Link&gt;        &lt;Link to=&quot;/page3&quot;&gt;page3&lt;/Link&gt;        &lt;Link to=&quot;/page4&quot;&gt;page4&lt;/Link&gt; */&#125;      &lt;/div&gt;      &#123;/* React v5 和 v6 有较大的区别 */&#125;      &#123;/* v5 是 switch，只有 Component */&#125;      &#123;/* Routes 里只能放 Route，Route 也只能放到 Routes 里 */&#125;      &lt;Suspense fallback=&#123;&lt;h2&gt;加载中&lt;/h2&gt;&#125;&gt;        &lt;Routes&gt;          &#123;/* 控制访问权限1：通过 navigate 跳转到其他页面 */&#125;          &#123;/* &lt;Route          path=&quot;/page1&quot;          element=&#123;_token ? &lt;Page1&gt;&lt;/Page1&gt; : &lt;Navigate to=&quot;/page4&quot;&gt;&lt;/Navigate&gt;&#125;        &gt;&lt;/Route&gt; */&#125;          &#123;/* 控制访问权限2：直接不生成 */&#125;          &lt;Route path=&quot;/page1&quot; element=&#123;_token ? &lt;Page1&gt;&lt;/Page1&gt; : &quot;&quot;&#125;&gt;&lt;/Route&gt;          &lt;Route path=&quot;/page2&quot; Component=&#123;Page2&#125;&gt;            &lt;Route path=&quot;son1&quot; Component=&#123;Page2Son1&#125;&gt;&lt;/Route&gt;            &lt;Route path=&quot;son2&quot; Component=&#123;Page2Son2&#125;&gt;&lt;/Route&gt;          &lt;/Route&gt;          &lt;Route path=&quot;/page3/:id&quot; Component=&#123;Page3&#125;&gt;&lt;/Route&gt;          &lt;Route path=&quot;/page4&quot; Component=&#123;Page4&#125;&gt;&lt;/Route&gt;          &lt;Route path=&quot;/lazyPage4&quot; Component=&#123;LazyPage4&#125;&gt;&lt;/Route&gt;        &lt;/Routes&gt;      &lt;/Suspense&gt;    &lt;/&gt;  );&#125;export default App;\n\n/* Page1.js */// location 路径信息import &#123; useLocation &#125; from &quot;react-router-dom&quot;;function Page1() &#123;  let location = useLocation();  console.log(&quot;location&quot;, location);  return &lt;div&gt;this is page1&lt;/div&gt;;&#125;export default Page1;\n\n/* Page2.js */import &#123; Outlet, useNavigate &#125; from &quot;react-router-dom&quot;;function Page2() &#123;  let nav = useNavigate()  return (    &lt;&gt;      &lt;div&gt;this is page2&lt;/div&gt;      &lt;button onClick=&#123;() =&gt; &#123;        nav(&quot;/page1?a=12345&quot;, &#123;          state: &#123;            msg: &quot;state msg&quot;          &#125;        &#125;)      &#125;&#125;&gt;跳转到 page1&lt;/button&gt;      &#123;/* 嵌套路由 */&#125;      &lt;Outlet&gt;&lt;/Outlet&gt;    &lt;/&gt;  );&#125;export default Page2;\n\n/* Page2Son1.js */function Page2Son1() &#123;  return &lt;div&gt;this is page2son1&lt;/div&gt;;&#125;export default Page2Son1;\n\n/* Page2Son2.js */function Page2Son2() &#123;  return &lt;div&gt;this is page2son2&lt;/div&gt;;&#125;export default Page2Son2;\n\n/* Page3.js */// ../page3?a=1&amp;b=2 - Query 参数// ../page3/123 - Param 参数import &#123; useParams &#125; from &quot;react-router-dom&quot;;function Page3() &#123;  let params = useParams()  console.log(&quot;params&quot;, params)  return &lt;div&gt;this is page3&lt;/div&gt;;&#125;export default Page3;\n\n/* Page4.js */import &#123; useSearchParams &#125; from &quot;react-router-dom&quot;;function Page4() &#123;  let [searchParams, setSearchParams] = useSearchParams();  console.log(&quot;searchParams.get(&#x27;a&#x27;)&quot;, searchParams.get(&quot;a&quot;));  // console.log(&quot;setSearchParams&quot;, setSearchParams)  return (    &lt;&gt;      &lt;div&gt;this is page4&lt;/div&gt;      &lt;button        onClick=&#123;() =&gt; &#123;          setSearchParams(&#123;            a: 888,            b: 666,          &#125;);        &#125;&#125;      &gt;        改变 search      &lt;/button&gt;    &lt;/&gt;  );&#125;export default Page4;\n\n十六、React 状态管理1、状态管理（1）React 没有专门的状态管理库，只有通用的 JS 状态管理库，所以首先创建一个全局的数据储存和管理工具\n（2）通过其他工具，数据修改能触发 React 页面更新\n2、React 状态管理库\n3、Redux/* index.js */import React from &quot;react&quot;;import ReactDOM from &quot;react-dom/client&quot;;import &quot;./index.css&quot;;import App from &quot;./App&quot;;import reportWebVitals from &quot;./reportWebVitals&quot;;import &#123; Provider &#125; from &quot;react-redux&quot;;import store from &quot;./store/index&quot;;const root = ReactDOM.createRoot(document.getElementById(&quot;root&quot;));// store.subscribe(() =&gt; &#123;//   root.render(//     &lt;React.StrictMode&gt;//       &lt;App /&gt;//     &lt;/React.StrictMode&gt;//   );// &#125;);root.render(  &lt;React.StrictMode&gt;    &lt;Provider store=&#123;store&#125;&gt;      &lt;App /&gt;    &lt;/Provider&gt;  &lt;/React.StrictMode&gt;);reportWebVitals();\n\n/* App.js */import store from &quot;./store/index&quot;;// let state = store.getState();import &#123; connect &#125; from &quot;react-redux&quot;;function App(props) &#123;  console.log(&quot;props&quot;, props);  // console.log(&quot;state1&quot;, state);  return (    &lt;&gt;      &#123;/* &lt;div&gt;&#123;state.msg&#125;&lt;/div&gt;      &lt;button        onClick=&#123;() =&gt; &#123;          store.dispatch(&#123;            type: &quot;changeMsg&quot;,            payload: &quot;world&quot;,          &#125;);          console.log(&quot;state2&quot;, state);        &#125;&#125;      &gt;        修改 state      &lt;/button&gt; */&#125;      &lt;div&gt;&#123;props.msg&#125;&lt;/div&gt;      &lt;button        onClick=&#123;() =&gt; &#123;          console.log(&quot;store.getState()&quot;, store.getState());          // props.dispatch(&#123;          //   type: &quot;changeMsg&quot;,          //   payload: &quot;world&quot;,          // &#125;);          props.changeMsg();        &#125;&#125;      &gt;        修改 state      &lt;/button&gt;    &lt;/&gt;  );&#125;// connect 第一个参数是 state 的映射，即需要把哪些 state 映射到该组件的 props 里// connect 第二个参数是方法的映射，即需要给 props 加入的方法let ReduxApp = connect(  (state) =&gt; &#123;    console.log(&quot;state&quot;, state);    // return state;    return &#123;      msg: state.msgReducer.msg,    &#125;;  &#125;,  (dispatch) =&gt; &#123;    return &#123;      // 把 dispatch 封装成 changeMsg      changeMsg() &#123;        dispatch(&#123;          type: &quot;changeMsg&quot;,          payload: &quot;world&quot;,        &#125;);      &#125;,    &#125;;  &#125;)(App);export default ReduxApp;\n\n/* store/index.js */import &#123; legacy_createStore as createStore, combineReducers &#125; from &quot;redux&quot;;function msgReducer(state = &#123; msg: &quot;hello&quot; &#125;, action) &#123;  // 具体修改数据的行为  // 通常约定叫 type  switch (action.type) &#123;    case &quot;changeMsg&quot;:      // 通常约定叫 payload      state.msg = action.payload;      // 最后一定要 return 并展开，解除引用      return &#123; ...state &#125;;    case &quot;resetMsg&quot;:      state.msg = &quot;hello&quot;;      return &#123; ...state &#125;;    default:      return state;  &#125;&#125;function numReducer(state = &#123; num: 0 &#125;, action) &#123;  switch (action.type) &#123;    case &quot;addNum&quot;:      state.num++;      return &#123; ...state &#125;;    default:      return state;  &#125;&#125;let reducer = combineReducers(&#123;  msgReducer,  numReducer,&#125;);let store = createStore(reducer);export default store;\n\n4、Redux-toolkit（1）connect 方式/* index.js */import React from &quot;react&quot;;import ReactDOM from &quot;react-dom/client&quot;;import &quot;./index.css&quot;;import App from &quot;./App&quot;;import reportWebVitals from &quot;./reportWebVitals&quot;;import &#123; Provider &#125; from &quot;react-redux&quot;;import store from &quot;./store/toolkitIndex&quot;;const root = ReactDOM.createRoot(document.getElementById(&quot;root&quot;));root.render(  &lt;React.StrictMode&gt;    &lt;Provider store=&#123;store&#125;&gt;      &lt;App /&gt;    &lt;/Provider&gt;  &lt;/React.StrictMode&gt;);reportWebVitals();\n\n/* App.js */import store from &quot;./store/toolkitIndex&quot;;import &#123; connect &#125; from &quot;react-redux&quot;;import &#123; changeMsg, addNum &#125; from &quot;./store/toolkitIndex&quot;;function App(props) &#123;  console.log(&quot;props&quot;, props);  return (    &lt;&gt;      &lt;div&gt;&#123;props.msg&#125;&lt;/div&gt;      &lt;div&gt;&#123;props.num&#125;&lt;/div&gt;      &lt;button        onClick=&#123;() =&gt; &#123;          console.log(&quot;store.getState()&quot;, store.getState());          props.changeMsg();        &#125;&#125;      &gt;        修改 state      &lt;/button&gt;      &lt;button        onClick=&#123;() =&gt; &#123;          console.log(&quot;store.getState()&quot;, store.getState());          props.addNum();        &#125;&#125;      &gt;        增加 num      &lt;/button&gt;    &lt;/&gt;  );&#125;// connect 第一个参数是 state 的映射，即需要把哪些 state 映射到该组件的 props 里// connect 第二个参数是方法的映射，即需要给 props 加入的方法let ReduxApp = connect(  (state) =&gt; &#123;    console.log(&quot;state&quot;, state);    return &#123;      msg: state.msgReducer.msg,      num: state.numReducer.num,    &#125;;  &#125;,  (dispatch) =&gt; &#123;    return &#123;      changeMsg() &#123;        // dispatch(&#123;        //   type: &quot;changeMsg&quot;,        //   payload: &quot;world&quot;,        // &#125;);        // toolkit 的触发方法        dispatch(changeMsg(&quot;world&quot;))      &#125;,      addNum() &#123;        // dispatch(&#123;        //   type: &quot;addNum&quot;,        // &#125;);        dispatch(addNum())      &#125;,    &#125;;  &#125;)(App);export default ReduxApp;\n\n（2）hook 方式/* App2.js */// hook 方式只能用于 toolkit，只能用于 函数组件import &#123; useSelector, useDispatch &#125; from &quot;react-redux&quot;;import &#123; addNum &#125; from &quot;./store/toolkitIndex&quot;;function App2() &#123;  // 取出 state  let num = useSelector((state) =&gt; &#123;    console.log(&quot;state&quot;, state);    return state.numReducer.num;  &#125;);  let dispatch = useDispatch()  return (    &lt;&gt;      &lt;div&gt;&#123;num&#125;&lt;/div&gt;      &lt;button onClick=&#123;()=&gt; &#123;        // dispatch(&#123;        //   type: &quot;numSlice/addNum&quot;        // &#125;)        dispatch(addNum())      &#125;&#125;&gt;增加&lt;/button&gt;    &lt;/&gt;  );&#125;export default App2;\n\n5、异步操作/* toolkitIndex.js */import &#123;  createSlice,  configureStore,  createAsyncThunk,&#125; from &quot;@reduxjs/toolkit&quot;;// 异步操作// 第一个参数名字// 第二个参数好似具体的异步操作export let changeNumThunk = createAsyncThunk(  &quot;numSlice/changeNum&quot;,  async (params) =&gt; &#123;    let res = await new Promise((resolve) =&gt; &#123;      console.log(&quot;params&quot;, params);      setTimeout((state, action) =&gt; &#123;        resolve(999);      &#125;, 1000);    &#125;);    return res;  &#125;);let msgSlice = createSlice(&#123;  name: &quot;msgSlice&quot;,  initialState: &#123;    msg: &quot;hello&quot;,  &#125;,  reducers: &#123;    changeMsg(state, action) &#123;      state.msg = action.payload;    &#125;,  &#125;,&#125;);let numSlice = createSlice(&#123;  name: &quot;numSlice&quot;,  initialState: &#123;    num: 0,  &#125;,  reducers: &#123;    addNum(state) &#123;      state.num++;    &#125;,  &#125;,    extraReducers: (chunk) =&gt; &#123;      chunk        .addCase(changeNumThunk.pending, () =&gt; &#123;          console.log(&quot;pending&quot;);        &#125;)        .addCase(changeNumThunk.fulfilled, (state, action) =&gt; &#123;          console.log(&quot;fulfilled&quot;);          state.num = action.payload;        &#125;);    &#125;,&#125;);export let &#123; changeMsg &#125; = msgSlice.actions;export let &#123; addNum &#125; = numSlice.actions;let store = configureStore(&#123;  reducer: &#123;    msgReducer: msgSlice.reducer,    numReducer: numSlice.reducer,  &#125;,&#125;);export default store;\n\n/* App.js */import store from &quot;./store/toolkitIndex&quot;;import &#123; connect &#125; from &quot;react-redux&quot;;import &#123; changeMsg, addNum, changeNumThunk &#125; from &quot;./store/toolkitIndex&quot;;function App(props) &#123;  console.log(&quot;props&quot;, props);  return (    &lt;&gt;      &lt;div&gt;&#123;props.msg&#125;&lt;/div&gt;      &lt;div&gt;&#123;props.num&#125;&lt;/div&gt;      &lt;button        onClick=&#123;() =&gt; &#123;          console.log(&quot;store.getState()&quot;, store.getState());          props.changeMsg();        &#125;&#125;      &gt;        修改 state      &lt;/button&gt;      &lt;button        onClick=&#123;() =&gt; &#123;          console.log(&quot;store.getState()&quot;, store.getState());          props.addNum();        &#125;&#125;      &gt;        增加 num      &lt;/button&gt;      &lt;button        onClick=&#123;() =&gt; &#123;          props.changeNumThunk();        &#125;&#125;      &gt;        异步修改      &lt;/button&gt;    &lt;/&gt;  );&#125;// connect 第一个参数是 state 的映射，即需要把哪些 state 映射到该组件的 props 里// connect 第二个参数是方法的映射，即需要给 props 加入的方法let ReduxApp = connect(  (state) =&gt; &#123;    console.log(&quot;state&quot;, state);    return &#123;      msg: state.msgReducer.msg,      num: state.numReducer.num,    &#125;;  &#125;,  (dispatch) =&gt; &#123;    return &#123;      changeMsg() &#123;        // dispatch(&#123;        //   type: &quot;changeMsg&quot;,        //   payload: &quot;world&quot;,        // &#125;);        // toolkit 的触发方法        dispatch(changeMsg(&quot;world&quot;));      &#125;,      addNum() &#123;        // dispatch(&#123;        //   type: &quot;addNum&quot;,        // &#125;);        dispatch(addNum());      &#125;,      changeNumThunk() &#123;        dispatch(changeNumThunk(1));      &#125;,    &#125;;  &#125;)(App);export default ReduxApp;\n\n十七、React 路由权限控制/* index.js */import React from &quot;react&quot;;import ReactDOM from &quot;react-dom/client&quot;;import &quot;./index.css&quot;;import App from &quot;./App&quot;;import reportWebVitals from &quot;./reportWebVitals&quot;;import &#123; BrowserRouter &#125; from &quot;react-router-dom&quot;;const root = ReactDOM.createRoot(document.getElementById(&quot;root&quot;));root.render(  // &lt;React.StrictMode&gt;  &lt;BrowserRouter&gt;    &lt;App /&gt;  &lt;/BrowserRouter&gt;  // &lt;/React.StrictMode&gt;);reportWebVitals();\n\n/* App.js */import &#123; Routes &#125; from &quot;react-router-dom&quot;;import &#123; createRoute &#125; from &quot;./router/createRoute&quot;;import routerArr from &quot;./router/routerArr&quot;;function App() &#123;  console.log(&quot;createRoute(routerArr)&quot;, createRoute(routerArr));  return (    &lt;&gt;      &lt;Routes&gt;&#123;createRoute(routerArr)&#125;&lt;/Routes&gt;    &lt;/&gt;  );&#125;export default App;\n\n/* createRoute.js */import &#123; Route &#125; from &quot;react-router-dom&quot;;export function createRoute(routerArr, parentPath = &quot;&quot;) &#123;  return routerArr.map((item) =&gt; &#123;    // 生成唯一的 key    const uniqueKey = parentPath ? `$&#123;parentPath&#125;-$&#123;item.path&#125;` : item.path;    if (item.children &amp;&amp; item.children.length &gt; 0) &#123;      return (        &lt;Route key=&#123;uniqueKey&#125; path=&#123;item.path&#125; element=&#123;&lt;item.component /&gt;&#125;&gt;          &#123;createRoute(item.children, item.path)&#125;        &lt;/Route&gt;      );    &#125; else &#123;      return (        &lt;Route key=&#123;uniqueKey&#125; path=&#123;item.path&#125; element=&#123;&lt;item.component /&gt;&#125; /&gt;      );    &#125;  &#125;);&#125;\n\n/* routerArr.js */import Page1 from &quot;../Page1&quot;;import Page2 from &quot;../Page2&quot;;import Page3 from &quot;../Page3&quot;;import Page2Son1 from &quot;../Page2Son1&quot;;import Page2Son2 from &quot;../Page2Son2&quot;;export default [  &#123;    path: &quot;/page1&quot;,    component: Page1,  &#125;,  &#123;    path: &quot;/page2&quot;,    component: Page2,    children: [      &#123;        path: &quot;son1&quot;,        component: Page2Son1,      &#125;,      &#123;        path: &quot;son2&quot;,        component: Page2Son2,      &#125;,    ],  &#125;,  &#123;    path: &quot;/page3&quot;,    component: Page3,  &#125;,];\n\n十八、组件库等相关生态1、React 组件库最常用：PC 端 - Ant Design，移动端 - Ant Design Mobile\n/* index.js */import React from &quot;react&quot;;import ReactDOM from &quot;react-dom/client&quot;;import &quot;./index.css&quot;;import App from &quot;./App&quot;;import reportWebVitals from &quot;./reportWebVitals&quot;;import &#123; ConfigProvider &#125; from &quot;antd&quot;;const root = ReactDOM.createRoot(document.getElementById(&quot;root&quot;));root.render(  &lt;React.StrictMode&gt;    &lt;ConfigProvider      theme=&#123;&#123;        token: &#123;          colorPrimary: &quot;#666&quot;,        &#125;,      &#125;&#125;    &gt;      &lt;App /&gt;    &lt;/ConfigProvider&gt;  &lt;/React.StrictMode&gt;);reportWebVitals();\n\n/* App.js */import &#123; Button &#125; from &quot;antd&quot;;import &#123; Table &#125; from &quot;antd&quot;;import &#123; useMemo &#125; from &quot;react&quot;;function App() &#123;  let arr = [    &#123;      id: 0,      name: &quot;name1&quot;,      status: 0,    &#125;,    &#123;      id: 1,      name: &quot;name2&quot;,      status: 1,    &#125;,    &#123;      id: 2,      name: &quot;name3&quot;,      status: 0,    &#125;,  ];  let columns = useMemo(() =&gt; &#123;    return [      &#123;        title: &quot;名字&quot;,        dataIndex: &quot;name&quot;,      &#125;,      &#123;        title: &quot;状态&quot;,        dataIndex: &quot;status&quot;,        render(status) &#123;          console.log(&quot;status1&quot;, status); // 0 1 2          return &lt;&gt;&#123;status === 0 ? &lt;span&gt;在校&lt;/span&gt; : &lt;span&gt;已休学&lt;/span&gt;&#125;&lt;/&gt;;        &#125;,      &#125;,      &#123;        title: &quot;操作&quot;,        render(status) &#123;          console.log(&quot;status2&quot;, status); // 没有 dataIndex，整列数据          return (            &lt;&gt;              &lt;Button type=&quot;primary&quot;&gt;增加&lt;/Button&gt;              &lt;Button&gt;删除&lt;/Button&gt;            &lt;/&gt;          );        &#125;,      &#125;,    ];  &#125;);  return (    &lt;&gt;      &lt;Button&gt;按钮&lt;/Button&gt;      &lt;Table columns=&#123;columns&#125; dataSource=&#123;arr&#125; rowKey=&quot;id&quot;&gt;&lt;/Table&gt;    &lt;/&gt;  );&#125;export default App;\n\n2、应用框架最常用：umi\nnpm i pnpm -gpnpm dix create-umi@latest\n","categories":["React - 基础课程"],"tags":["React"]},{"title":"IB-Rust-环境搭建","url":"/2025/05/20/59-IB-Rust-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","content":"Codes in lesson1.1: hello_world\nCodes in lesson1.2: hello_cargo\n一、Rust 介绍1、内存安全不允许空指针和悬空指针，可预防 C++ 中的许多类型错误\n2、静态类型编译器必须在编译期知道所有变量的类型\n在编译器能推导变量类型的情况下，不需要手动为变量指定类型\n3、并发编程使开发者能编写高效、安全的多线程程序，避免数据竞争等并发问题\n二、环境搭建1、安装通过 rustup 下载 Rust\ncurl --proto &#x27;=https&#x27; --tlsv1.2 -sSf https://sh.rustup.rs | sh\n\n检查是否正确安装 Rust\nrustc --version\n\n2、rustup 命令（1）升级 rust 工具链和 rustup 本身rustup update\n（2）卸载 rustrustup self uninstall\n（3）打开离线文档rustup doc\n三、vscode 配置1、rust-analyzer\n2、even-better-toml\n3、crates（已无法使用，换成了 Dependi）\n四、hello worldrust 文件以 .rs 结尾，如 main.rs\nfn main() &#123;    println!(&quot;Hello, world!&quot;);&#125;\n\n1、编译rustc main.rs\n\n编译成功后输出一个二进制可执行文件 main\n2、运行rust 是 预编译静态类型（ahead-of-time compiled）语言，即一旦拥有了编译后的可执行文件，不需要安装 Rust 即可运行\n./main\n\n五、cargo1、初始化项目cargo new hello_cargocd hello_cargo\n\n其中的 Cargo.toml 文件包含：\n[package]name = &quot;hello_cargo&quot;version = &quot;0.1.0&quot;edition = &quot;2024&quot;[dependencies]\n\n[package]\n\n项目名称\n项目版本\nRust 版本\n\n[dependencies]\n项目依赖，Rust 中的代码包为 crates\n2、构建并运行（1）构建cargo build\n\n创建可执行文件 target&#x2F;debug&#x2F;hello_cargo\n（2）运行./target/debug/hello_cargo\n\n（3）构建并运行cargo run\n\n同时编译并运行生成的可执行文件，更方便\n（4）发布构建cargo build --release\n\n在 target&#x2F;release 下生成可执行文件，编译优化让 Rust 代码运行的更快，但消耗更长的编译时间\n两种构建对比：\n\ncargo build 用于开发，因为经常需要重新构建\n\ncargo build --release 用于为用户构建最终程序，不会经常重新构建，并希望程序运行得更快\n\n\n3、添加依赖crate 是一个 Rust 代码库，可以包含任意能被其他程序使用的代码，但不能自执行\n添加一个随机数的库（crate）：\n[dependencies]rand = &quot;0.8.5&quot;\n\n然后重新构建项目\n\n当增加了新依赖，Cargo 会从 Crates.io 获取依赖，并将指定的依赖版本写入 Cargo.lock 文件\n\nCargo.lock 文件\n确保任何人在任何时候重新构建代码，都会产生相同的结果，因为 Cargo 只会使用指定的依赖版本（类似 package-lock.json）\n\n\n如需升级 crate，cargo update 会忽略 Cargo.lock 文件，并计算出所有符合 Cargo.toml 声明的最新版本，接着将其写入 Cargo.lock。\n但是 Cargo 只会寻找 0.8.x 的版本，假设 rand crate 发布了 0.8.6 和 0.9.0 两个新版本，运行 cargo update 后会升级到 0.8.6 而不是 0.9.0。这是因为 0.9.0 相对于 0.8.5 主版本发生了变化。\n如需升级到 0.9.x 版本，更新 Cargo.toml 文件：\n[dependencies]rand = &quot;0.9.0&quot;\n\n4、配置国内镜像为了使用 crates.io 之外的注册服务，需要对 $HOME/.cargo/config.toml 文件进行配置，添加新的服务提供商\n\ncargo v1.68 开始支持稀疏索引：不需要完整克隆 crates.io-index 仓库，加快获取包的速度\n\n\n协议推荐使用 git，如配置 git 协议后无法正常获取和编译 crate，可以换 https 协议试试\n\n两种实现方式：增加新的镜像地址 和 覆盖默认的镜像地址\n（1）增加新的镜像地址如果支持稀疏索引：\n### https，任选一种即可[registries]ustc = &#123; index = &quot;sparse+https://mirrors.ustc.edu.cn/crates.io-index/&quot; &#125;[registries.ustc]index = &quot;sparse+https://mirrors.ustc.edu.cn/crates.io-index/&quot;### git，任选一种即可[registries]ustc = &#123; index = &quot;sparse+git://mirrors.ustc.edu.cn/crates.io-index/&quot; &#125;[registries.ustc]index = &quot;sparse+git://mirrors.ustc.edu.cn/crates.io-index/&quot;\n\n\n这种方式只会新增一个新的镜像地址，因此在引入依赖的时候，需要指定该地址，例如在项目中引入 time 包，你需要在 Cargo.toml 中使用以下方式引入:\n[dependencies]rand = &#123;  registry = &quot;ustc&quot; &#125;\n\n（2）【推荐】覆盖默认的镜像地址这种方式不需要修改 Cargo.toml 文件，因为它会直接使用新注册服务替代默认的 crates.io。\n在 $HOME/.cargo/config.toml 添加以下内容：\n[source.crates-io]replace-with = &#x27;ustc&#x27;[source.ustc]registry = &quot;https://mirrors.ustc.edu.cn/crates.io-index/&quot;\n\n创建一个新的镜像源 [source.ustc]，然后将默认的 crates-io 替换成新的镜像源：replace-with = &#39;ustc&#39;\n\n可用镜像列表：\n# 中科大&quot;https://mirrors.ustc.edu.cn/crates.io-index/&quot;&quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;# 清华&quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git/&quot;# 字节&quot;https://rsproxy.cn/crates.io-index/&quot;\n","categories":["Rust - IB课程"],"tags":["Rust"]},{"title":"vue class 与 style 绑定","url":"/2023/11/28/6-vue%20class%E4%B8%8Estyle%E7%BB%91%E5%AE%9A/","content":"绑定一个返回对象的计算属性const isActive = ref(true);const error = ref(null);const classObject = computed(() =&gt; (&#123;    active: isActive.value &amp;&amp; !error.value,    &#x27;text-danger&#x27;: error.value &amp;&amp; error.value.type === &#x27;fatal&#x27;&#125;));\n\n&lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt;\n\n子组件继承父组件传入的class有一个根元素的组件子组件的根元素，在渲染时会添加父组件的 class。\n有多个根元素的组件子组件中 :class=&#39;$attrs.class&#39; 的根元素，在渲染时会添加父组件的 class。\n&lt;!-- 子组件 MyComponent.vue --&gt;&lt;p :class=&quot;$attrs.class&quot;&gt;one root element&lt;/p&gt;&lt;span&gt;another root element&lt;/span&gt;\n\n&lt;!-- 父组件 --&gt;&lt;MyComponent class=&quot;fatherClass&quot;/&gt;\n\n渲染后结果：\n&lt;p class=&quot;fatherClass&quot;&gt;one root element&lt;/p&gt;&lt;span&gt;another root element&lt;/span&gt;\n\n內联样式绑定对象const styleObject = reactive(&#123;    color: &quot;red&quot;,    fontSize: &quot;13px&quot;&#125;);\n\n&lt;div :style=&quot;styleObject&quot;&gt;&lt;/div&gt;\n\n绑定对象数组&lt;div :style=&quot;[baseStyle, overriddingStyle]&quot;&gt;&lt;/div&gt;\n\nconst baseStyle = reactive(&#123;    color: &quot;red&quot;,    ...&#125;);const overriddingStyle = reactive(&#123;    color: &quot;black&quot;,    ...&#125;);\n","categories":["vue - 样式","vue3 - 文档"],"tags":["vue3","vue"]},{"title":"IB-Rust-变量&可变类型","url":"/2025/05/20/60-IB-Rust-%E5%8F%98%E9%87%8F&%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B/","content":"Codes in lesson2\n一、可变 &amp; 不可变变量（Mutable &amp; Immutable）Rust 的变量默认不可改变（immutable），如果想改变，需要声明可变变量（mutable）\n1、声明不可变变量let x = 5;\n\n2、声明可变变量let mut x = 5;x = 6;\n\n二、常量（Constants）Rust 中用 const 关键字定义一个常量，定义时需要指定其数据类型\n常量的特点：\n必须指定数据类型\n常量名使用大写字母，否则会 warning\n必须使用常量表达式赋值，即编译期能计算出的值\n不支持重定义（遮蔽）\n\n\n常量与不可变变量的区别？\n\n常量使用 const 声明，不可变变量使用 let 声明\n常量的值不能在运行时改变，不可变变量在运行期才确定\n常量不可修改，不可变变量可通过重定义（shadowing）修改\n常量必须声明类型\n常量必须使用大写字母\n\n\n三、静态变量\n静态变量使用 static 关键字声明，在编译时分配内存，并在程序运行期间一直存在\n静态变量可以在整个程序中共存，并可以在多个线程之间共享\n静态变量的值在运行期间不会改变，常用于存储程序的全局状态\n\n\n静态变量与常量的异同\n相似性：\n\n名称要求使用大写，否则 warning\n必须指定类型\n必须使用常量表达式赋值，即编译期能计算出的值\n都不支持重定义（shadowing）\n\n不同点：\n常量值直接嵌入代码，无独立存储，而静态变量存储在静态内存区，独立占用内存常量不可变，而静态变量和普通变量一样，默认不可变，但可以通过 mut 关键字定义为可变（必须在 unsafe{} 中）变量用于数学常数、固定配置，静态变量用于全局状态管理、跨线程共享数据\n\n四、作用域 &amp; 遮蔽（variable &amp; shadowing）变量绑定在一个作用域（scope）中，即被限定只在一个代码块（block）中生存（live）\n变量遮蔽（variable shadowing）即重定义\n","categories":["Rust - IB课程"],"tags":["Rust"]},{"title":"IB-Rust-函数","url":"/2025/05/21/61-IB-Rust-%E5%87%BD%E6%95%B0/","content":"Codes in lesson3\n函数组成\n声明函数的关键字 fn\n函数名 add()\n参数 i 和 j和参数类型i32\n返回值类型i32\n函数体i + j \n\n注意：函数可以在任意位置定义\n函数名开头是字符&#x2F;下划线，后面是数字，下划线，字母（不能仅有下划线）\n函数名和变量名使用蛇形命名法（snake case），如：fn add_two() -&gt; &#123;&#125;\n函数参数Rust 是强类型语言，需要为所有函数参数标识具体类型\n函数返回函数返回值是函数体最后一条表达式的返回值，也可以使用 return 提前返回，初学者只需记住两种形态：\n// 没有return + 没有分号fn add(i: i32, j: i32) -&gt; i32 &#123;    i + j&#125;// return + 分号fn add(i: i32, j: i32) -&gt; i32 &#123;    return i + j;&#125;\n\n特殊返回类型1、无返回值()如果一个函数没有返回值，就返回()\nfn print(i: i32) &#123;    println!(&quot;&#123;&#125;&quot;, i);&#125;fn print(i: i32) -&gt; () &#123;    println!(&quot;&#123;&#125;&quot;, i);&#125;\n\n2、函数永不返回函数返回类型为!时，表示该函数永不返回（diverge function），常用做会导致程序崩溃的函数：\nfn dead_end() -&gt; ! &#123;  panic!(&quot;崩溃&quot;);&#125;\n\n下面的函数创建了一个无限循环，也永不返回：\nfn forever() -&gt; ! &#123;  loop &#123;    //...  &#125;;&#125;\n\n练习题https://practice-zh.course.rs/basic-types/functions.html\n","categories":["Rust - IB课程"],"tags":["Rust"]},{"title":"IB-Rust-流程控制","url":"/2025/05/21/62-IB-Rust-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","content":"Codes in lesson4\n条件控制if 表达式Rust 不会自动将非布尔值转换为布尔值，必须显式使用布尔值作为 if 的条件\n使用 else if 处理多重条件只会执行第一个条件为 true 的代码块\n在 let 语句中使用 if声明的变量将会绑定到表示 if 表达式结果的值上\n\nif 的每个分支可能的返回值必须是相同类型\n代码块的值是其最后一个表达式的值，即不需要分号\n\n循环Rust 有三种循环：loop、while 和 for\nloop运行时会出现反复打印的 again!，直到手动停止程序：\nfn main() &#123;    loop &#123;        println!(&quot;again!&quot;);    &#125;&#125;\n\nbreak &amp; continuebreak 关键字告诉程序停止循环\ncontinue 关键字告诉程序继续循环\n从循环返回值和 if 类似，loop 也能赋值\nfn main() &#123;    let mut counter = 0;    let result = loop &#123;        counter += 1;        if counter == 10 &#123;            break counter * 2;        &#125;    &#125;;    println!(&quot;The result is &#123;result&#125;&quot;);&#125;\n\n循环标签break + 循环标签 可以退出外层循环\nfn main() &#123;    let mut count = 0;    &#x27;counting_up: loop &#123;        println!(&quot;count = &#123;count&#125;&quot;);        let mut remaining = 10;        loop &#123;            println!(&quot;remaining = &#123;remaining&#125;&quot;);            if remaining == 9 &#123;                break;            &#125;            if count == 2 &#123;                break &#x27;counting_up;            &#125;            remaining -= 1;        &#125;        count += 1;    &#125;    println!(&quot;End count = &#123;count&#125;&quot;);&#125;\n\nwhile 条件循环条件为 true 执行循环，条件不为 true 停止循环\nfn main() &#123;    let mut number = 3;    while number != 0 &#123;        println!(&quot;&#123;number&#125;!&quot;);        number -= 1;    &#125;    println!(&quot;LIFTOFF!!!&quot;);&#125;\n\n用 loop 实现fn main() &#123;    let mut number = 3;    loop &#123;        if number == 0 &#123;            break;        &#125;        println!(&quot;&#123;number&#125;!&quot;);        number -= 1;    &#125;    println!(&quot;LIFTOFF!!!&quot;);&#125;\n\nforfn main() &#123;    let a = [10, 20, 30, 40, 50];    for element in a &#123;        println!(&quot;the value is: &#123;element&#125;&quot;);    &#125;&#125;\n\n倒序输出 [1, 2, 3]，结果为 3, 2, 1：\nfn main() &#123;    for number in (1..4).rev() &#123;        println!(&quot;&#123;number&#125;!&quot;);    &#125;&#125;\n\n所有权转移\n对于实现了 copy 特征的数组（如 [i32; 10]）而言，for item in arr 不会转移 arr 的所有权，而是对其进行了拷贝，因此循环之后仍可以使用 arr \n\n\n\n\n使用方法\n等价使用方式\n所有权\n\n\n\nfor item in collection\nfor item in IntoIterator::into_iter(collection)\n转移所有权\n\n\nfor item in &amp;collection\nfor item in collection.iter()\n不可变借用\n\n\nfor item in &amp;mut collection\nfor item in collection.iter_mut()\n可变借用\n\n\n练习题https://practice-zh.course.rs/flow-control.html\n","categories":["Rust - IB课程"],"tags":["Rust"]},{"title":"IB-Rust-基础类型","url":"/2025/05/21/63-IB-Rust-%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/","content":"Codes in lesson5\n整型根据数据大小和有无符号对整数进行分类：\n\n\n\n大小\n有符号\n无符号\n\n\n\n8位\ni8\nu8\n\n\n16位\ni16\nu16\n\n\n32位\ni32\nu32\n\n\n64位\ni64\nu64\n\n\n128位\ni128\nu128\n\n\n视架构而定\nisize\nusize\n\n\n整型字面量可以用下表的形式书写\n\n\n\n数字字面量\n示例\n\n\n\n十进制\n98_222\n\n\n十六进制\n0xff\n\n\n八进制\n0o77\n\n\n二进制\n0b1111_0000\n\n\n字节\n（仅限 u8）b’A’\n\n\n浮点数浮点类型数字是有小数点的数字，rust 的浮点类型数字有两种基本类型：f32 和 f64\n默认浮点类型是 f64，在现代 CPU 中它的速度与 f32 几乎相同，但精度更高\n\nNaN 是什么？\n对于数学上未定义的结果，如负数开平方根，rust 的浮点数类型会使用 NAN 来处理。任何与 NaN 交互的操作都返回 NaN，且 NaN 不能用于比较（如断言），否则会导致程序崩溃\n\n布尔型布尔型有 true 和 false 两个值，占用1个字节的内存\n字符Rust 的字符不仅是 ASCII，所有的 Unicode 值都可以作为 Rust 字符，包括中日韩文、emoji等\n字节类型占用4个字节\n序列Rust 可以生成连续的数值，比如：1..5 生成从 1到4 的连续数字；1..=5 生成从 1到5 的连续数字\n序列常用于循环\n类型强制转换as 关键字用于在原始类型之间进行类型转换，而复合类型的转换通常需要使用其他方法或函数\n","categories":["Rust - IB课程"],"tags":["Rust"]},{"title":"IB-Rust-所有权","url":"/2025/05/22/64-IB-Rust-%E6%89%80%E6%9C%89%E6%9D%83/","content":"Codes in lesson6\n内存回收Rust 的设计目的是确保内存安全并防止数据竞争，而不依赖垃圾回收器，这种内存安全性主要通过所有权（ownership）来实现\n主流编程语言的内存回收机制：\n\n静态语言\n在编译时对变量类型进行检查和确认\nC, C++, Rust\n\n\n动态语言\n在运行时进行类型检查和确认\nJavascript, Python\n\n\n\n\n\n\n特性\n静态语言\n动态语言\n\n\n\n类型检查时间\n编译时\n运行时\n\n\n类型安全\n更安全，减少运行时类型错误\n较灵活，但类型错误可能在运行时出现\n\n\n性能\n通常更高效，编译器优化\n通常较低，运行时类型检查\n\n\n灵活性\n较低，需明确声明类型\n较高，允许在运行时改变类型\n\n\n代码简洁性\n需要显式类型声明，代码相对冗⻓\n通常更简洁，适合快速开发\n\n\n开发工具支持\n更强大的静态分析和重构工具\n开发工具支持有限，但在快速开发上占优势\n\n\nC&#x2F;C++\n内存管理方式：手动管理\n特点\n程序员通过 malloc 和 free (C) 或 new 和 delete (C++) 释放内存\n没有内置的垃圾回收机制\n\n\n优点：高效灵活，适用于对性能要求极高的系统级编程\n缺点：容易出现内存泄漏、悬垂指针和缓冲区溢出等问题\n\n// 释放分配的内存free(ptr);ptr = NULL; // 将指针设为 NULL，避免悬空指针 // 动态分配一个数组的内存int n = 5;int *arr = (int *)malloc(n * sizeof(int));\n\nJavascript\n内存管理方式：垃圾回收\n特点\n浏览器和 Node.js 环境中均使用垃圾回收器（如 V8 引擎的垃圾回收器）\n采用标记-清除、标记-压缩等算法\n\n\n优点：自动内存管理，适合快速开发和运行在多平台上的应用\n缺点：垃圾回收机制在某些情况下可能导致性能问题，如线程停顿\n\nRust\n内存管理方式：所有权系统\n特点\n使用所有权系统进行内存管理，编译器在编译时通过静态分析来确保内存安全\n每个值都有一个所有者，且任何时候只能有一个有效的所有者\n通过借用（引用）机制来共享数据，避免数据竞争和悬垂指针\n\n\n优点\n在编译时保证内存安全，没有运行时开销\n避免了数据竞争和悬垂指针\n\n\n缺点：需要程序员理解和遵循所有权和借用规则，学习曲线较陡\n\n所有权规则Rust 所有权系统的三个基本规则：\n\n每一个值都有一个所有者（owner）\n在任一时刻，值只能有一个所有者\n当所有者离开作用域（scope），值会被丢弃（drop）\n\n课后习题用 2 种方式实现，确保 s1 s2 都能正常打印出来\n// TODO:fn take_ownership(s: String) -&gt; String &#123;    s&#125;let s1 = String::from(&quot;Hello&quot;);let s2 = take_ownership(s1);// 如下代码不能修改println!(&quot;&#123;&#125;&quot;, s1);println!(&quot;&#123;&#125;&quot;, s2);\n\n方式一：借用fn take_ownership(s: &amp;String) -&gt; String &#123;    s.clone()&#125;fn main() &#123;    let s1 = String::from(&quot;Hello&quot;);    let s2 = take_ownership(&amp;s1);    // 如下代码不能修改    println!(&quot;&#123;&#125;&quot;, s1);    println!(&quot;&#123;&#125;&quot;, s2);&#125;\n\n方式二：调用时 clonefn take_ownership(s: &amp;String) -&gt; &amp;String &#123;    s&#125;fn main() &#123;    let s1 = String::from(&quot;Hello&quot;);    let s2 = take_ownership(&amp;s1);    // 如下代码不能修改    println!(&quot;&#123;&#125;&quot;, s1);    println!(&quot;&#123;&#125;&quot;, s2);&#125;\n","categories":["Rust - IB课程"],"tags":["Rust"]},{"title":"IB-Rust-引用","url":"/2025/05/22/65-IB-Rust-%E5%BC%95%E7%94%A8/","content":"Codes in lesson7\n引用的分类\n不可变引用（Immutable Reference）\n可以读取数据，但不能修改\n一个变量可以有多个不可变引用，但不能与可变引用共存\n\n\n可变引用（Mutable Reference）\n可以读取和修改数据\n一个变量在某一时刻只能有一个可变引用，且不能与不可变引用共存\n\n\n\n借用的规则\n同一时间内，一个变量只能有一个可变引用或多个不可变引用\n引用必须总是有效（被引用的数据在其引用的生命周期内必须始终存在，且不能被销毁）\n\nmove &amp; borrow &amp; slicemove当​堆数据被赋值给另一个变量或作为参数传递时，其所有权会 ​​转移​​（move）到新变量或函数中，原变量将失效\nborrow借用是 Rust 中通过引用 ​​临时访问数据​​ 的逻辑概念\nslice切片（slices）分为：\n字符串切片let s = String::from(&quot;hello world&quot;);let hello = &amp;s[0..5]; // 引用 &quot;hello&quot;let world = &amp;s[6..11]; // 引用 &quot;world&quot;\n\n数组切片let arr = [1, 2, 3, 4, 5];let slice = &amp;arr[1..3]; // 引用 [2, 3]\n\n课后习题通过编译器错误提示，修复并运行代码\n#[test]fn test_lifetime() &#123;    let large = longest(&quot;a&quot;, &quot;ab&quot;);    println!(&quot;large one is &#123;large&#125;&quot;);    // expected named lifetime parameter    fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str &#123;        if x.len() &gt; y.len() &#123;          x        &#125; else &#123;          y        &#125;    &#125;&#125;\n\n如果函数返回引用，且该引用依赖于输入参数的引用，必须显式标注生命周期参数\n#[test]\nfn test_lifetime() &#123;\n    let large = longest(&quot;a&quot;, &quot;ab&quot;);\n    println!(&quot;large one is &#123;large&#125;&quot;);\n    // modified\n    fn longest&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; &amp;&#39;a str &#123;\n        if x.len() &gt; y.len() &#123;\n          x\n        &#125; else &#123;\n          y\n        &#125;\n    &#125;\n&#125;\n\n","categories":["Rust - IB课程"],"tags":["Rust"]},{"title":"IB-Rust-数组与切片","url":"/2025/05/22/66-IB-Rust-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/","content":"Codes in lesson8\n数组介绍[T; N] 表示 N 个值的数组，每个值的类型为 T。数组的大小是在编译期就已确定的常量，并且是类型的一部分，不能追加新元素或缩小数组\n任意一种类型的值 v，表达式 v.len() 会给出 v 中的元素数，v[i] 引用的是 v 的第 i 个元素（i 的类型必须是 usize）。Rust 会检查 i 是否在 0～v.len()-1 的范围内，如果没在则会出现 panic\n数组切片介绍&amp;[T] 和 &amp;mut [T] 可称为 T 的共享切片和 T 的可变切片，它们是对一系列元素的引用，这些元素是某个其他值（如：数组或向量）的一部分\n可以将切片视为指向其第一个元素的指针，以及从该点开始允许访问的元素数量的计数\n可变切片 &amp;mut [T] 允许读取和修改元素，但不能共享；共享切片 &amp;[T] 允许在多个读取者之间共享访问权限，但不允许修改\n数组\n数组是一段分配的连续的相同数据类型的内存块\n\n数组是静态的，一旦定义和初始化（为数组中每个元素赋值），则长度不可更改\n\n数组的元素有相同的数据类型，每个元素都独占数据类型大小的内存块，即数组的内存大小等于数组长度乘数组的数据类型大小\n\n数组中每个元素都按顺序依次存储，数组下标既代表元素的存储位置，也是数组元素的唯一标识\n\n可以更新或修改数组元素的值，但不能删除数组元素。如果要删除，可将值赋为表示删除的值（比如 0）\n\n\n切片切片（Slice）表示从包含多个元素的容器中取得局部数据，Rust 有三种数据类型支持 Slice 操作：String、Array 和 Vec\nRust 中的切片操作只允许获取一段连续的局部数据，该数据称作切片数据。而有些语言可以取得离散元素，甚至有些语言可以对 hash 结构进行切片操作\n切片常用函数\nlen()：slice 元素个数\nis_empty()：判断 slice 是否为空\ncontains()：判断是否包含某个元素\nrepeat()：重复 slice 指定次数\nreverse()：反转 slice\njoin()：将各元素压平（flatten）并通过指定的分隔符连接起来\nswap()：交换两个索引处的元素\nwindows()：以指定大小的窗口进行滚动迭代\nstarts_with()：判断 slice 是否以某个 slice 开头\n\n课后习题\n给定一个整数数组 nums，返回一个数组 answer ，使得 answer[i] 等于 nums 除之外 nums[i] 的所有元素的乘积。任何前缀或后缀的乘积 nums 都保证适合 32 位整数。您必须编写一个能够及时运行 O(n) 且无需使用除法运算的算法。\n示例 1：输入： nums &#x3D; [1,2,3,4]输出： [24,12,8,6]\n示例 2：输入： nums &#x3D; [-1,1,0,-3,3]输出： [0,0,9,0,0]\n限制：2 &lt;&#x3D; nums.length &lt;&#x3D; 105-30 &lt;&#x3D; nums[i] &lt;&#x3D; 30任何前缀或后缀的乘积 nums 都保证适合 32 位整数。\n进阶： 你能以 O(1) 额外空间复杂度解决这个问题吗？（输出数组不算作空间复杂度分析的额外空间。）\n\nfn main() &#123;    let nums = [1, 2, 3, 4];    let answer = get_answer(nums.to_vec());    println!(&quot;answer is &#123;:?&#125;&quot;, answer); // [24, 12, 8, 6]&#125;fn get_answer(nums: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; &#123;    let n = nums.len();    let mut answer = vec![1; n];    // 计算前缀乘积：answer[i]    for i in 1..n &#123;        // nums[1, n-1] 的前缀乘积（nums[0] 没有前缀）        answer[i] = answer[i - 1] * nums[i - 1];    &#125;    // 计算后缀乘积，并更新 answer[i]    let mut right = 1; // right 表示当前元素右侧所有元素的乘积    for i in (0..n).rev() &#123;        // 从 nums[n-1..0] 的乘积        answer[i] *= right; // 前缀乘积 * 后缀乘积        right *= nums[i]; // 更新后缀乘积    &#125;    answer&#125;","categories":["Rust - IB课程"],"tags":["Rust"]},{"title":"v-for","url":"/2023/11/29/7-v-for/","content":"基础&lt;li v-for=&quot;(item, index) in items&quot;&gt;&lt;/li&gt;\n\n可以使用 of 代替 in：\n&lt;li v-for=&quot;(item, index) of items&quot;&gt;&lt;/li&gt;\n\n支持解构语法：\n&lt;li v-for=&quot;&#123;message&#125; in items&quot;&gt;    &#123;&#123; message &#125;&#125;&lt;/li&gt;&lt;li v-for=&quot;(&#123;message&#125;, index) in items&quot;&gt;    &#123;&#123; message &#125;&#125;&lt;/li&gt;\n\n遍历对象属性使用 v-for 遍历对象属性，遍历的顺序和 Object.keys() 返回值的顺序一致\n三个参数依次为 索引、属性名、属性值：\nconst myObject = reactive(&#123;  title: &#x27;How to do lists in Vue&#x27;,  author: &#x27;Jane Doe&#x27;,  publishedAt: &#x27;2016-04-10&#x27;&#125;);\n\n&lt;li v-for=&quot;(index, key, value) in myObject&quot;&gt;&#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/li&gt;\n\n结果为：\n0. title: How to do lists in Vue1. author: Jane Doe2. publishedAt: 2016-04-10\n\nv-for 与 v-ifv-if 比 v-for 优先级高\n错误用法：\n&lt;!-- 此时 v-if 的 todo 还没有定义 --&gt;&lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt;&#123;&#123; todo.name &#125;&#125;&lt;/li&gt;\n\n正确用法：\n&lt;template v-for=&quot;todo in todos&quot;&gt;   &lt;li v-if=&quot;!todo.isComplete&quot;&gt;   &#123;&#123; todo.name &#125;&#125;   &lt;/li&gt;&lt;/template&gt;\n\n通过 key 管理状态Vue 默认按照 “就地更新” 的策略更新通过 v-for 渲染的列表。当数据项的顺序改变时，Vue 不会随之移动 DOM 元素的顺序，而是就地更新每个元素，确保它们在原本指定的索引位置上渲染。\n默认模式是高效的，但只适用于 列表渲染输出的结果不依赖子组件状态或者临时 DOM 状态 (例如表单输入值) 的情况。\n推荐在任何时候为 v-for 提供一个 key attribute，除非所迭代的 DOM 内容非常简单。\n","categories":["vue - 文档"],"tags":["vue"]},{"title":"js 事件","url":"/2023/11/29/8-js%E4%BA%8B%E4%BB%B6/","content":"事件捕获和事件冒泡 是浏览器处理DOM元素事件的两种方式（顺序：先捕获，再冒泡）。\n&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;body&gt;      &lt;div&gt;click me&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\n事件捕获事件捕获从文档根节点开始，逐级向下传播到目标元素。\n点击 div，事件传播方向：document -&gt; html -&gt; body -&gt; div\n事件冒泡事件冒泡指当目标元素触发了某事件时，事件会从该元素开始逐级向上传播，直到文档根节点。\n点击 div，事件传播方向：div -&gt; body -&gt; html -&gt; document\n事件模型DOM0 事件模型DOM0 只在冒泡阶段处理事件处理程序。\n&lt;div onclick=&quot;handleClick&quot;&gt;click&lt;/div&gt;&lt;script&gt;  function handleClick() &#123;    alert(&#x27;clicked&#x27;);  &#125;&lt;/script&gt;\n\nDOM2 事件模型DOM2 在捕获阶段和冒泡阶段都可以处理事件处理程序（更灵活可控）。\n使用：addEventListener() 和 removeEventListener()\n&lt;div id=&quot;myBtn&quot;&gt;click&lt;/div&gt;&lt;script&gt;  function handleClick() &#123;    alert(&#x27;clicked&#x27;);  &#125;  const btn = document.getElementById(&#x27;myBtn&#x27;);  btn.addEventListener(&#x27;click&#x27;, handleClick);&lt;/script&gt;\n\nIE 事件模型功能类似于 DOM0，使用方式上类似于 DOM2。\n使用 attachEvent() 和 detachEvent() 方法。\n&lt;div id=&quot;myBtn&quot;&gt;click&lt;/div&gt;&lt;script&gt;  function handleClick() &#123;    alert(&#x27;clicked&#x27;);  &#125;  const btn = document.getElementById(&#x27;myBtn&#x27;);  btn.attachEvent(&#x27;click&#x27;, handleClick);&lt;/script&gt;\n\njs 实现事件修饰符阻止默认行为 preventDefault比如阻止链接的跳转或表单的提交\ndocument.getElementById(&#x27;btn&#x27;).addEventListener(&#x27;click&#x27;, (event) =&gt; &#123;  event.preventDefault();&#125;);\n\n阻止事件冒泡 stopPropagation()阻止事件传到父元素\ndocument.getElementById(&#x27;btn&#x27;).addEventListener(&#x27;click&#x27;, (event) =&gt; &#123;  event.stopPropagation();&#125;);\n\n一次性事件处理function handleClick(event) &#123;  this.removeEventListener(&#x27;click&#x27;, handleClick); // 点击一次移除监听器&#125;document.getElementById(&#x27;btn&#x27;).addEventListener(&#x27;click&#x27;, handleClick);\n\n获取键盘按键document.addEventListener(&#x27;keydown&#x27;, (event) =&gt; &#123;  console.log(event.key);&#125;);\n\n获取鼠标按键document.addEventListener(&#x27;mousedown&#x27;, (event) =&gt; &#123;  console.log(event.key);&#125;);\n","categories":["JavaScript - 事件"],"tags":["JavaScript"]},{"title":"vue 事件处理","url":"/2023/11/30/9-vue%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/","content":"v-on:click&#x3D;”” 缩写为 @click\n在內联事件处理器中访问事件参数在內联事件中访问原生 DOM 事件：\n向处理器中传入一个 $event 变量&lt;button @click=&quot;warn(&#x27;message1&#x27;, $event)&quot;&gt;Submit&lt;/button&gt;\n\n使用内联箭头函数&lt;button @click=&quot;(event) =&gt; warn(&#x27;message1&#x27;, event)&quot;&gt;Submit&lt;/button&gt;\n\nfunction warn(message, event) &#123;  // 在此处可以访问原生事件  if (event) &#123;    event.preventDefault()  &#125;  alert(message)&#125;\n\n事件修饰符\nstop：调用 event.stopPropagation()，阻止事件继续传播。\nprevent：调用 event.preventDefault()，阻止事件的默认行为。\nself：只当事件是从原始目标元素本身触发时触发回调，如果事件是从内部元素冒泡上来的则不触发。\ncapture：添加事件监听器时使用 capture 模式，即在捕获阶段触发而不是冒泡阶段。\nonce：只触发一次事件，之后移除该监听器。\npassive：提升页面滚动性能，告诉浏览器事件处理函数不会调用 event.preventDefault()。\n\n（1）.stop&lt;div @click.stop=&quot;handleOuterClick&quot;&gt;  &lt;button @click=&quot;handleInnerClick&quot;&gt;内部按钮&lt;/button&gt;&lt;/div&gt;\n\n当内部按钮被点击时，handleOuterClick 不会被触发，因为事件不会继续向外部元素传播。\n（2）.prevent&lt;form @submit.prevent=&quot;handleSubmit&quot;&gt;  &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;&lt;/form&gt;\n\nhandleSubmit 方法中的 event.preventDefault() 将会被调用，从而阻止表单的默认提交行为。\n（3）.self&lt;div @click.self=&quot;handleClick&quot;&gt;只有当点击该div本身时触发&lt;/div&gt;\n\n只有当点击该 div 元素本身时，handleClick 方法才会被触发；div 内部其他元素冒泡上来的事件不会触发。\n（4）.once&lt;button @click.once=&quot;handleClick&quot;&gt;点击我，只触发一次&lt;/button&gt;\n\n当按钮被点击后，handleClick 方法只会被触发一次，之后该事件监听器会被移除。\n（5）.capture&lt;div @click.capture=&quot;handleCaptureClick&quot;&gt;捕获阶段触发&lt;/div&gt;\n\n事件监听器将在捕获阶段（从外向内）触发，而不是在冒泡阶段触发。\n（6）.passive&lt;div @touchstart.passive=&quot;handleTouchStart&quot;&gt;优化页面滚动性能&lt;/div&gt;\n\n告诉浏览器 handleTouchStart 方法不会调用 event.preventDefault()，从而有助于提升页面滚动的性能。\n按键修饰符中的 .enter 就是按键修饰符。### 常规按键- enter- tab- delete (捕获“Delete”和“Backspace”两个按键)- esc- space- up- down- left- right### 系统按键系统按键和常规按键不同的是，与 keyup 一起使用时，只有当系统按键被 **按下** 并松开其他键才会触发。- ctrl- alt- shift- meta举例：``` html&lt;!-- 常规按键 --&gt;&lt;!-- 当 Alt + Enter 抬起时，触发 submit 事件 --&gt;&lt;input @keyup.alt.enter=&quot;submit&quot; /&gt;&lt;!-- 系统按键 --&gt;&lt;!-- 当 按下 ctrl 时触发 --&gt;&lt;div @click.ctrl=&quot;doSth&quot;&gt;A&lt;/div&gt;&lt;!-- 当 按住 ctrl + 抬起其他键 时触发 --&gt;&lt;div @keyup.ctrl=&quot;doSth&quot;&gt;A&lt;/div&gt;\n\n.exact 修饰符.exact 用于确定触发事件的确定组合。\n举例：\n&lt;!-- 当抬起 Ctrl 时，即使同时抬起其他系统按键也会触发 --&gt;&lt;button @keyup.ctrl=&quot;doSth&quot;&gt;A&lt;/button&gt;&lt;!-- 仅当抬起 Ctrl 且未抬起任何其他键时才会触发 --&gt;&lt;button @keyup.ctrl.exact=&quot;doSth&quot;&gt;A&lt;/button&gt;&lt;!-- 仅当没有抬起任何系统按键时触发 --&gt;&lt;button @keyup.exact=&quot;doSth&quot;&gt;A&lt;/button&gt;\n","categories":["vue - 文档"],"tags":["vue"]},{"title":"IB-Rust-字符串","url":"/2025/05/23/67-IB-Rust-%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"Codes in lesson9\n字符串的定义字符串是由字符组成的连续集合\nRust 中的字符是 Unicode 类型，因此每个字符占据 4 字节内存空间，但字符串是 UTF-8 编码，也就是字符串中的字符所占的字节数是变化的（1～4）\n比如，对于“hello 中国”来说，utf8 编码为：\nh    e   l   l   o   _   中           国[104 101 108 108 111 32  228,184,173  229,155,189]\n\nstrstr 是 Rust 的一个基础类型，本质是一个字节数组[u8]\nstr 或 [u8] 类型的值存放在内存：可能是堆，可能是栈，还可能硬编码进可执行程序\n字符串字面量字符串字面量是 str 类型，在编译时就知道其内容，其字面值文本被直接硬编码进可执行程序\n在存储了该字符串之后，需要通过切片引用 &amp;str 来访问它\n\n&amp;str是一种不可变引用，所以它没有所有权\nstr 类型是硬编码进可执行文件，无法被修改\n\nlet s: &amp;str = &quot;hello world&quot;;\n\nStringString 字符串是在程序运行得过程中动态生成的，其在 rust 中是一个复合数据类型，定义如下：\npub struct String &#123;    vec: Vec&lt;u8&gt;,&#125;\n\n这说明 String 是可改变的，并且拥有所有权\n其他除了 String 类型的字符串，Rust 的标准库还提供了其他类型的字符串，例如 OsString， OsStr， CsString 和 CsStr 等\n&amp;str vs String&amp;str: 这是一个字符串切片，它是固定大小的，并且不能改变。\nString: 这是一个可增长的、可改变的、拥有所有权的、UTF-8 编码的字符串类型。它通常用于需要改变或者增长字符串的情况。\n类型转换&amp;str 的转换字节数组 [u8]|Vec&lt;u8&gt;-&gt;&amp;struse std::str;fn main() &#123;    let b = [104, 101, 108, 108, 111, 32, 228, 184, 173, 229, 155, 189];    // 实现了从 Vec&lt;u8&gt; 到 [u8] 的隐式类型转换  \t// let b = vec!(104, 101, 108, 108, 111, 32, 228, 184, 173, 229, 155, 189);    let s = str::from_utf8(&amp;b).unwrap();&#125;\n\n字符串字面量-&gt;[u8]let s = &quot;hello 中国&quot;;let b = s.as_bytes();dbg!(&quot;&#123;&#125;&quot;, b);\n\nString-&gt;&amp;strString 转变为 &amp;str 是无损的（性能无损，不会造成重写 malloc 或者数据移动）\n&amp;String 可以自动转换为 &amp;str，因此在函数中，如果接收参数是 &amp;String，通常会采用 &amp;str 作为入参，提升数据兼容性\n字符串是 UTF-8 编码，因此需要保证索引的字节刚好落在字符的边界，因为有些字符的长度超过 1 个字节\nlet s = String::from(&quot;hello, world&quot;);// 方法一、使用 &amp;String 直接转换some_func(&amp;s);// 方法二、使用 .as_str() 转换some_func(s.as_str());\n\nString的转换字节数组 Vec&lt;u8&gt;-&gt;Stringfn main() &#123;    let b = vec!(104, 101, 108, 108, 111, 32, 228, 184, 173, 229, 155, 189);    let s = String::from_utf8(b).unwrap();    println!(&quot;&#123;&#125;&quot;, s);&#125;\n\n&amp;str-&gt;String从 &amp;str 获得 String 是低效的，因为要重新 malloc 数据\nlet s = String::from(&quot;hello 世界&quot;);\n\nOverview&amp;str    -&gt; String  | String::from(s) or s.to_string() or s.to_owned()&amp;str    -&gt; &amp;[u8]   | s.as_bytes()&amp;str    -&gt; Vec&lt;u8&gt; | s.as_bytes().to_vec() or s.as_bytes().to_owned()String  -&gt; &amp;str    | &amp;s if possible* else s.as_str()String  -&gt; &amp;[u8]   | s.as_bytes()String  -&gt; Vec&lt;u8&gt; | s.into_bytes()&amp;[u8]   -&gt; &amp;str    | s.to_vec() or s.to_owned()&amp;[u8]   -&gt; String  | std::str::from_utf8(s).unwrap(), but unsafe&amp;[u8]   -&gt; Vec&lt;u8&gt; | String::from_utf8(s).unwrap(), but unsafeVec&lt;u8&gt; -&gt; &amp;str    | &amp;s if possible* else s.as_slice()Vec&lt;u8&gt; -&gt; String  | std::str::from_utf8(&amp;s).unwrap(), but unsafeVec&lt;u8&gt; -&gt; &amp;[u8]   | String::from_utf8(s).unwrap(), but unsafe\n\n操作字符串可变字符串 String 的修改，添加，删除等常用方法，且如果执行这些操作会修改原字符串，则字符串必须是 mut 的\n追加 (Push)\n使用 push() 方法追加字符 char\n使用 push_str() 方法追加字符串字面量\n两个方法都是在原有的字符串上追加，需要用 mut 修饰\n\nlet mut s = String::from(&quot;Hello &quot;);s.push_str(&quot;rust&quot;);s.push(&#x27;!&#x27;);\n\n插入 (Insert)\n使用 insert() 方法插入单个字符 char\n使用 insert_str() 方法插入字符串字面量\n这俩方法需要传入两个参数，第一个参数是字符（串）插入位置的索引，索引从 0 开始计数；第二个参数是要插入的字符（串），注意不要越界\n两个方法都是在原有的字符串上追加，需要用 mut 修饰\n\nlet mut s = String::from(&quot;Hello rust!中文&quot;);s.insert(5, &#x27;,&#x27;);s.insert_str(6, &quot; I like&quot;);\n\n替换 (Replace)replace\nreplace() 方法接收两个参数，第一个参数是要被替换的字符串，第二个参数是新的字符串\n该方法会替换所有匹配到的字符串\n该方法返回一个新的字符串，而不是操作原来的字符串，所以不需要 mut 修饰\n\nlet s = String::from(&quot;I like rust. Learning rust is my favorite!&quot;);let new_string_replace = s.replace(&quot;rust&quot;, &quot;RUST&quot;);\n\nreplacen方法接收三个参数，前两个参数与 replace() 方法一样，第三个参数则表示替换的个数\nlet s = &quot;I like rust. Learning rust is my favorite!&quot;;let new_string_replacen = s.replacen(&quot;rust&quot;, &quot;RUST&quot;, 1);\n\nreplace_range\nreplace_range 接收两个参数，第一个参数是要替换字符串的范围（Range），第二个参数是新的字符串\n该方法是直接操作原来的字符串，需要使用 mut 修饰\n如果range的范围大于&#x2F;小于新字符串长度会怎样？\n参数的位置需要在合法的字符边界\n\nlet mut s = String::from(&quot;hello rust 中国&quot;);s.replace_range(7..8, &quot;R&quot;);\n\n删除 (Delete)pop\n删除并返回字符串的最后一个字符\n其返回值是一个 Option 类型，如果字符串为空，则返回 None\n该方法直接操作原来的字符串，需要用 mut 修饰\n\nlet mut s = String::from(&quot;中文!&quot;);let p1 = s.pop(); // 中let p2 = s.pop(); // 文let p3 = s.pop(); // ！let p4 = s.pop(); // `None`\n\nremove\n其返回值是删除位置的字符串\n接收一个参数，表示该字符起始索引位置\n参数的位置需要在合法的字符边界\n该方法直接操作原来的字符串，需要用 mut 修饰\n\nfn main() &#123;    let mut s = String::from(&quot;测试remove方法&quot;);    println!(        &quot;string_remove 占 &#123;&#125; 个字节&quot;,        std::mem::size_of_val(s.as_str())    );    // 删除第一个汉字    s.remove(0);    // 下面代码会发生错误    // s_remove.remove(1);    // 直接删除第二个汉字    // s_remove.remove(3);    dbg!(s);&#125;\n\ntruncate\n删除字符串中从指定位置开始到结尾的全部字符\n参数的位置需要在合法的字符边界\n该方法是直接操作原来的字符串，需要用 mut 修饰\n\nlet mut s = String::from(&quot;测试truncate&quot;);s.truncate(3);\n\nclear\n清空字符串\n该方法直接操作原来的字符串，需要用 mut 修饰\n\nlet mut s = String::from(&quot;string clear&quot;);s.clear();\n\n连接 (Concatenate)使用 Add()add() 方法的第二个参数必须为字符串切片引用（Slice）类型\nuse std::ops::Add;fn main() &#123;    let s = String::from(&quot;hello &quot;);    let string_rust = String::from(&quot;rust&quot;);    let result = s.add(&amp;string_rust);&#125;\n\n使用 + 或者 +&#x3D; 连接字符串之所以可以直接 + 是因为 Add 实现了 + 的 trait\nlet s = String::from(&quot;hello &quot;);let string_rust = String::from(&quot;rust&quot;);let result = s + &amp;string_rust; // &amp;string_rust 会解引用为 &amp;strlet mut result = result + &quot;!&quot;;result += &quot;!!!&quot;;\n\n关于自动解引用std::String -&gt; &amp;str 没有任何成本，反过来则需要重新申请空间\n所以在定义使用字符串的函数的时候，优先定义成字符串切片的类型\n关于所有权移动\n无论是 + 还是 add 都发生了所有权移动\n\nlet s = String::from(&quot;hello &quot;);let string_rust = String::from(&quot;rust&quot;);let result = s + &amp;string_rust; // &amp;string_rust 会解引用转为 &amp;str// println!(&quot;&#123;&#125;&quot;, s); // 报错let mut result = result + &quot;!&quot;;result += &quot;!!!&quot;;println!(&quot;连接字符串 + -&gt; &#123;&#125;&quot;, result);\n\n使用 format! 连接字符串\nformat! 的用法与 println! 的用法类似\n\nlet s1 = &quot;hello&quot;;let s2 = String::from(&quot;rust&quot;);let s = format!(&quot;&#123;&#125; &#123;&#125;!&quot;, s1, s2);println!(&quot;&#123;&#125;&quot;, s);\n\nRust 手册 String 相关的函数https://doc.rust-lang.org/std/string/struct.String.html#\n字符串转义可以通过转义的方式 \\ 输出 ASCII 和 Unicode 字符。\n// 通过 \\ + 字符的十六进制表示，转义输出一个字符let byte_escape = &quot;I&#x27;m writing \\x52\\x75\\x73\\x74!&quot;;println!(&quot;What are you doing\\x3F (\\\\x3F means ?) &#123;&#125;&quot;, byte_escape); // What are you doing? (\\x3F means ?) I&#x27;m writing Rust!// \\u 可以输出一个 unicode 字符let unicode_codepoint = &quot;\\u&#123;211D&#125;&quot;;let character_name = &quot;\\&quot;DOUBLE-STRUCK CAPITAL R\\&quot;&quot;;println!(    &quot;Unicode character &#123;&#125; (U+211D) is called &#123;&#125;&quot;,    unicode_codepoint, character_name); // Unicode character ℝ (U+211D) is called &quot;DOUBLE-STRUCK CAPITAL R&quot;// 换行了也会保持之前的字符串格式// 使用\\忽略换行符let long_string = &quot;String literals                    can span multiple lines.                    The linebreak and indentation here -&gt;\\                    &lt;- can be escaped too!&quot;;println!(&quot;&#123;&#125;&quot;, long_string); // The linebreak and indentation here -&gt;&lt;- can be escaped too!\n\n原样输出println!(&quot;&#123;&#125;&quot;, &quot;hello \\\\x52\\\\x75\\\\x73\\\\x74&quot;);let raw_str = r&quot;Escapes don&#x27;t work here: \\x3F \\u&#123;211D&#125;&quot;;println!(&quot;&#123;&#125;&quot;, raw_str);// 如果字符串包含双引号，可以在开头和结尾加 #let quotes = r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#;println!(&quot;&#123;&#125;&quot;, quotes);// 如果还是有歧义，可以继续增加，没有限制let longer_delimiter = r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###;println!(&quot;&#123;&#125;&quot;, longer_delimiter);\n","categories":["Rust - IB课程"],"tags":["Rust"]},{"title":"IB-Rust-enum元组","url":"/2025/05/24/68-IB-Rust-enum%E5%85%83%E7%BB%84/","content":"Codes in lesson10\n不同语言 enum 对比typescriptenum Direction &#123;    North,    East,    South,    West&#125;let dir: Direction = Direction.North;\n\nc++enum Direction &#123;    North,    East,    South,    West&#125;int main() &#123;    Direction dir = North;&#125;\n\nrustenum Direction &#123;    North,    East,    South,    West&#125;let dir: Direction = Direction::North;\n\nenum 语法field-less enum只定义类型，但没有定义值\nenum Fieldless &#123;    Tuple(),    Struct &#123;&#125;,    Unit,&#125;\n\nunit-only enum全都是 unit 类型\nenum UnitOnlyEnum &#123;    Foo = 0,    Bar = 1,    Baz = 2,&#125;\n\nenum 规范Pascal Caseenum 名和 enum 值采用 Pascal Case\nenum PascalCase &#123;    PascalCase1,    PascalCase2,    PascalCase3,&#125;\n\nsnake_case函数或关联函数采用 snake_case\n// 方法impl Pets &#123;    // 入参是 mut 或 &amp;mut    fn snake_case1(&amp;self) &#123;        println!(&quot;hi&quot;);    &#125;&#125;// 关联函数impl Pets &#123;    fn snake_case2(name: String) &#123;        println!(&quot;name is &#123;name&#125;&quot;);    &#125;&#125;\n\nenum 用法matchmatch 必须能匹配所有条件\nenum Pets &#123;    Cat,    Dog,&#125;let cat = Pets::Cat;let dog = Pets::Dog;match cat &#123;    Pets::Cat =&gt; &#123;        println!(&quot;is cat&quot;);    &#125;    Pets::Dog =&gt; &#123;        println!(&quot;is dog&quot;);    &#125;    _ =&gt; &#123;&#125;&#125;\n\nif letif let cat = Pets::Cat &#123;    println!(&quot;is cat&quot;);&#125;\n\noption &amp; resultoption\n表示一个值可能为 Some（存在）或 None（不存在）\n替代其他语言中的 null 或 undefined，强制开发者处理可能的空值\n\nlet num = Some(1);let none: Option&lt;usize&gt; = None; // Option&lt;T&gt;match num &#123;    Some(val) =&gt; &#123;&#125;    None =&gt; &#123;&#125;&#125;\n\nresult\n表示一个操作可能成功（Ok）或失败（Err）\n替代其他语言中的异常（Exception），强制开发者处理可能的错误\n\nfn main() -&gt; Result&lt;(), ()&gt; &#123;    let num: Result&lt;usize, ()&gt; = Ok(1);    match num &#123;        Ok(val) =&gt; &#123;&#125;        Err(_) =&gt; &#123;&#125;    &#125;    // Err(())    Ok(())&#125;\n\noption 和 result 的转换option -&gt; result: ok_or当 Option 的 None 需要携带具体的错误信息时（例如在函数中需要返回 Result，但内部逻辑依赖 Option）\nlet opt: Option&lt;i32&gt; = Some(42);let result: Result&lt;i32, &amp;str&gt; = opt.ok_or(&quot;error&quot;);let none: Option&lt;i32&gt; = None;let result: Result&lt;i32, &amp;str&gt; = none.ok_or(&quot;error&quot;);\n\nresult -&gt; option : ok(), err()当错误无关紧要，只需关注操作是否成功时（例如日志记录或快速判断）\nlet res: Result&lt;i32, &amp;str&gt; = Ok(42);let opt: Option&lt;i32&gt; = res.ok();let res: Result&lt;i32, &amp;str&gt; = Err(&quot;error&quot;);let opt: Option&lt;i32&gt; = res.ok();\n\n常用 APIOption API.map() .unwrap()map() 对 Option 中的值应用一个闭包，返回一个新的布尔值 Option。若原 Option 是 None，直接返回 None\n.unwrap() 取值，如果是 None 则会 panic\nlet opt: Option&lt;i32&gt; = Some(1);let a1 = opt.map(|num| num &gt; 0); // Some(true)assert!(a1.unwrap()); // true\n\n.and_then().and_then() 对 Option 中的值应用一个闭包，闭包返回新的 Option，实现链式调用。若原 Option 是 None，直接返回 None\nlet opt: Option&lt;i32&gt; = Some(1);let b1 = opt.and_then(|val| Some(val + 1)); // Some(2)assert_eq!(b1, Some(2));\n\n.or_else().or_else() 在 Option 为 None 时调用闭包生成一个替代的 Option。若原 Option 是 Some，直接返回原值\nlet opt: Option&lt;i32&gt; = Some(1);let c1 = opt.or_else(|| Some(2)); // Some(1)；如果不是 Some，返回 Some(2)assert_eq!(c1, Some(1));\n\nResult API.map().map() 对 Result 中的 Ok 值应用一个闭包，返回新的 Result。若原 Result 是 Err，直接返回原 Err\nlet ret: Result&lt;i32, &amp;str&gt; = Ok(1);let a2 = ret.map(|val| val &gt; 0); // Ok(true)assert!(a2.unwrap()); // true\n\n.and_then().and_then() 对 Result 中的 Ok 值应用一个闭包，闭包返回新的 Result，实现链式调用。若原 Result 是 Err，直接返回原 Err\nlet ret: Result&lt;i32, &amp;str&gt; = Ok(1);let b2 = ret.and_then(|val| Ok((val + 1))); // Ok(2)assert_eq!(b2, Ok(2));\n\n.or_else().or_else() 在 Result 为 Err 时调用闭包生成一个替代的 Result。若原 Result 是 Ok，直接返回原值\nlet ret: Result&lt;i32, &amp;str&gt; = Ok(1);let c2 = ret.or_else(|str| Err(3)); // Ok(1)；如果不是 Ok，返回 Err(3)assert_eq!(c2, Ok(1));\n\nenum 内存占用每个 enum 包含标签（tag）​​和​​数据（data）​​两部分：\n\n​​标签​​：用于区分不同变体，大小取决于变体数量\n比如：1 byte &#x3D; 8 bits，能表示 2^8&#x3D;256 个变体​- ​数据​​：存储变体中的具体值，大小由最大的变体决定\n因为每次当枚举变量被赋值为某个变体时，只有该变体的数据会被写入内存，而旧数据会被销毁\n\n\n\n课后习题enum MyEnum &#123;    A(u8, u8), // 2    B,    C &#123;&#125;,&#125;// 标签1，内存2// 1 + 2 = 3println!(&quot;size of MyEnum: &#123;&#125;&quot;, size_of::&lt;MyEnum&gt;());enum EnumA &#123;    A = 255,&#125;// 当枚举只有一个变体时，Rust 编译器会将其优化为 ​​零大小类型（ZST）​​，即不占用任何内存// 即使显式指定判别值，判别值仅在 ​​编译时存在​​，不会在运行时存储// 标签0，内存0println!(&quot;size of EnumA: &#123;&#125;&quot;, size_of::&lt;EnumA&gt;());enum EnumB &#123;    A = 255,    B, // 256 -&gt; 2&#125;// 当定义枚举时，如果某个变体​​没有显式指定判别值（discriminant）​​// Rust 会默认将其判别值设为 ​​前一个变体的判别值加 1​​// 判别值的整数值直接用于标识变体，无需额外标签// 标签0，内存2// 0 + 2 = 2println!(&quot;size of EnumB: &#123;&#125;&quot;, size_of::&lt;EnumB&gt;());\n","categories":["Rust - IB课程"],"tags":["Rust"]},{"title":"IB-Rust-结构体","url":"/2025/05/26/69-IB-Rust-%E7%BB%93%E6%9E%84%E4%BD%93/","content":"Codes in lesson11\n普通结构体定义结构体\n结构体的定义的位置没有要求，实例化的作用域在定义的范围内即可\n大括号中，定义每一部分数据的名字和类型，称为字段（field）\n\nstruct User &#123;    active: bool,    username: String,    email: String,    sign_in_count: u64,&#125;\n\n创建结构体实例初始化实例时，每个字段都需要进行初始化，没有初始值\nlet user1 = User &#123;    email: String::from(&quot;someone@example.com&quot;),    username: String::from(&quot;someusername123&quot;),    active: true,    sign_in_count: 1,&#125;;\n\n使用字段初始化简写语法变量名与字段名完全相同（类似 js）\nlet email = String::from(&quot;someone@example.com&quot;);let username = String::from(&quot;someusername123&quot;);let user1 = User &#123;    email,    username,    active: true,    sign_in_count: 1,&#125;;\n\n从其他实例创建实例\n结构体更新语法允许从一个实例中创建一个新实例，同时保留部分字段值\n最后没有逗号\n\nlet user2 = User &#123;    email: String::from(&quot;another@example.com&quot;),    active: user1.active,    username: user1.username,    sign_in_count: user1.sign_in_count,&#125;;\n\nlet user2 = User &#123;    email: String::from(&quot;another@example.com&quot;),    ..user1 // 简写&#125;;\n\n修改结构体字段（可变性）整个实例必须是可变的，不允许只将某个字段标记为可变\nlet mut user1 = User &#123;    email: String::from(&quot;someone@example.com&quot;),    username: String::from(&quot;someusername123&quot;),    active: true,    sign_in_count: 1,&#125;;user1.email = String::from(&quot;anotheremail@example.com&quot;);\n\n特殊的结构体\n元组结构体（Tuple Struct）\n单元结构体（Unit-like Struct）\n\n元组结构体字段没有名称的结构体，这种结构体长得像元组，因此被称为元组结构体\n例如 Point 元组结构体，是 (x, y, z) 形式的坐标点\n\n使用 struct 关键字，接着是圆括号，然后是各字段类型\n实例化时使用圆括号\n\nstruct Color(i32, i32, i32);struct Point(i32, i32, i32);let black = Color(0, 0, 0); // 访问let origin = Point(0, 0, 0);\n\n单元结构体如果定义一个类型，但是不关心该类型的内容, 只关心其行为时，就可以使用 单元结构体\n\n使用 struct 关键字，接着是名称\n实例化不需要花括号或圆括号\n\nstruct AlwaysEqual;let subject = AlwaysEqual;// 不关心 AlwaysEqual 的字段数据，只关心其行为// 因此将它声明为单元结构体，然后再为它实现某个特征impl SomeTrait for AlwaysEqual &#123; &#125;\n\n所有权实现 Copy 特征的类型实现了 Copy 特征的类型无需所有权转移，可以直接在赋值时进行数据拷贝\nfn main() &#123;    let user1 = User &#123;        email: String::from(&quot;someone@example.com&quot;),        username: String::from(&quot;someusername123&quot;),        active: true,        sign_in_count: 1,    &#125;;    let active = user1.active;    println!(&quot;&#123;&#125;&quot;, user1.active); // true    print_username(user1); // someusername123&#125;fn print_username(user: User) &#123;    println!(&quot;&#123;&#125;&quot;, user.username);&#125;\n\n没有实现 Copy 特征的类型\n字段所有权发生了移动，但其他字段不受影响\n结构体整体也无法再被使用\n结构体更新语法同样适用\n\nfn main() &#123;    let user1 = User &#123;        email: String::from(&quot;someone@example.com&quot;),        username: String::from(&quot;someusername123&quot;),        active: true,        sign_in_count: 1,    &#125;;    let name = user1.username;    println!(&quot;&#123;&#125;&quot;, user1.email); // someone@example.com    println!(&quot;&#123;&#125;&quot;, user1.username); // error    print_username(user1); // error &#125;fn print_username(user: User) &#123;    println!(&quot;&#123;&#125;&quot;, user.username);&#125;\n\n结构体更新语法fn main() &#123;    let user1 = User &#123;        email: String::from(&quot;someone@example.com&quot;),        username: String::from(&quot;someusername123&quot;),        active: true,        sign_in_count: 1,    &#125;;    let user2 = User &#123;        email: String::from(&quot;another@example.com&quot;),        ..user1    &#125;;    // let user2 = User &#123;    //     email: String::from(&quot;another@example.com&quot;),    //     active: user1.active,    //     username: user1.username,    //     sign_in_count: user1.sign_in_count,    // &#125;;    println!(&quot;&#123;&#125;&quot;,user1.active);    println!(&quot;&#123;&#125;&quot;,user1.username); // 报错    print_username(user1); // 报错&#125;fn print_username(user: User) &#123;    println!(&quot;&#123;&#125;&quot;, user.username);&#125;\n\n结构体中的借用可以让 User 结构体从其它对象借用数据，不过需要引入生命周期\n生命周期能确保结构体的作用范围要比它所借用的数据的作用范围要小\nstruct User&lt;&#x27;a&gt; &#123;    username: &amp;&#x27;a str,    email: &amp;&#x27;a str,    sign_in_count: u64,    active: bool,&#125;let user1 = User &#123;    email: &quot;someone@example.com&quot;,    username: &quot;someusername123&quot;,    active: true,    sign_in_count: 1,&#125;;\n\n方法定义方法方法与函数不同，方法的第一个参数是 self，代表调用该方法的结构体实例\n#[derive(Debug)]struct Rectangle &#123;    width: u32,    height: u32,&#125;impl Rectangle &#123;    fn area(&amp;self) -&gt; u32 &#123;        self.width * self.height    &#125;&#125;fn main() &#123;    let rect1 = Rectangle &#123; width: 30, height: 50 &#125;;&#125;\n\n一般使用 &amp;self 替代 \n\nself: &amp;Self\nrectangle: &amp;Rectangle\n\nimpl Rectangle &#123;    fn area(&amp;self) -&gt; u32 &#123;        self.width * self.height    &#125;    // fn area(self: &amp;Self) -&gt; u32 &#123;    //     self.width * self.height    // &#125;    // fn area(self: &amp;Rectangle) -&gt; u32 &#123;    //     self.width * self.height    // &#125;&#125;\n\n\nself 依然有所有权的概念：\n\nself 表示 Rectangle 的所有权转移到该方法中，这种形式较少\n&amp;self 表示对 Rectangle 的不可变借用\n&amp;mut self 表示可变借用\n\n方法名跟结构体字段名相同在外部的包里，用户只能通过方法获取字段，而不能直接访问，作用类似 getter\npub struct Rectangle &#123;    width: u32,    height: u32,&#125;impl Rectangle &#123;    // getter    pub fn width(&amp;self) -&gt; bool &#123;        self.width &gt; 0    &#125;&#125;fn main() &#123;    let rect1 = Rectangle &#123;        width: 30,        height: 50,    &#125;;    if rect1.width() &#123;        println!(&quot;The rectangle has a nonzero width; it is &#123;&#125;&quot;, rect1.width);    &#125;&#125;\n\n关联函数在 impl 块中定义的函数被称为关联函数（associated functions），因为它们与 impl 后面命名的类型相关\n在 String 类型上定义的 String::from() 也是这样的函数\n\n关联函数没有 self\n不能用 . 的方式来调用，需要用 :: 来调用，例如 let sq = Rectangle::new(3, 3);\n一般使用 new 来作为构造器的名称\n\npub struct Rectangle &#123;    width: u32,    height: u32,&#125;impl Rectangle &#123;    fn new(width: u32, height: u32) -&gt; Rectangle &#123;        Rectangle &#123; width, height &#125;    &#125;&#125;fn main() &#123;    let rect1 = Rectangle::new(30, 50);&#125;\n\n多个 impl 定义允许为一个结构体定义多个 impl 块，目的是提供更多的灵活性和代码组织性\nimpl Rectangle &#123;    fn area(&amp;self) -&gt; u32 &#123;        self.width * self.height    &#125;&#125;impl Rectangle &#123;    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool &#123;        self.width &gt; other.width &amp;&amp; self.height &gt; other.height    &#125;&#125;\n\n实现trait为类型实现特征如果不同的类型具有相同的行为，可以定义一个特征，然后为这些类型实现该特征\n定义特征是把一些方法组合在一起，目的是定义一个实现某些目标所必需的行为的集合\ntrait Shape &#123;    fn area(&amp;self) -&gt; f64;&#125;#[derive(Debug)]struct Rectangle &#123;    width: u32,    height: u32,&#125;impl Shape for Rectangle &#123;    fn area(&amp;self) -&gt; f64 &#123;        (self.width * self.height) as f64    &#125;&#125;fn print_area(shape: &amp;impl Shape) &#123;    println!(&quot;&#123;&#125;&quot;, shape.area());&#125;\n\n打印结构体的信息❌ println!(“{}”, r)结构体默认没有实现 Display 特征\n\n结构体为什么不默认实现 Display 特征呢？\n原因在于结构体较为复杂，例如：想要逗号对字段进行分割吗？需要括号吗？等等因此如果要用 &#123;&#125; 的方式打印结构体，那就自己实现 Display 特征\n\n❌ println!(“{:?}”, r)结构体默认没有实现 Debug 特征\n✅  #[derive(Debug)]#[derive(Debug)]struct Rectangle &#123;    width: u32,    height: u32,&#125;fn main() &#123;    let rect1 = Rectangle &#123;        width: 30,        height: 50,    &#125;;    println!(&quot;rect1 is &#123;:?&#125;&quot;, rect1);  // rect1 is Rectangle &#123; width: 30, height: 50 &#125;&#125;\n\nprintln!(“{:#?}”, r)println!(&quot;rect1 is &#123;:#?&#125;&quot;, rect1);// rect1 is Rectangle &#123;//     width: 30,//     height: 50,// &#125;\n\ndbg!(&amp;r)代码所在的文件名、行号、表达式以及表达式的值\n#[derive(Debug)]struct Rectangle &#123;    width: u32,    height: u32,&#125;fn main() &#123;    let scale = 2;    let rect1 = Rectangle &#123;        width: dbg!(30 * scale),        height: 50,    &#125;;    dbg!(&amp;rect1);    // [src/rectangle/main.rs:97:16] 30 * scale = 60    // [src/rectangle/main.rs:100:5] &amp;rect1 = Rectangle &#123;    //     width: 60,    //     height: 50,    // &#125;&#125;\n\n✅ 自己实现 Display 特征impl std::fmt::Display for Rectangle &#123;    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#x27;_&gt;) -&gt; std::fmt::Result &#123;        for _ in 0..self.height &#123;            let mut s = String::new();            for _ in 0..self.width &#123;                s.push(&#x27;#&#x27;);            &#125;            write!(f, &quot;&#123;&#125;\\n&quot;, s);        &#125;        return Ok(());    &#125;&#125;\n\n课后作业✅ 自己实现 Debug 特征impl std::fmt::Debug for Rectangle &#123;    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#x27;_&gt;) -&gt; std::fmt::Result &#123;        for _ in 0..self.height &#123;            let mut s = String::new();            for _ in 0..self.width &#123;                s.push(&#x27;#&#x27;);            &#125;            write!(f, &quot;&#123;&#125;\\n&quot;, s);        &#125;        return Ok(());    &#125;&#125;","categories":["Rust - IB课程"],"tags":["Rust"]},{"title":"IB-Rust-模式匹配","url":"/2025/05/27/70-IB-Rust-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/","content":"Codes in lesson12\n概述模式匹配可以检查数据的结构并进行相应操作，提高代码的可读性和简洁性、减少错误，尤其是在处理复杂数据结构时\n基础模式匹配match 表达式基本用法：match 语句可以用于模式匹配数字、字符串、枚举等\nlet number = 13;match number &#123;    1 =&gt; println!(&quot;One!&quot;),    2 =&gt; println!(&quot;Two!&quot;),    3 =&gt; println!(&quot;Three!&quot;),    _ =&gt; println!(&quot;Something else!&quot;),&#125;\n\n模式匹配的各种模式字面值模式let x = 1;let y = &quot;Hello&quot;;match x &#123;    1 =&gt; println!(&quot;One&quot;),    2 =&gt; println!(&quot;Two&quot;),    _ =&gt; println!(&quot;Other&quot;),&#125;match y &#123;    &quot;Hello&quot; =&gt; println!(&quot;Greeting&quot;),    &quot;Goodbye&quot; =&gt; println!(&quot;Farewell&quot;),    _ =&gt; println!(&quot;Other&quot;),&#125;\n\n变量模式将 x 赋值给 var，注意 x 所有权的转移\nlet x = 42;match x &#123;    var =&gt; println!(&quot;The value is: &#123;&#125;&quot;, var),&#125;\n\n通配符模式match x &#123;    _ =&gt; println!(&quot;Any value&quot;),&#125;\n\n结构模式struct Point &#123; x: i32, y: i32 &#125;let p = Point &#123; x: 0, y: 7 &#125;;match p &#123;    Point &#123; x, y: 0 &#125; =&gt; println!(&quot;On the x axis at &#123;&#125;&quot;, x),    Point &#123; x: 0, y &#125; =&gt; println!(&quot;On the y axis at &#123;&#125;&quot;, y),    Point &#123; x, y &#125; =&gt; println!(&quot;On neither axis: (&#123;&#125;, &#123;&#125;)&quot;, x, y),&#125;\n\n元组模式、枚举模式、解构模式类似的，用于解构元组、枚举和其他复杂数据结构\n守卫和绑定守卫：在模式匹配中，可以使用守卫来添加额外的条件判断\n先匹配模式，再检查条件\nlet x = 5;match x &#123;    n if n % 2 == 0 =&gt; println!(&quot;Even&quot;),    n =&gt; println!(&quot;Odd&quot;),&#125;\n\n绑定：在模式匹配中，可以使用绑定来将模式中的值绑定到变量上\n同时匹配模式并绑定变量\nlet x = 3match x &#123;    var @ 1..=5 =&gt; println!(&quot;Value in range: &#123;&#125;&quot;, var),    _ =&gt; println!(&quot;Out of range&quot;),&#125;\n\n模式匹配的应用场景\n处理错误\n解析命令行参数\n解析配置文件\n解析数据包\n解析 XML 或 JSON 等数据格式\n\n处理错误fn divide(a: i32, b: i32) -&gt; Result&lt;i32, String&gt; &#123;    if b == 0 &#123;        Err(String::from(&quot;Cannot divide by zero&quot;))    &#125; else &#123;        Ok(a / b)    &#125;&#125;match divide(4, 2) &#123;    Ok(result) =&gt; println!(&quot;Result is &#123;&#125;&quot;, result),    Err(e) =&gt; println!(&quot;Error: &#123;&#125;&quot;, e),&#125;\n\n高级模式匹配技巧嵌套模式enum Message &#123;    Quit,    Move &#123; x: i32, y: i32 &#125;,    Write(String),    ChangeColor(i32, i32, i32),&#125;let msg = Message::ChangeColor(0, 160, 255);match msg &#123;    // 解构    Message::ChangeColor(r, g, b) =&gt; &#123;        println!(&quot;Change the color to red &#123;&#125;, green &#123;&#125;, and blue &#123;&#125;&quot;, r, g, b)    &#125;    _ =&gt; (),&#125;\n\n模式匹配与迭代器： 结合 iter 和 match 使用let vec1 = vec![1, 2, 3];let vec2 = vec![1, 2, 3];for (a, b) in vec1.iter().zip(vec2) &#123;    println!(&quot;&#123;&#125; + &#123;&#125; = &#123;&#125;&quot;, a, b, a + b);&#125;\n\nif let 和 while let： 简化单个模式匹配let opt = Some(5);if let Some(x) = opt &#123;    println!(&quot;Matched &#123;:?&#125;&quot;, x);&#125;let mut iter = vec![1, 2, 3].into_iter();while let Some(x) = iter.next() &#123;    println!(&quot;Matched &#123;:?&#125;&quot;, x);    // Matched 1    // Matched 2    // Matched 3&#125;\n\nref 和 ref mut使用场景\n借用数据而不转移所有权：在某些情况下，你只需要借用数据而不是转移其所有权。例如在递归数据结构中，借用数据可以避免所有权转移带来的复杂性\n对数据进行修改：使用 ref mut 可以在模式匹配时对数据进行修改，而无需转移所有权\n\nlet x = String::from(&quot;Hello&quot;);match x &#123;    // 借用 x 的所有权，x 所有权没有转移    ref r =&gt; println!(&quot;Got a reference to a value: &#123;:?&#125;&quot;, r),&#125;println!(&quot;x is still accessible: &#123;&#125;&quot;, x);let x = String::from(&quot;Hello&quot;);match x &#123;    ref mut r =&gt; &#123;        *r += String::from(&quot;world&quot;)    &#125;,&#125;\n\n课后习题编写一个使用模式匹配解析 JSON 字符串的程序\n\n作业目标\n理解如何使用 Rust 的模式匹配功能解析 JSON 数据。\n学会使用 serde_json 库进行 JSON 处理。\n练习在实际应用场景中使用模式匹配。\n\n\n作业要求\n使用 serde_json 库解析 JSON 字符串。\n使用模式匹配提取 JSON 对象中的不同字段。\n处理不同类型的数据（字符串、数字、数组、嵌套对象等）。\n\n\n作业示例假设你有一个包含用户信息的 JSON 字符串：\n\n&#123;  &quot;name&quot;: &quot;Alice&quot;,  &quot;age&quot;: 30,  &quot;email&quot;: &quot;alice@example.com&quot;,  &quot;address&quot;: &#123;    &quot;street&quot;: &quot;123 Main St&quot;,    &quot;city&quot;: &quot;Wonderland&quot;  &#125;,  &quot;phone_numbers&quot;: [&quot;123-456-7890&quot;, &quot;987-654-3210&quot;]&#125;\n\nuse serde_json::&#123;Result, Value&#125;;use std::collections::HashMap;fn main() -&gt; Result&lt;()&gt; &#123;    // 原始 JSON 数据    // 如果字符串包含双引号，可以在开头和结尾加 #    let json_str = r#&quot;    &#123;        &quot;name&quot;: &quot;Alice&quot;,        &quot;age&quot;: 30,        &quot;email&quot;: &quot;alice@example.com&quot;,        &quot;address&quot;: &#123;            &quot;street&quot;: &quot;123 Main St&quot;,            &quot;city&quot;: &quot;Wonderland&quot;        &#125;,        &quot;phone_numbers&quot;: [&quot;123-456-7890&quot;, &quot;987-654-3210&quot;]    &#125;    &quot;#;    // 步骤 1：解析 JSON 字符串为动态类型 Value    // serde_json::from_str 返回 Result&lt;Value, Error&gt;    let v: Value = serde_json::from_str(json_str)?;    // 步骤 2：使用模式匹配处理 JSON 结构    match v &#123;        Value::Object(obj) =&gt; &#123;            let mut name = String::from(&quot;Unknown&quot;);            let mut age = 0;            let mut address = HashMap::new();            let mut phone_numbers = Vec::new();            for (key, value) in obj &#123;                match key.as_str() &#123;                    &quot;name&quot; =&gt; &#123;                        if let Value::String(s) = value &#123;                            name = s;                        &#125;                    &#125;                    &quot;age&quot; =&gt; &#123;                        if let Value::Number(n) = value &#123;                            // as_i64()​​：将 JSON 数值转换为 i64 类型，返回 Option&lt;i64&gt;                            // unwrap_or(0)：解包 Option&lt;i64&gt;，如果值为 None，则使用默认值 0                            age = n.as_i64().unwrap_or(0) as i32;                        &#125;                    &#125;                    &quot;address&quot; =&gt; &#123;                        if let Value::Object(addr_obj) = value &#123;                            let mut street = String::from(&quot;Unknown&quot;);                            let mut city = String::from(&quot;Unknown&quot;);                            for (addr_key, addr_value) in addr_obj &#123;                                match addr_key.as_str() &#123;                                    &quot;street&quot; =&gt; &#123;                                        if let Value::String(s) = addr_value &#123;                                            street = s;                                        &#125;                                    &#125;                                    &quot;city&quot; =&gt; &#123;                                        if let Value::String(s) = addr_value &#123;                                            city = s;                                        &#125;                                    &#125;                                    _ =&gt; &#123;&#125;                                &#125;                            &#125;                            // 插入 HashMap 键值对                            address.insert(&quot;street&quot;, street);                            address.insert(&quot;city&quot;, city);                        &#125;                    &#125;                    &quot;phone_numbers&quot; =&gt; &#123;                        if let Value::Array(arr) = value &#123;                            for num in arr &#123;                                if let Value::String(s) = num &#123;                                    phone_numbers.push(s.clone());                                &#125;                            &#125;                        &#125;                    &#125;                    _ =&gt; &#123;&#125;                &#125;            &#125;            println!(&quot;Name: &#123;&#125;&quot;, name);            println!(&quot;Age: &#123;&#125;&quot;, age);            println!(&quot;Address: &#123;:?&#125;&quot;, address);            println!(&quot;Phone Numbers: &#123;:?&#125;&quot;, phone_numbers);        &#125;        _ =&gt; println!(&quot;Invalid JSON structure&quot;),    &#125;    Ok(())&#125;","categories":["Rust - IB课程"],"tags":["Rust"]},{"title":"IB-Rust-常见集合","url":"/2025/05/28/71-IB-Rust-%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88/","content":"Codes in lesson13\nRust 中的常见集合有 Vector 和 HashMap\nVector什么是 VecVec 是一个动态数组，可以根据需要动态增长和缩小，适用于需要按顺序存储数据的场景\nVec 的基本操作创建和初始化let v: Vec&lt;i32&gt; = Vec::new();let v = vec![1, 2, 3];\n\n添加元素// let mut v = vec![1, 2, 3];v.push(1);\n\n访问元素let v = vec![1, 2, 3];// 直接引用访问let third = &amp;v[2];println!(&quot;third: &#123;third&#125;&quot;);// 使用 get 访问match v.get(2) &#123;    Some(val) =&gt; println!(&quot;value: &#123;val&#125;&quot;),    None =&gt; println!(&quot;Index error&quot;),&#125;;\n\n修改元素let mut v = vec![1, 2, 3];v[0] = 0;\n\n遍历元素// 如果不用引用，v 的所有权会被转移for i in &amp;v &#123;    println!(&quot;i: &#123;i&#125;&quot;);&#125;\n\nVec 的进阶用法使用枚举存储多种类型enum SpreadSheetCell &#123;    Int(i32),    Float(f64),    Test(String),&#125;let row = vec![    SpreadSheetCell::Int(3),    SpreadSheetCell::Float(10.12),    SpreadSheetCell::Test(String::from(&quot;Hello&quot;)),];\n\n容量与重新分配let mut v: Vec&lt;i32&gt; = Vec::with_capacity(10);println!(&quot;capacity: &#123;&#125;&quot;, v.capacity()); // 10v.push(1);println!(&quot;capacity: &#123;&#125;&quot;, v.capacity()); // 10\n\nVec 的常见陷阱不安全的索引访问用 if 判断索引是否合法，或者使用 match\n可变引用与不可变引用的混用// let mut v = vec![1, 2, 3];// let first = &amp;v[0]; // 不可变借用// v.push(4); // 可变借用，error: mutable borrow occurs here// println!(&quot;The first element is : &#123;&#125;&quot;, first);let mut v = vec![1, 2, 3];&#123;    let first = &amp;v[0]; // 不可变借用    println!(&quot;The first element is : &#123;&#125;&quot;, first);&#125;v.push(4); // 可变借用，error: mutable borrow occurs hereprintln!(&quot;v: &#123;:?&#125;&quot;, v);\n\nHashMap什么是 HashMapHashMap 是一个键值对（key-value）存储的数据结构，适用于需要快速查找数据的场景\nHashMap 的基本操作创建和初始化let mut scores: HashMap&lt;_, _&gt; = HashMap::new();scores.insert(String::from(&quot;Blue&quot;), 10);scores.insert(String::from(&quot;yellow&quot;), 50);\n\n访问元素let team_name = String::from(&quot;Blue&quot;);let score = scores.get(&amp;team_name);match score &#123;    Some(s) =&gt; println!(&quot;The &#123;&#125; score is &#123;&#125;&quot;, team_name, s),    None =&gt; println!(&quot;No score for this team&quot;),&#125;;\n\n遍历元素// 使用引用防止所有权转移for (team, score) in &amp;scores &#123;    println!(&quot;&#123;&#125;: &#123;&#125;&quot;, team, score);&#125;\n\nHashMap 的进阶用法更新哈希表scores.insert(String::from(&quot;Blue&quot;), 25);scores.entry(String::from(&quot;Yellow&quot;)).or_insert(100);let entry = scores.entry(String::from(&quot;Red&quot;)).or_insert(30);println!(&quot;entry: &#123;entry&#125;&quot;); // 30*entry += 10;println!(&quot;entry: &#123;entry&#125;&quot;); // 40println!(&quot;&#123;:?&#125;&quot;, scores);\n\n合并哈希表let mut map1 = HashMap::new();map1.insert(&quot;a&quot;, 1);map1.insert(&quot;b&quot;, 2);let mut map2 = HashMap::new();map2.insert(&quot;b&quot;, 3);map2.insert(&quot;c&quot;, 4);for (k, v) in map2 &#123;    // map1.insert(k, v);    map1.entry(k).or_insert(v);&#125;\n\n生成哈希 keyuse std::hash::&#123;DefaultHasher, Hash, Hasher&#125;;fn calculate_hash&lt;T: Hash&gt;(t: &amp;T) -&gt; u64 &#123;    let mut s = DefaultHasher::new();    t.hash(&amp;mut s);    s.finish()&#125;fn hashmap_study() &#123;    let key1 = String::from(&quot;key1&quot;);    let key2 = String::from(&quot;key2&quot;);    println!(        &quot;hash of key1: &#123;&#125;, and key2: &#123;&#125;&quot;,        calculate_hash(&amp;key1),        calculate_hash(&amp;key2)    );&#125;\n\nHashMap 的常见陷阱哈希冲突使用 .entry().or_insert()\n值的所有权问题let field_name = String::from(&quot;color&quot;);let field_value = String::from(&quot;Blue&quot;);let mut map = HashMap::new();// map.insert(field_name, field_value);// println!(&quot;field_name: &#123;&#125;&quot;, field_name); // error: value borrowed here after movemap.insert(field_name.clone(), field_value.clone());println!(&quot;field_name: &#123;&#125;&quot;, field_name);\n\n练习题练习 1使用 Vec 实现一个简单的栈实现一个简单的栈（后进先出，LIFO）数据结构，支持 push、pop 和 peek 操作。\nstruct Stack&lt;T&gt; &#123;    elements: Vec&lt;T&gt;,&#125;impl&lt;T&gt; Stack&lt;T&gt; &#123;    fn new() -&gt; Self &#123;        &#123;            Stack &#123;                elements: Vec::new(),            &#125;        &#125;    &#125;    fn push(&amp;mut self, item: T) &#123;        self.elements.push(item);    &#125;    fn pop(&amp;mut self) -&gt; Option&lt;T&gt; &#123;        self.elements.pop()    &#125;    fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; &#123;        self.elements.last()    &#125;&#125;fn main() &#123;    let mut stack = Stack::new();    // 压入元素    stack.push(1);    stack.push(2);    stack.push(3);    // 查看栈顶    assert_eq!(stack.peek(), Some(&amp;3));    // 弹出元素    assert_eq!(stack.pop(), Some(3));    assert_eq!(stack.peek(), Some(&amp;2));    // 继续弹出和压入    assert_eq!(stack.pop(), Some(2));    stack.push(4);    assert_eq!(stack.peek(), Some(&amp;4));    // 清空栈    assert_eq!(stack.pop(), Some(4));    assert_eq!(stack.pop(), Some(1));    assert_eq!(stack.pop(), None); // 空栈时返回 None    assert_eq!(stack.peek(), None); // 空栈时返回 None&#125;\n\n练习 2使用 HashMap 实现一个字频统计器编写一个程序，统计一个字符串中每个单词出现的频率。\nuse std::collections::HashMap;fn word_frequency(text: &amp;str) -&gt; HashMap&lt;String, u32&gt; &#123;    let mut frequency_map = HashMap::new();    for word in text.split_whitespace() &#123;        // 清理单词并转换为 String（拥有所有权）        let cleaned_word = word            .chars() // 将单词分解为字符迭代器            .filter(|c| c.is_alphanumeric()) // 保留字母和数字字符，过滤标点符号            .collect::&lt;String&gt;() // 将过滤后的字符收集为 String            .to_lowercase();        if cleaned_word.is_empty() &#123;            continue;        &#125;        // 使用 String 作为键（拥有所有权）        *frequency_map.entry(cleaned_word).or_insert(0) += 1;    &#125;    frequency_map&#125;fn main() &#123;    let text = &quot;Hello world! Hello Rust. Rust is awesome. World says hello to Rust.&quot;;    let frequency = word_frequency(text);    println!(&quot;Word frequency:&quot;);    for (word, count) in &amp;frequency &#123;        println!(&quot;&#123;&#125;: &#123;&#125;&quot;, word, count);    &#125;    // 验证结果    assert_eq!(frequency.get(&quot;hello&quot;), Some(&amp;3));    assert_eq!(frequency.get(&quot;rust&quot;), Some(&amp;3));    assert_eq!(frequency.get(&quot;world&quot;), Some(&amp;2));    assert_eq!(frequency.get(&quot;is&quot;), Some(&amp;1));    assert_eq!(frequency.get(&quot;says&quot;), Some(&amp;1));    assert_eq!(frequency.get(&quot;to&quot;), Some(&amp;1));    assert_eq!(frequency.get(&quot;awesome&quot;), Some(&amp;1));&#125;\n\n练习3综合练习：使用 Vec 和 HashMap 实现一个简单的书籍库存管理系统实现一个书籍库存管理系统，可以添加书籍、查询库存、更新库存以及删除书籍。\nuse std::collections::HashMap;use std::fmt;// 书籍结构体#[derive(Debug, Clone)]struct Book &#123;    id: u32,        // 唯一标识符    title: String,  // 书名    author: String, // 作者    price: f64,     // 价格    quantity: u32,  // 库存数量&#125;impl Book &#123;    // 创建新书籍    fn new(id: u32, title: &amp;str, author: &amp;str, price: f64, quantity: u32) -&gt; Self &#123;        Book &#123;            id,            title: title.to_string(),            author: author.to_string(),            price,            quantity,        &#125;    &#125;&#125;// 为 Book 实现 Display trait 以便打印impl fmt::Display for Book &#123;    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;&#x27;_&gt;) -&gt; fmt::Result &#123;        write!(            f,            &quot;ID: &#123;&#125;, Title: &#x27;&#123;&#125;&#x27;, Author: &#x27;&#123;&#125;&#x27;, Price: $&#123;:.2&#125;, Quantity: &#123;&#125;&quot;,            self.id, self.title, self.author, self.price, self.quantity        )    &#125;&#125;// 库存管理系统struct InventoryManager &#123;    books_by_id: HashMap&lt;u32, Book&gt;,           // 按 ID 快速查找    books_by_title: HashMap&lt;String, Vec&lt;u32&gt;&gt;, // 按书名查找 ID 列表    next_id: u32,                              // 下一个可用 ID&#125;impl InventoryManager &#123;    // 创建新的库存管理系统    fn new() -&gt; Self &#123;        InventoryManager &#123;            books_by_id: HashMap::new(),            books_by_title: HashMap::new(),            next_id: 1,        &#125;    &#125;    // 添加新书    fn add_book(&amp;mut self, title: &amp;str, author: &amp;str, price: f64, quantity: u32) &#123;        let id = self.next_id;        self.next_id += 1;        let book = Book::new(id, title, author, price, quantity);        // 添加到 ID 索引        self.books_by_id.insert(id, book.clone());        // 添加到书名索引        self.books_by_title            .entry(title.to_lowercase())            .or_insert_with(Vec::new)            .push(id);        println!(&quot;Added book: &#123;&#125;&quot;, book);    &#125;    // 按 ID 查找书籍    fn find_by_id(&amp;self, id: u32) -&gt; Option&lt;&amp;Book&gt; &#123;        self.books_by_id.get(&amp;id)    &#125;    // 按书名查找书籍    fn find_by_title(&amp;self, title: &amp;str) -&gt; Vec&lt;&amp;Book&gt; &#123;        let title_lower = title.to_lowercase();        self.books_by_title            .get(&amp;title_lower)            .map(|ids| &#123;                ids.iter()                    .filter_map(|id| self.books_by_id.get(id))                    .collect()            &#125;)            .unwrap_or_else(Vec::new)    &#125;    // 更新库存数量    fn update_quantity(&amp;mut self, id: u32, delta: i32) -&gt; Result&lt;(), String&gt; &#123;        if let Some(book) = self.books_by_id.get_mut(&amp;id) &#123;            let new_quantity = book.quantity as i32 + delta;            if new_quantity &lt; 0 &#123;                return Err(format!(                    &quot;Cannot update quantity for book ID &#123;&#125;. Negative quantity not allowed.&quot;,                    id                ));            &#125;            book.quantity = new_quantity as u32;            println!(&quot;Updated book ID &#123;&#125;: new quantity = &#123;&#125;&quot;, id, book.quantity);            Ok(())        &#125; else &#123;            Err(format!(&quot;Book with ID &#123;&#125; not found&quot;, id))        &#125;    &#125;    // 删除书籍    fn remove_book(&amp;mut self, id: u32) -&gt; Result&lt;(), String&gt; &#123;        if let Some(book) = self.books_by_id.remove(&amp;id) &#123;            // 从书名索引中移除            if let Some(ids) = self.books_by_title.get_mut(&amp;book.title.to_lowercase()) &#123;                ids.retain(|&amp;book_id| book_id != id);                // 如果该书名下没有其他书籍，移除整个条目                if ids.is_empty() &#123;                    self.books_by_title.remove(&amp;book.title.to_lowercase());                &#125;            &#125;            println!(&quot;Removed book: &#123;&#125;&quot;, book);            Ok(())        &#125; else &#123;            Err(format!(&quot;Book with ID &#123;&#125; not found&quot;, id))        &#125;    &#125;    // 列出所有书籍    fn list_all_books(&amp;self) &#123;        println!(&quot;\\n--- Inventory Report ---&quot;);        if self.books_by_id.is_empty() &#123;            println!(&quot;No books in inventory&quot;);            return;        &#125;        for book in self.books_by_id.values() &#123;            println!(&quot;&#123;&#125;&quot;, book);        &#125;        println!(&quot;Total books: &#123;&#125;&quot;, self.books_by_id.len());    &#125;&#125;fn main() &#123;    let mut inventory = InventoryManager::new();    // 添加书籍    inventory.add_book(&quot;The Rust Programming Language&quot;, &quot;Steve Klabnik&quot;, 39.99, 10);    inventory.add_book(&quot;Programming Rust&quot;, &quot;Jim Blandy&quot;, 49.99, 5);    inventory.add_book(&quot;Rust in Action&quot;, &quot;Tim McNamara&quot;, 44.99, 8);    inventory.add_book(&quot;The Rust Programming Language&quot;, &quot;Carol Nichols&quot;, 39.99, 15); // 同名不同作者    // 查询书籍    println!(&quot;\\nSearching for books by title &#x27;Rust&#x27;:&quot;);    for book in inventory.find_by_title(&quot;Rust&quot;) &#123;        println!(&quot;- &#123;&#125;&quot;, book);    &#125;    println!(&quot;\\nSearching for book ID 2:&quot;);    if let Some(book) = inventory.find_by_id(2) &#123;        println!(&quot;- &#123;&#125;&quot;, book);    &#125;    // 更新库存    println!(&quot;\\nUpdating stock:&quot;);    inventory.update_quantity(1, -3).unwrap(); // 卖出3本    inventory.update_quantity(1, 5).unwrap(); // 进货5本    // 尝试无效更新    match inventory.update_quantity(1, -20) &#123;        Ok(_) =&gt; &#123;&#125;        Err(e) =&gt; println!(&quot;Error: &#123;&#125;&quot;, e),    &#125;    // 删除书籍    println!(&quot;\\nRemoving book ID 3:&quot;);    inventory.remove_book(3).unwrap();    // 列出所有书籍    inventory.list_all_books();    // 尝试删除不存在的书籍    match inventory.remove_book(99) &#123;        Ok(_) =&gt; &#123;&#125;        Err(e) =&gt; println!(&quot;\\nError: &#123;&#125;&quot;, e),    &#125;&#125;","categories":["Rust - IB课程"],"tags":["Rust"]},{"title":"IB-Rust-返回值与错误处理","url":"/2025/06/02/72-IB-Rust-%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8E%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/","content":"Codes in lesson14\nOption 返回值let mut s = String::from(&quot;A&quot;);let p1 = s.pop();dbg!(p1); // Some(&#x27;A&#x27;)let p2 = s.pop();dbg!(p2); // None\n\n解构 Optionenum Option&lt;T&gt; &#123;    Some(T),    None,&#125;\n\n匹配 Optionfn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; &#123;    match x &#123;        None =&gt; None,        Some(i) =&gt; Some(i + 1),    &#125;&#125;fn main() &#123;    let five = Some(5);    let six = plus_one(five); // Some(6)    let none = plus_one(None); // None&#125;\n\nOption&lt;T&gt; 的辅助函数\n Method overview https://doc.rust-lang.org/std/option/\n\n使用 unwrap如果确定 Option 存在值，可以使用 unwrap 方法来获取该值；如果 Option 不存在值，则会触发 panic\nlet mut s = String::from(&quot;A&quot;);let p1 = s.pop().unwrap(); // &quot;A&quot;// let p2 = s.pop().unwrap(); // panic: called `Option::unwrap()` on a `None` value\n\n使用 is_some 和 is_none可以使用 is_some 和 is_none 方法来判断 Option 中是否存在值。\nlet v = [10, 40, 30];if v.get(1).is_some() &#123;    println!(&quot;&#123;&#125;&quot;, v[1]); // 40&#125;\n\n使用 unwrap_or 提供默认值fn div(a: i32, b: i32) -&gt; Option&lt;f64&gt; &#123;    if b != 0 &#123;        Some(a as f64 / b as f64)    &#125; else &#123;        None    &#125;&#125;fn main() &#123;    let a = 10;    let b = 0;    let result = div(a, b).unwrap_or(0.0); // 0.0&#125;\n\n错误处理Rust 中的错误主要分为两类：\n\n可恢复错误，通常是从系统全局角度看可以接受的错误，例如处理用户的访问、操作等错误，这些错误只会影响某用户自身的操作进程，而不会影响系统的全局稳定性\n\n不可恢复错误，通常是全局性或者系统性的错误，例如数组越界访问，系统启动时发生了影响启动流程的错误等，这些错误对系统来说往往是致命的\n\nResult&lt;T, E&gt; 用于可恢复错误\n\npanic! 用于不可恢复错误\n\n\n用 panic! 处理不可恢复的错误触发被动触发C 语言中，读取数据结构未定义的值，会得到对应数据结构中这个元素内存位置的值（这些内存可能并不属于该数据结构），这被称为缓冲区溢出，并会导致安全漏洞，比如攻击者可以通过操作索引，读取储存在数据结构之后不被允许的数据\n为防范此类漏洞，如果读取索引不存在的元素，Rust 会停止执行，发生 panic\nlet v = vec![1, 2, 3];v[99];\n\n主动调用Rust 提供了 panic! 宏，当调用执行该宏时，程序会打印出错误信息，展开报错点之前的函数调用堆栈，并退出程序\npanic!(&quot;crash and burn&quot;);\n\nbacktrace 栈展开RUST_BACKTRACE=1 cargo run\n\n在栈展开（或栈回溯）中，函数调用按照逆序排列：最近调用的排在最上方\n要获取栈回溯信息，还需要开启 debug 标志。当不使用 --release 参数运行 cargo build 或 cargo run 时， debug 标识会默认启用\npanic 的两种终止方式\n栈展开（unwinding）（默认）: Rust 会回溯栈上数据和函数调用，可以给出充分的报错和栈调用信息，便于问题复盘，不过也意味着更多的善后工作\n直接终止（abort）: 不清理数据就直接退出程序，善后工作交与操作系统负责\n\n大多数情况，使用默认选择最好；当关心编译出的二进制可执行文件大小时，可以使用直接终止的方式，例如下面的 Cargo.toml 配置文件，可以实现在 release 模式下，遇到 panic 直接终止：\n[profile.release]panic = &#x27;abort&#x27;\nRUST_BACKTRACE=1 cargo run --release\n\n用 Result 处理可恢复的错误大部分错误并没有严重到需要程序完全停止执行，例如，如果因为打开一个并不存在的文件而失败，此时我们可能想创建这个文件，而不是终止进程\n\nOk(T)：泛型参数 T 代表成功时存入的正确值的类型\nErr(E)：E 代表错误时存入的错误值，存放方式是\n\nenum Result&lt;T, E&gt; &#123;    Ok(T),    Err(E),&#125;\n\n返回 Result例1fn div(x: f64, y: f64) -&gt; Result&lt;f64, String&gt; &#123;    if y == 0.0 &#123;        // 此操作将会失败，那么（与其让程序崩溃）不如把失败的原因包装在 Err 中并返回        Err((&quot;y is zero&quot;).to_string())    &#125; else &#123;        // 此操作是有效的，返回包装在 Ok 中的结果        Ok(x / y)    &#125;&#125;\n\n例2#[derive(Debug)]pub enum MathError &#123;    DivisionByZero,    NegativeSquareRoot,&#125;fn div(x: f64, y: f64) -&gt; Result&lt;f64, MathError&gt; &#123;    if y == 0.0 &#123;        Err(MathError::DivisionByZero)    &#125; else &#123;        Ok(x / y)    &#125;&#125;fn sqrt(x: f64) -&gt; Result&lt;f64, MathError&gt; &#123;    if x &lt; 0.0 &#123;        Err(MathError::NegativeSquareRoot)    &#125; else &#123;        Ok(x.sqrt())    &#125;&#125;\n\n处理 Resultuse std::fs::File;fn main() &#123;    let f = File::open(&quot;hello.txt&quot;);    let f = match f &#123;        Ok(file) =&gt; file,        Err(error) =&gt; &#123;            panic!(&quot;Problem opening the file: &#123;:?&#125;&quot;, error)        &#125;,    &#125;;&#125;\n\n对返回的错误进行处理对不同的错误原因采取不同的行为：\n\n如果 File::open 因为文件不存在而失败，我们希望创建这个文件并返回新文件的句柄\n如果 File::open 因为任何其他原因失败，例如没有打开文件的权限，我们仍然 panic!\n\nuse std::fs::File;use std::io::ErrorKind;fn main() &#123;    let greeting_file_result = File::open(&quot;hello.txt&quot;);    // `File::open` 返回的 `Err` 成员中的值类型 `io::Error` 是一个标准库中提供的结构体    // 该结构体有一个返回 `io::ErrorKind` 值的 `kind` 方法可供调用    // `io::ErrorKind` 是一个标准库提供的枚举，其成员对应 `io` 操作可能导致的不同错误类型    let greeting_file = match greeting_file_result &#123;        Ok(file) =&gt; file,        Err(error) =&gt; match error.kind() &#123;            ErrorKind::NotFound =&gt; match File::create(&quot;hello.txt&quot;) &#123;                Ok(fc) =&gt; fc,                Err(e) =&gt; panic!(&quot;Problem creating the file: &#123;e:?&#125;&quot;),            &#125;,            other_error =&gt; &#123;                panic!(&quot;Problem opening the file: &#123;other_error:?&#125;&quot;);            &#125;        &#125;,    &#125;;&#125;\n\nResult&lt;T, E&gt; 的辅助方法match 能够胜任，不过可能有点冗长且不总能很好的表明其意图Result&lt;T, E&gt; 类型定义了很多辅助方法来处理各种情况\n\nMethod overview: https://doc.rust-lang.org/std/result/index.html\n\nunwrap\n如果 Result 值是成员 Ok，unwrap 会返回 Ok 中的值\n如果 Result 是成员 Err，unwrap 会调用 panic!\n\nuse std::fs::File;fn main() &#123;    let f = File::open(&quot;hello.txt&quot;).unwrap();&#125;\n\nexpectexpect 跟 unwrap 很像，也是遇到错误直接 panic, 但会有自定义的错误提示信息，相当于重载了错误打印的函数：\nuse std::fs::File;fn main() &#123;    let f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);&#125;\n\nmapResult&lt;T, E&gt; -&gt; Result&lt;U, E&gt;\nlet line = &quot;1\\n2\\n3\\n4\\n&quot;;for num in line.lines() &#123;    match num.parse::&lt;i32&gt;().map(|i| i * 2) &#123;        Ok(n) =&gt; println!(&quot;&#123;n&#125;&quot;),        Err(..) =&gt; &#123;&#125;    &#125;&#125;\n\nmap_errResult&lt;T, E&gt; -&gt;Result&lt;T, F&gt;\nfn x() -&gt; Result&lt;(), String&gt; &#123;    let f = File::open(&quot;hello.txt&quot;).map_err(|e: std::io::Error| format!(&quot;&#123;e&#125;&quot;) );    match f&#123;        Err(e)=&gt;Err(e),        Ok(_)=&gt;&#123;            Ok(())        &#125;    &#125;&#125;\n\n传播错误可以使用 ? 运算符来简写\n对于 Result\n\n如果结果是 Ok(T)，则把 T 赋值给 f\n如果结果是 Err(E)，则返回该错误\n\n对于 Option\n\n如果值是 Some，Some 中的值作为表达式的返回值同时函数继续\n如果值是 None，此时 None 会从函数中提前返回\n\nuse std::fs::File;use std::io::Read;fn read_username_from_file() -&gt; Result&lt;String, std::io::Error&gt; &#123;    // // 打开文件，f是`Result&lt;文件句柄,io::Error&gt;`    // let f = File::open(&quot;hello.txt&quot;);    // let mut f = match f &#123;    //     // 打开文件成功，将file句柄赋值给f    //     Ok(file) =&gt; file,    //     // 打开文件失败，将错误返回(向上传播)    //     Err(e) =&gt; return Err(e),    // &#125;;    let mut f = File::open(&quot;hello.txt&quot;)?;    // 创建动态字符串s    let mut s = String::new();    // // 从f文件句柄读取数据并写入s中    // match f.read_to_string(&amp;mut s) &#123;    //     // 读取成功，返回Ok封装的字符串    //     Ok(_) =&gt; Ok(s),    //     // 将错误向上传播    //     Err(e) =&gt; Err(e),    // &#125;    f.read_to_string(&amp;mut s)?;    Ok(s)&#125;\n\n链式方法调用fn read_username_from_file() -&gt; Result&lt;String, std::io::Error&gt; &#123;    let mut s = String::new();    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;    Ok(s)&#125;\n\n常见错误fn first(arr: &amp;[i32]) -&gt; Option&lt;&amp;i32&gt; &#123;   arr.get(0)?   // 正确   // let a = arr.get(0)?;   // return a;&#125;\n\n这段代码无法通过编译：? 操作符需要一个变量来承载值，这个函数只会返回 Some(&amp;i32) 或者 None。而事实上，只有错误值能直接返回，正确的值不行，因为如果数组存在 0 号元素，函数第二行使用 ? 后的返回类型是 &amp;i32 而不是 Some(&amp;i32)\nOption 与 Result 的互相转换Option -&gt; Result: ok_or()\nSome(v) to Ok(v)\nNone to Err(err)\n\nfn first(arr: &amp;[i32]) -&gt; Result&lt;&amp;i32, &amp;str&gt; &#123;    arr.get(0).ok_or(&quot;out of index&quot;)&#125;\n\nResult -&gt; Opiton: err()\nErr(e) to Some(e) \nOk(v) to None\n\nlet f = File::open(&quot;hello.txt&quot;).err();if f.is_some() &#123;    println!(&quot;no file&quot;);&#125;\n\nResult -&gt; Opiton: ok()\nOk(e) to Some(e) \nErr(v) to None\n\nlet f = File::open(&quot;hello.txt&quot;).ok();if f.is_none()&#123;    println!(&quot;no file&quot;);&#125;\n\n课后习题// 修复 call 函数的错误// 当 b 为 None 时，按默认值 1fn call(a: i32, b: i32) -&gt; Result&lt;f64, String&gt; &#123;    let r = divide(a, b);     let s = sqrt(r);        Ok(s);&#125;fn divide(a: i32, b: i32) -&gt; Option&lt;f64&gt; &#123;    if b != 0 &#123;        Some(a as f64 / b as f64)    &#125; else &#123;        None    &#125;&#125;pub enum MathError &#123;    DivisionByZero,    NegativeSquareRoot,&#125;fn sqrt(x: f64) -&gt; Result&lt;f64, MathError&gt; &#123;    if x &lt; 0.0 &#123;        Err(MathError::NegativeSquareRoot)    &#125; else &#123;        Ok(x.sqrt())    &#125;&#125;\n\n答案fn call(a: i32, b: Option&lt;i32&gt;) -&gt; Result&lt;f64, String&gt; &#123;    let r = divide(a, b.unwrap_or(1)).ok_or(&quot;Division by zero&quot;.to_string())?;    let s = sqrt(r).map_err(|e: MathError| -&gt; String &#123;        match e &#123;            MathError::DivisionByZero =&gt; &#123;                return &quot;DivisionByZero&quot;.to_string();            &#125;            MathError::NegativeSquareRoot =&gt; &#123;                return &quot;NegativeSquareRoot&quot;.to_string();            &#125;        &#125;    &#125;)?;    return Ok(s);&#125;\n","categories":["Rust - IB课程"],"tags":["Rust"]},{"title":"IB-Rust-模块化","url":"/2025/06/03/73-IB-Rust-%E6%A8%A1%E5%9D%97%E5%8C%96/","content":"Codes in lesson15\nPackage &amp; Crate定义和作用\n​​package 是包含一个或多个 crate 的集合​​：由 Cargo.toml 文件定义\n​​项目组织单位​​：对应于文件系统中的一个目录​​- 依赖管理​​：通过 Cargo.toml 管理外部 crate 依赖​​- 构建管理​​：Cargo 根据包定义构建所有 crate\n\n关键规则\n​​一个 package 最多包含一个 library​​ crate\n​​一个 package 可以包含任意数量的 binary crate​- ​至少包含一个 crate​​（library crate or binary crate）\n\nmy_package/├── Cargo.toml       # 包定义文件└── src/    ├── lib.rs       # library crate（可选）    ├── main.rs      # 默认 binary crate    └── bin/         # 额外 binary crate        ├── tool1.rs        └── tool2.rs\n\nCargo.toml 额外 binary crate\n[[bin]]name = &quot;tool1&quot;path = &quot;src/bin/tool1.rs&quot;\n\nVisibilityprivate (default)默认私有：\nstruct PrivateStruct;fn private_function() &#123;&#125;\n\npub(crate)\n在当前 crate 内的任何位置可见\n对外部 crate 不可见\n适合内部共享的实用工具（utils）\n\npub(crate) struct CrateVisible; // 当前 crate 内可见\n\npub(in path)\n限定在指定的模块路径内可见\n比 pub(crate) 更精确的可见性控制\n路径必须是当前crate内的模块路径\n\npub(in crate::module) struct ModuleVisible; // 特定模块路径内可见\n\npub use\n创建简化的公共 API\n在不暴露内部结构的情况下公开功能\n组合来自不同模块的相关项\n\npub use some_module::SomeType; // 简化重新导出到当前作用域\n\nPath\n绝对路径：crate\n相对路径：super self\n\n// 绝对路径访问crate::a::echo(); // 相对路径访问a::echo(); self::a::echo();use super::echo1;echo1();\n\nWorkspace工作区是一组共享同一个 Cargo.lock 文件和 target 输出目录的包（packages），这些包通常：\n\n位于同一个代码仓库中\n相互关联（如 library crate + binary crate）\n需要共享依赖项版本\n\n典型目录结构my_workspace/├── Cargo.toml          # 工作区配置文件├── Cargo.lock          # 共享的依赖锁文件├── target/             # 共享的构建输出目录│├── crate1/             # 第一个成员包│   ├── Cargo.toml│   └── src/│├── crate2/             # 第二个成员包│   ├── Cargo.toml│   └── src/│└── tools/              # 工具包（可选）    ├── Cargo.toml    └── src/\n\n创建工作区创建根目录配置my_workspace/Cargo.toml:\n[workspace]members = [    &quot;crate1&quot;,       # library crate    &quot;crate2&quot;,       # binary crate    &quot;tools/*&quot;,      # 通配符支持]resolver = &quot;2&quot;      # 使用新版解析器（Cargo 2021+）\n\n创建成员包# 创建库cratecargo new --lib crate1# 创建二进制cratecargo new crate2# 创建工具包mkdir -p tools/tool1cargo init --bin tools/tool1\n\n工作区操作命令# 构建所有成员cargo build --workspace# 测试特定成员cargo test -p crate1# 运行二进制成员cargo run -p crate2 -- --args# 检查所有依赖更新cargo update --workspace\n\nTestunit test\n位置​​：与源码在同一文件（src&#x2F; 目录下）​- ​作用​​：测试函数或模块内部的实现细节​​- 标记​​：#[cfg(test)] mod tests &#123; &#125; + #[test]\n\n#[cfg(test)]mod tests &#123;    #[test]    fn it_works() &#123;        assert_eq!(2 + 2, 4);    &#125;&#125;\n\nintegration test\n​​位置​​：单独的 tests&#x2F; 目录（与 src&#x2F; 同级）​- ​作用​​：测试库的公共接口​- ​特点​​：每个测试文件都是独立的 crate\n\n// project/tests/integration_test.rsuse my_crate;#[test]fn it_adds_two() &#123;    assert!(my_crate::add(2, 2), 4);&#125;\n","categories":["Rust - IB课程"],"tags":["Rust"]},{"title":"IB-Rust-泛型","url":"/2025/06/05/75-IB-Rust-%E6%B3%9B%E5%9E%8B/","content":"Codes in lesson17\n泛型的例子用同一功能的函数处理不同类型的数据，例如两个数的加法，无论是整数、浮点数、还是自定义类型，都能支持。在不支持泛型的编程语言中，需要为每种类型编写一个函数：\nfn add_i8(a:i8, b:i8) -&gt; i8 &#123;    a + b&#125;fn add_i32(a:i32, b:i32) -&gt; i32 &#123;    a + b&#125;fn add_f64(a:f64, b:f64) -&gt; f64 &#123;    a + b&#125;fn main() &#123;    println!(&quot;add i8: &#123;&#125;&quot;, add_i8(2i8, 3i8));    println!(&quot;add i32: &#123;&#125;&quot;, add_i32(20, 30));    println!(&quot;add f64: &#123;&#125;&quot;, add_f64(1.23, 1.23));&#125;\n\n泛型当使用泛型定义函数时，本来在函数签名中指定参数和返回值的类型的地方，会改用泛型来表示。这种技术能使代码适应性更强，从而为函数调用者提供更多的功能，同时也避免了代码重复\nfn add&lt;T&gt;(a:T, b:T) -&gt; T &#123;    a + b&#125;\n\n上面代码的 T 就是泛型参数，泛型参数的名称可以为任意，但是惯例一般用 T作为首选。该名称越短越好，除非需要表达含义\n不是所有 T 类型都能进行相加操作，因此需要用 std::ops::Add&lt;Output = T&gt; 对 T 进行限制：\nfn add&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(a: T, b: T) -&gt; T &#123;    a + b&#125;fn main() &#123;    println!(&quot;add i8: &#123;&#125;&quot;, add(2i8, 3i8));    println!(&quot;add i32: &#123;&#125;&quot;, add(20, 30));    println!(&quot;add f64: &#123;&#125;&quot;, add(1.23, 1.23));&#125;\n\n在函数定义中使用泛型不是所有的类型都能进行比较，使用标准库中定义的 std::cmp::PartialOrd trait 可以实现类型的比较功能，限制 T 只对实现了 PartialOrd 的类型有效（i32 和 char）\nfn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; &amp;T &#123;    let mut largest = &amp;list[0];    for item in list &#123;        if item &gt; largest &#123;            largest = item;        &#125;    &#125;    largest&#125;fn main() &#123;    let number_list = vec![34, 50, 25, 100, 65];    let result = largest(&amp;number_list);    println!(&quot;The largest number is &#123;&#125;&quot;, result);    let char_list = vec![&#x27;y&#x27;, &#x27;m&#x27;, &#x27;a&#x27;, &#x27;q&#x27;];    let result = largest(&amp;char_list);    println!(&quot;The largest char is &#123;&#125;&quot;, result);&#125;\n\n结构体定义中的泛型\n结构体名称后面的尖括号中声明泛型参数的名称，结构体定义中可以指定具体数据类型的位置\nx 和 y 是相同的类型\n\nstruct Point&lt;T&gt; &#123;    x: T,    y: T,&#125;fn main() &#123;    let integer = Point &#123; x: 5, y: 10 &#125;;    let float = Point &#123; x: 1.0, y: 4.0 &#125;;    // let wont_work = Point &#123; x: 5, y: 4.0 &#125;; // error: mismatched types&#125;\n\n定义一个 x 和 y 有不同类型且仍是泛型的 Point 结构体：\nstruct Point&lt;T, U&gt; &#123;    x: T,    y: U,&#125;fn main() &#123;    let both_integer = Point &#123; x: 5, y: 10 &#125;;    let both_float = Point &#123; x: 1.0, y: 4.0 &#125;;    let integer_and_float = Point &#123; x: 5, y: 4.0 &#125;;&#125;\n\n枚举中使用泛型enum Option&lt;T&gt; &#123;    Some(T),    None,&#125;enum Result&lt;T, E&gt; &#123;    Ok(T),    Err(E),&#125;\n\n方法中使用泛型其他 T 不是 i32 类型的 Point&lt;T&gt; 实例没有定义此方法\nstruct Point&lt;T&gt; &#123;    x: T,    y: T,&#125;impl Point&lt;i32&gt; &#123;    fn x(&amp;self) -&gt; &amp;i32 &#123;        &amp;self.x    &#125;&#125;\n\nimpl 之后声明泛型 T泛型参数可以与结构体定义中声明的泛型参数不同\nstruct Point&lt;T&gt; &#123;    x: T,    y: T,&#125;impl&lt;T&gt; Point&lt;T&gt; &#123;    fn x(&amp;self) -&gt; &amp;T &#123;        &amp;self.x    &#125;&#125;\n\n方法使用了与结构体定义中不同类型的泛型struct Point&lt;X1, Y1&gt; &#123;    x: X1,    y: Y1,&#125;impl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; &#123;    fn mixup&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; &#123;        Point &#123;            x: self.x,            y: other.y,        &#125;    &#125;&#125;fn main() &#123;    let p1 = Point &#123; x: 5, y: 10.4 &#125;;    let p2 = Point &#123; x: &quot;Hello&quot;, y: &#x27;c&#x27; &#125;;    let p3 = p1.mixup(p2); // &#123;x: 5, y: c&#125;&#125;\n\nconst 泛型（Rust 1.51 版本引入的重要特性）[i32; 3] 和 [i32; 2] 确实是两个完全不同的类型，因此无法用同一个函数调用\nfn display_array(arr: [i32; 3]) &#123;    println!(&quot;&#123;:?&#125;&quot;, arr);&#125;fn main() &#123;    let arr: [i32; 3] = [1, 2, 3];    display_array(arr);    let arr: [i32; 2] = [1,2];    // display_array(arr); // error: mismatched types&#125;\n\n方式1: 切片+泛型\n使用数组切片，传入 arr 的不可变引用\ni32 改成所有类型T的数组\n需要对 T 加一个限制 std::fmt::Debug，表明 T 可以用在 println!(&quot;&#123;:?&#125;&quot;, arr) 中，因为 &#123;:?&#125; 形式的格式化输出需要 arr 实现该特征\n\nfn display_array&lt;T: std::fmt::Debug&gt;(arr: &amp;[T]) &#123;    println!(&quot;&#123;:?&#125;&quot;, arr);&#125;fn main() &#123;    let arr: [i32; 3] = [1, 2, 3];    display_array(&amp;arr);    let arr: [i32;2] = [1,2];    display_array(&amp;arr);&#125;\n\n方式2: const 泛型const N: usize，表示 const 泛型 N 基于的值类型是 usize\n定义一个类型为 [T; N] 的数组：其中的 N 是一个基于值的泛型参数，因为它用来替代数组的长度\nfn display_array&lt;T: std::fmt::Debug, const N: usize&gt;(arr: [T; N]) &#123;    println!(&quot;&#123;:?&#125;&quot;, arr);&#125;fn main() &#123;    let arr: [i32; 3] = [1, 2, 3];    display_array(arr);    let arr: [i32; 2] = [1, 2];    display_array(arr);&#125;\n\n泛型代码的性能\nRust 通过在编译时进行泛型代码的 单态化（monomorphization）来保证效率\n\n对于标准库中的 Option 枚举：\nlet integer = Some(5);let float = Some(5.0);\n\n编译器生成的单态化版本的代码看起来像这样（名字为假想的）：\nenum Option_i32 &#123;    Some(i32),    None,&#125;enum Option_f64 &#123;    Some(f64),    None,&#125;fn main() &#123;    let integer = Option_i32::Some(5);    let float = Option_f64::Some(5.0);&#125;\n\n泛型 Option&lt;T&gt; 被编译器替换为了具体的定义。Rust 会将每种情况下的泛型代码编译为具体类型，使用泛型没有运行时开销。代码运行的执行效率和手写每个具体定义的重复代码一样。单态化正是 Rust 泛型在运行时极其高效的原因\n但是，Rust 在编译期为泛型对应的多个类型，生成各自的代码，因此损失了编译速度，且增大了最终生成文件的大小\n","categories":["Rust - IB课程"],"tags":["Rust"]},{"title":"IB-Rust-生命周期","url":"/2025/06/05/76-IB-Rust-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","content":"Codes in lesson18\n创建生命周期⽣命周期主要通过⽣命周期注解来创建和使⽤。⽣命周期注解是⼀种显式声明引⽤有效时间的⽅式，通常⽤’a、’b 这样的符号表示\n生命周期类别fn‘a ⽣命周期注解 表明返回值的⽣命周期与输⼊参数的⽣命周期相同：\nfn longest&lt;&#x27;a&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123;    if x.len() &gt; y.len() &#123; x &#125; else &#123; y &#125;&#125;\n\nstructstruct Example&lt;&#x27;a&gt; &#123;    part: &amp;&#x27;a str,&#125;\n\nenumenum StringOption&lt;&#x27;a&gt; &#123;    Some(&amp;&#x27;a str),    None,&#125;\n\n生命周期消除（Lifetime Elision）\nrust 编译期自动推理，无需手动重复添加\n\n\n每个引⽤参数都有⾃⼰的⽣命周期参数\n如果只有⼀个输⼊引⽤参数，那么它的⽣命周期会被赋予所有输出引⽤\n如果有多个输⼊⽣命周期参数，但其中⼀个是 &amp;self 或 &amp;mut self，那么 self 的⽣命周期会被赋予所有输出引⽤\n\nfn _first_word(s: &amp;str) -&gt; &amp;str &#123;    &amp;s[..1]&#125;// 返回值不包含引⽤，⽆需标注fn _add(a: &amp;i32, b: &amp;i32) -&gt; i32 &#123;    *a + *b&#125;// 只包含⼀个 输入引⽤参数，输出引用的⽣命周期与其⼀致fn _identity(a: &amp;i32) -&gt; &amp;i32 &#123;    a&#125;\n\n特殊生命周期标注&#39;static ⽣命周期表示整个程序运⾏期间都有效的⽣命周期，通常⽤于全局变量或字符串字⾯量\n let s: &amp;&#x27;static str = &quot;hello&quot;;const SOME_COORDINATE: (i32, i32) = (7, 4);let static_reference: &amp;&#x27;static (i32, i32) = &amp;SOME_COORDINATE;struct Counter&lt;&#x27;a&gt; &#123;    counter: &amp;&#x27;a mut i32,&#125;// 方法中没有需要显示指定的生命周期，可以用占位符默认匹配impl Counter&lt;&#x27;_&gt; &#123;    fn increment(&amp;mut self) &#123;        *self.counter += 1;    &#125;&#125;\n\n生命周期约束生命周期注解可以用来约束多个引用之间的关系\n‘b: ‘a 表示⽣命周期’b 必须不短于’a：\nfn example&lt;&#x27;a, &#x27;b&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;b str) -&gt; &amp;&#x27;a strwhere    &#x27;b: &#x27;a,&#123;    x&#125;\n\n⽣命周期⼦类型和协变⽣命周期可以有⼦类型关系，较短的⽣命周期可以被视为较⻓⽣命周期的⼦类型。这在协变（convariance）中尤为重要\nfn _example1&lt;&#x27;a, &#x27;b&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;b str) -&gt; &amp;&#x27;a strwhere    &#x27;a: &#x27;b,&#123;    x&#125;\n\n课后习题修改如下代码，使得编译通过，并解释为什么？\n进阶： 还有⼏种解法可以实现，你能通过修改⼀个⽣命周期参数实现吗？\nfn test_lifetime_multiple() &#123;    fn insert_value&lt;&#x27;a, &#x27;b&gt;(my_vec: &amp;&#x27;a mut Vec&lt;&amp;&#x27;a i32&gt;, value: &amp;&#x27;b i32) &#123;        my_vec.push(value)    &#125;    let mut my_vec: Vec&lt;&amp;i32&gt; = vec![];    let val1 = 1;    let val2 = 2;    let a = &amp;mut my_vec;    insert_value(a, &amp;val1);    println!(&quot;a is &#123;:?&#125; &quot;, a);    let b = &amp;mut my_vec;    insert_value(b, &amp;val2);    println!(&quot;b is &#123;:?&#125;&quot;, b);    println!(&quot;&#123;my_vec:?&#125;&quot;);&#125;\n\n解决方法：&amp;&#39;a mut Vec&lt;&amp;&#39;a i32&gt; 是错误的，my_vec 和 其中存储的元素引用 的生命周期不能相同，因为有如下冲突：\n\n第一次调用后，向量要求所有元素具有生命周期’α1\n但第二次调用要求元素具有生命周期’α2\n‘α1和’α2是不同的具体生命周期实例\n向量不能存储具有不同生命周期的引用\n\nlet a = &amp;mut my_vec;  // [1] 借用开始，设为生命周期&#x27;α1insert_value(a, &amp;val1); // [2] 要求val1生命周期 ≥ &#x27;α1                        // 并强制存储元素的生命周期为&#x27;α1println!(&quot;a is &#123;:?&#125; &quot;, a); // [3] a最后一次使用let b = &amp;mut my_vec;  // [4] 新借用开始，设为生命周期&#x27;α2insert_value(b, &amp;val2); // [5] 要求存储元素生命周期为&#x27;α2\n\n正确代码：fn _test_lifetime_multiple() &#123;    fn insert_value&lt;&#x27;a&gt;(my_vec: &amp;mut Vec&lt;&amp;&#x27;a i32&gt;, value: &amp;&#x27;a i32) &#123;        my_vec.push(value)    &#125;    let mut my_vec: Vec&lt;&amp;i32&gt; = vec![];    let val1 = 1;    let val2 = 2;    let a = &amp;mut my_vec;    insert_value(a, &amp;val1);    println!(&quot;a is &#123;:?&#125; &quot;, a);    let b = &amp;mut my_vec;    insert_value(b, &amp;val2);    println!(&quot;b is &#123;:?&#125;&quot;, b);    println!(&quot;&#123;my_vec:?&#125;&quot;);&#125;\n","categories":["Rust - IB课程"],"tags":["Rust"]},{"title":"IB-Rust-智能指针2","url":"/2025/06/09/77-IB-Rust-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%882/","content":"Codes in lesson19\n课程概述\nRc&lt;T&gt;\nRefCell&lt;T&gt;\nWeak&lt;T&gt;\n\nRc&lt;T&gt; 引用计数指针什么是 Rc&lt;T&gt;？\nRc 是 Reference Counted（引用计数） 的缩写\n允许多所有者的共享所有权模型\n\n举例说明使用 Box&lt;T&gt; 定义 cons list 的例子。这一次，我们希望创建两个共享第三个列表所有权的列表\n尝试使用 Box&lt;T&gt; 定义的 List：\nuse crate::List::&#123;Cons, Nil&#125;;fn main() &#123;    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));    let b = Cons(3, Box::new(a));    let c = Cons(4, Box::new(a)); // use of moved value: `a`&#125;enum List &#123;    Cons(i32, Box&lt;List&gt;),    Nil,&#125;\n\n使用 Rc&lt;T&gt; 实现use crate::List::&#123;Cons, Nil&#125;;use std::rc::Rc;fn main() &#123;    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));    println!(&quot;a: &#123;&#125;&quot;, Rc::strong_count(&amp;a));    let b = Cons(3, Rc::clone(&amp;a));    println!(&quot;a: &#123;&#125;&quot;, Rc::strong_count(&amp;a));    let c = Cons(4, Rc::clone(&amp;a));    println!(&quot;a: &#123;&#125;&quot;, Rc::strong_count(&amp;a));&#125;enum List &#123;    Cons(i32, Rc&lt;List&gt;),    Nil,&#125;\n\nRefCell&lt;T&gt;什么是RefCell&lt;T&gt;？RefCell&lt;T&gt; 是一个智能指针类型，允许在编译时无法确定的情况下，在运行时进行借用检查\n主要特征\n内部可变性:\nRefCell&lt;T&gt; 允许你在其拥有的 T 内部进行修改，即使 RefCell 本身是不可变的。这是通过在运行时进行借用检查实现的\n\n\n运行时借用检查:\nRefCell 使用动态借用检查，确保在运行时遵循 Rust 的借用规则，即在任何时刻，RefCell 只能有一个可变借用或多个不可变借用，但不能同时存在\n\n\nborrow 和 borrow_mut 方法:\nRefCell 提供了两个方法来获取对内部数据的借用：\nborrow()：获取不可变借用（Ref&lt;T&gt;），可以同时有多个\nborrow_mut()：获取可变借用（RefMut&lt;T&gt;），在同一时间只能有一个\n\n\n\n\n\n关键点\n借用规则:\nRefCell 在运行时检查借用规则，以防止数据竞争和未定义行为。编译器不进行这些检查，而是依赖 RefCell 在运行时进行\n\n\n运行时开销:\n因为 RefCell 需要在运行时检查借用规则，所以它会引入一定的性能开销。这在需要在编译时确定所有借用规则的场景中不可替代\n\n\n错误处理:\n如果违反了借用规则（例如，尝试同时获取多个可变借用），RefCell 会在运行时引发 panic\n\n\n\n使用场景\n数据结构:\n在需要可变性但又受限于 Rust 的所有权系统时，RefCell 允许在数据结构中使用内部可变性。例如，实现需要共享但修改的数据结构（如图、树）\n\n\n单线程环境:\nRefCell 主要用于单线程环境。如果你需要在多线程环境中处理内部可变性，应该使用 Mutex 或 RwLock 这类类型。\n\n\n\n引用循环与内存泄漏引用计数（Rc&lt;T&gt;）和原子引用计数（Arc&lt;T&gt;）可以让多个所有者共享同一个数据。然而，这种共享机制如果不当使用，可能会导致引用循环（reference cycle），从而造成内存泄漏\n例子use std::rc::Rc;use std::cell::RefCell;#[derive(Debug)]struct Node &#123;    value: i32,    next: Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,&#125;fn main() &#123;    let first = Rc::new(RefCell::new(Node &#123; value: 1, next: None &#125;));    let second = Rc::new(RefCell::new(Node &#123; value: 2, next: None &#125;));    // 创建引用循环    first.borrow_mut().next = Some(Rc::clone(&amp;second));    second.borrow_mut().next = Some(Rc::clone(&amp;first));    // 如果尝试打印引用计数，将看到引用循环已经发生    println!(&quot;first strong = &#123;&#125;, weak = &#123;&#125;&quot;, Rc::strong_count(&amp;first), Rc::weak_count(&amp;first));    println!(&quot;second strong = &#123;&#125;, weak = &#123;&#125;&quot;, Rc::strong_count(&amp;second), Rc::weak_count(&amp;second));    // println!(&quot;&#123;:?&#125;&quot;, &amp;first); // stack overflow&#125;\n\nWeak&lt;T&gt; 弱引用Weak&lt;T&gt; 的特点\n非所有权引用: Weak&lt;T&gt; 并不拥有数据的所有权，因此它不会影响 Rc&lt;T&gt; 的引用计数\n不会引发内存泄漏: 由于 Weak&lt;T&gt; 不增加引用计数，可以避免引用循环问题，从而避免内存泄漏\n必须升级: Weak&lt;T&gt; 是一个非所有权引用，因此在使用数据之前，需要通过 upgrade() 方法将其升级为 Rc&lt;T&gt;。如果数据已经被释放，upgrade() 会返回 None\n\n解决循环引用use std::cell::RefCell;use std::rc::&#123;Rc, Weak&#125;;#[derive(Debug)]struct Node &#123;    value: i32,    next: Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,    prev: Option&lt;Weak&lt;RefCell&lt;Node&gt;&gt;&gt;, // 添加一个弱引用来指向前一个节点&#125;fn main() &#123;    let first = Rc::new(RefCell::new(Node &#123;        value: 1,        next: None,        prev: None,    &#125;));    let second = Rc::new(RefCell::new(Node &#123;        value: 2,        next: None,        prev: None,    &#125;));    // 创建非循环引用    first.borrow_mut().next = Some(Rc::clone(&amp;second));    second.borrow_mut().prev = Some(Rc::downgrade(&amp;first));    // 如果尝试打印引用计数    println!(        &quot;first strong = &#123;&#125;, weak = &#123;&#125;&quot;,        Rc::strong_count(&amp;first),        Rc::weak_count(&amp;first)    ); // first strong = 1, weak = 1    println!(        &quot;second strong = &#123;&#125;, weak = &#123;&#125;&quot;,        Rc::strong_count(&amp;second),        Rc::weak_count(&amp;second)    ); // second strong = 2, weak = 0    // 因为 second 还拥有 first.borrow_mut().next 的所有权    println!(&quot;&#123;:?&#125;&quot;, &amp;first);&#125;\n\n强引用与弱引用的主要区别\n所有权:\n\n强引用 (Rc&lt;T&gt;): 持有数据的所有权，保证数据在作用域内不会被释放。\n弱引用 (Weak&lt;T&gt;): 不持有数据的所有权，不影响数据的生命周期。\n\n\n引用计数:\n\n强引用: 增加引用计数，数据被多个所有者共享。\n弱引用: 不增加引用计数，不干扰 Rc&lt;T&gt; 的生命周期管理。\n\n\n内存管理:\n\n强引用: 只有当所有强引用都被丢弃时，数据才会被释放。\n弱引用: 只能通过升级 (upgrade()) 来访问数据，如果数据已经被释放，则升级会失败。\n\n\n适用场景:\n\n强引用: 当你希望共享数据并确保数据在至少一个强引用存在时不会被释放。\n弱引用: 当你需要避免引用循环或只需要偶尔访问数据，不想持有其所有权时。\n\n\n\n课后作业任务: 实现一个简单的社交网络系统，包含用户和朋友关系。使用 Rc&lt;T&gt;, RefCell&lt;T&gt;, Weak&lt;T&gt; 来处理用户和朋友之间的关系，并避免循环引用导致的内存泄漏\n要求:\n\n用户结构: 每个用户拥有一个名字和一个朋友列表。\n添加朋友: 支持在两个用户之间建立朋友关系。\n展示朋友关系: 能够展示每个用户的朋友列表。\n循环引用: 处理用户之间的双向引用，确保不产生循环引用。\n\nuse std::cell::RefCell;use std::rc::&#123;Rc, Weak&#125;;struct User &#123;    name: String,    // 一个用户拥有一个朋友列表（Vec），这个列表存储的是对其他用户的弱引用（Weak）    // 每个朋友用户（即其他用户）需要具有内部可变性，所以每个朋友用户被包裹在 RefCell 中    // 用户自己需要能够修改朋友列表（添加朋友），所以整个列表被包裹在 RefCell 中以提供内部可变性    friends: RefCell&lt;Vec&lt;Weak&lt;RefCell&lt;User&gt;&gt;&gt;&gt;,&#125;impl User &#123;    // 用户对象需要：共享所有权（Rc）、提供内部可变性（RefCell）    fn new(name: &amp;str) -&gt; Rc&lt;RefCell&lt;Self&gt;&gt; &#123;        Rc::new(RefCell::new(User &#123;            name: name.to_string(),            friends: RefCell::new(Vec::new()),        &#125;))    &#125;    // 添加好友：在 user1 和 user2 之间建立好友关系    fn add_friend(user1: &amp;Rc&lt;RefCell&lt;Self&gt;&gt;, user2: &amp;Rc&lt;RefCell&lt;Self&gt;&gt;) &#123;        // 在 user1 的朋友列表中添加 user2 的弱引用        user1            .borrow_mut() // 获取 user1 的可变借用            .friends            .borrow_mut() // 获取 user1 好友列表的可变借用            .push(Rc::downgrade(user2)); // 添加 user2 的弱引用        // 在 user2 的朋友列表中添加 user1 的弱引用        user2            .borrow_mut()            .friends            .borrow_mut()            .push(Rc::downgrade((user1)));    &#125;    // 显示用户的好友列表    fn show_friends(&amp;self) &#123;        println!(&quot;&#123;&#125; 的朋友:&quot;, self.name);        // 遍历好友列表中的每个弱引用        for (i, friend) in self.friends.borrow().iter().enumerate() &#123;            // 将弱引用升级为强引用            if let Some(friend_rc) = friend.upgrade() &#123;                let friend_ref = friend_rc.borrow();                // 打印朋友名称                println!(&quot;  &#123;&#125;. &#123;&#125;&quot;, i + 1, friend_ref.name);            &#125;            // 朋友已释放（异常情况）            else &#123;                println!(&quot;  &#123;&#125;. [已移除的朋友]&quot;, i + 1);            &#125;        &#125;        println!(); // 添加空行分隔    &#125;&#125;fn main() &#123;    // 创建用户 Alice    let alice = User::new(&quot;Alice&quot;);    println!(        &quot;[创建] Alice, 初始强引用计数 = &#123;&#125;&quot;,        Rc::strong_count(&amp;alice)    );    // 创建用户 Bob    let bob = User::new(&quot;Bob&quot;);    println!(&quot;[创建] Bob, 初始强引用计数 = &#123;&#125;&quot;, Rc::strong_count(&amp;bob));    // 创建用户 Charlie    let charlie = User::new(&quot;Charlie&quot;);    println!(        &quot;[创建] Charlie, 初始强引用计数 = &#123;&#125;&quot;,        Rc::strong_count(&amp;charlie)    );    // 建立朋友关系    // 添加 Alice 和 Bob 为朋友    User::add_friend(&amp;alice, &amp;bob);    println!(&quot;[添加好友] Alice 和 Bob&quot;);    println!(        &quot;  Alice 强引用计数 = &#123;&#125;, 弱引用计数 = &#123;&#125;&quot;,        Rc::strong_count(&amp;alice),        Rc::weak_count(&amp;alice)    );    println!(        &quot;  Bob 强引用计数 = &#123;&#125;, 弱引用计数 = &#123;&#125;&quot;,        Rc::strong_count(&amp;bob),        Rc::weak_count(&amp;bob)    );    // 添加 Alice 和 Charlie 为朋友    User::add_friend(&amp;alice, &amp;charlie);    println!(&quot;[添加好友] Alice 和 Charlie&quot;);    println!(        &quot;  Alice 强引用计数 = &#123;&#125;, 弱引用计数 = &#123;&#125;&quot;,        Rc::strong_count(&amp;alice),        Rc::weak_count(&amp;alice)    );    println!(        &quot;  Charlie 强引用计数 = &#123;&#125;, 弱引用计数 = &#123;&#125;&quot;,        Rc::strong_count(&amp;charlie),        Rc::weak_count(&amp;charlie)    );    // 添加 Bob 和 Charlie 为朋友    User::add_friend(&amp;bob, &amp;charlie);    println!(&quot;[添加好友] Bob 和 Charlie&quot;);    println!(        &quot;  Bob 强引用计数 = &#123;&#125;, 弱引用计数 = &#123;&#125;&quot;,        Rc::strong_count(&amp;bob),        Rc::weak_count(&amp;bob)    );    println!(        &quot;  Charlie 强引用计数 = &#123;&#125;, 弱引用计数 = &#123;&#125;&quot;,        Rc::strong_count(&amp;charlie),        Rc::weak_count(&amp;charlie)    );    // 创建临时用户 Dave 来演示弱引用    &#123;        let dave = User::new(&quot;Dave&quot;);        println!(            &quot;[创建临时用户] Dave, 初始强引用计数 = &#123;&#125;&quot;,            Rc::strong_count(&amp;dave)        );        // 添加 Alice 和 Dave 为朋友        // 注意：这里只单向添加，避免循环引用        alice            .borrow_mut()            .friends            .borrow_mut()            .push(Rc::downgrade(&amp;dave));        println!(&quot;[添加好友] Alice 和 Dave（弱引用）&quot;);        println!(            &quot;  Alice 强引用计数 = &#123;&#125;, 弱引用计数 = &#123;&#125;&quot;,            Rc::strong_count(&amp;alice),            Rc::weak_count(&amp;alice)        );        println!(            &quot;  Dave 强引用计数 = &#123;&#125;, 弱引用计数 = &#123;&#125;&quot;,            Rc::strong_count(&amp;dave),            Rc::weak_count(&amp;dave)        );        // 展示 Alice 的朋友（包括 Dave）        println!(&quot;[展示 Alice 的完整朋友列表]&quot;);        alice.borrow().show_friends();        // 作用域结束，Dave 将被销毁        println!(&quot;[临时用户 Dave 离开作用域]&quot;);    &#125;    // 展示最终朋友关系    // 展示 Alice 的朋友列表（Dave 已消失）    println!(&quot;[Alice 的最终朋友列表]&quot;);    alice.borrow().show_friends();    // 展示 Bob 的朋友列表    println!(&quot;[Bob 的朋友列表]&quot;);    bob.borrow().show_friends();    // 展示 Charlie 的朋友列表    println!(&quot;[Charlie 的朋友列表]&quot;);    charlie.borrow().show_friends();    // 最终引用计数状态    println!(&quot;程序结束前引用计数状态:&quot;);    println!(        &quot;Alice: 强引用计数 = &#123;&#125;, 弱引用计数 = &#123;&#125;&quot;,        Rc::strong_count(&amp;alice),        Rc::weak_count(&amp;alice)    );    println!(        &quot;Bob: 强引用计数 = &#123;&#125;, 弱引用计数 = &#123;&#125;&quot;,        Rc::strong_count(&amp;bob),        Rc::weak_count(&amp;bob)    );    println!(        &quot;Charlie: 强引用计数 = &#123;&#125;, 弱引用计数 = &#123;&#125;&quot;,        Rc::strong_count(&amp;charlie),        Rc::weak_count(&amp;charlie)    );&#125;\n","categories":["Rust - IB课程"],"tags":["Rust"]},{"title":"IB-Rust-trait特性","url":"/2025/06/10/78-IB-Rust-trait%E7%89%B9%E6%80%A7/","content":"Codes in lesson20\ntrait 定义trait 定义了某个特定类型拥有可能与其他类型共享的功能\n\n trait 类似于其他语言中 接口（interfaces）的功能\n\ntrait 实现普通实现\n使用 trait 关键字声明一个特征\n在大括号中定义该特征的所有方法\n只定义特征方法的签名，而不进行实现，此时方法签名结尾是 ;，而不是 &#123;&#125;\n\npub trait Summary &#123;    fn summarize(&amp;self) -&gt; String;&#125;\n\n为类型实现特征pub trait Summary &#123;    fn summarize(&amp;self) -&gt; String;&#125;pub struct Post &#123;    pub title: String, // 标题    pub author: String, // 作者    pub content: String, // 内容&#125;impl Summary for Post &#123;    fn summarize(&amp;self) -&gt; String &#123;        format!(&quot;文章&#123;&#125;, 作者是&#123;&#125;&quot;, self.title, self.author)    &#125;&#125;pub struct Weibo &#123;    pub username: String,    pub content: String&#125;impl Summary for Weibo &#123;    fn summarize(&amp;self) -&gt; String &#123;        format!(&quot;&#123;&#125;发表了微博&#123;&#125;&quot;, self.username, self.content)    &#125;&#125;\n\n特征定义与实现的位置（孤儿规则）如果你想要为类型 A 实现特征 T，那么 A 或者 T 至少有一个是在当前作用域中定义的\n\n可以为上面的 Post 类型实现标准库中的 Display 特征，这是因为 Post 类型定义在当前的作用域中\n可以在当前包中为 String 类型实现 Summary 特征，因为 Summary 定义在当前作用域中\n无法在当前作用域中，为 String 类型实现 Display 特征，因为它们俩都定义在标准库中，而不是当前的作用域\n\n默认实现1、其它类型无需再实现该方法，也可以选择重载该方法pub trait Summary &#123;    fn summarize(&amp;self) -&gt; String &#123;        String::from(&quot;(Read more...)&quot;)    &#125;&#125;\n\nPost 选择了默认实现，而 Weibo 重载了该方法\nimpl Summary for Post &#123;&#125;impl Summary for Weibo &#123;    fn summarize(&amp;self) -&gt; String &#123;        format!(&quot;&#123;&#125;发表了微博&#123;&#125;&quot;, self.username, self.content)    &#125;&#125;\n\n2、默认实现 允许调用 相同特征中的其他方法，哪怕这些方法没有默认实现pub trait Summary &#123;    fn summarize_author(&amp;self) -&gt; String;    fn summarize(&amp;self) -&gt; String &#123;        format!(&quot;(Read more from &#123;&#125;...)&quot;, self.summarize_author())    &#125;&#125;impl Summary for Weibo &#123;    fn summarize_author(&amp;self) -&gt; String &#123;        format!(&quot;@&#123;&#125;&quot;, self.username)    &#125;&#125;println!(&quot;1 new weibo: &#123;&#125;&quot;, weibo.summarize());\n\n带泛型的 trait\n可以对同一个目标类型，多次 impl 此 trait，每次提供不同的泛型参数\n在具体方法调用的时候，必须通过类型标注明确使用的是哪一个具体的实现\n\n// 将元组结构体中的数据，转换为类型 Ttrait Converter&lt;T&gt; &#123;    fn convert(&amp;self) -&gt; T;&#125;struct MyInt(i32);impl Converter&lt;String&gt; for MyInt &#123;    fn convert(&amp;self) -&gt; String &#123;        // self.0 访问元组结构体的第 0 个元素        self.0.to_string()    &#125;&#125;impl Converter&lt;f32&gt; for MyInt &#123;    fn convert(&amp;self) -&gt; f32 &#123;        self.0 as f32    &#125;&#125;fn main() &#123;    let my_int = MyInt(42);    let output: String = my_int.convert();    println!(&quot;output is: &#123;&#125;&quot;, output);    let output: f32 = my_int.convert();    println!(&quot;output is: &#123;&#125;&quot;, output);&#125;\n\n关联类型关联类型是 trait 定义中的类型占位符，定义时不指定其具体的类型，在实现（impl）该 trait 时，才为这个关联类型赋予确定的类型\n关联类型方式只允许对目标类型实现一次\ntrait Converter &#123;    type Output;    fn convert(&amp;self) -&gt; Self::Output;&#125;impl Converter for MyInt &#123;    type Output = String;    fn convert(&amp;self) -&gt; Self::Output &#123;        self.0.to_string()    &#125;&#125;\n\n默认泛型类型参数默认泛型的例子fn add&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(a: T, b: T) -&gt; T &#123;// 相当于 fn add&lt;T: std::ops::Add&lt;T, Output = T&gt;&gt;(a: T, b: T) -&gt; T &#123;    a + b&#125;println!(&quot;add i8: &#123;&#125;&quot;, add(2i8, 3i8));println!(&quot;add f64: &#123;&#125;&quot;, add(1.23, 1.23));\n\n默认泛型类型参数加法之所以设置默认参数​，​是因为相同类型相加是最常见的情况\ntrait Add&lt;Rhs=Self&gt; &#123;    type Output;    fn add(self, rhs: Rhs) -&gt; Self::Output;&#125;\n\n&lt;Rhs=Self&gt; 定义了加法操作的​​右操作数类型​​：\n\nRhs 是 “Right-hand side”（右操作数）的缩写\n=Self 表示默认情况下右操作数与左操作数相同\n这是一个​​默认泛型参数​​语法，允许在实现时不显式指定类型\n\ntype Output; 定义加法操作的​​结果类型​​，具体类型在实现时确定\nfn add(self, rhs: Rhs) -&gt; Self::Output;\n\n接受两个参数：左操作数（self）和右操作数（rhs）\n返回 Output 关联类型定义的类型使用 move 语义转移所有权\n\n使用默认泛型类型参数use std::ops::Add;struct Point &#123;    x: i32,    y: i32,&#125;impl Add for Point &#123;    type Output = Point;    fn add(self, other: Point) -&gt; Point &#123;        Point &#123;            x: self.x + other.x,            y: self.y + other.y,        &#125;    &#125;&#125;fn main() &#123;    assert_eq!(        Point &#123; x: 1, y: 0 &#125; + Point &#123; x: 2, y: 3 &#125;,        Point &#123; x: 3, y: 3 &#125;    );&#125;\n\n自定义 Rhs 类型而不使用默认类型use std::ops::Add;struct Millimeters(u32);struct Meters(u32);impl Add&lt;Meters&gt; for Millimeters &#123;    type Output = Millimeters;    fn add(self, other: Meters) -&gt; Millimeters &#123;        Millimeters(self.0 + (other.0 * 1000))    &#125;&#125;\n\n使用特征作为函数参数impl Trait 语法可以使用任何实现了 Summary 特征的类型作为该函数的参数\npub fn notify(item: &amp;impl Summary) &#123;    println!(&quot;Breaking news! &#123;&#125;&quot;, item.summarize());&#125;\n\n除了单个约束条件，还可以通过 + 语法指定多个约束条件\npub fn notify(item: &amp;(impl Summary + Display)) &#123;&#125;\n\nTrait Bound 语法\nimpl Trait 适用于短小的例子，它是 trait bound 语法的语法糖\n更长的 trait bound 则适用于更复杂的场景\n除了单个约束条件，我们还可以通过 + 语法指定多个约束条件\n\npub fn notify&lt;T: Summary&gt;(item: &amp;T) &#123;    println!(&quot;Breaking news! &#123;&#125;&quot;, item.summarize());&#125;pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) &#123;&#125;\n\nTrait Bound 能做到而 impl Trait 做不到的能力pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) &#123;&#125;\n\n这适用于 item1 和 item2 允许是不同类型的情况（只要都实现了 Summary）。如果希望它们都是相同类型，就只能使用 trait bound 才能实现：\npub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) &#123;\n\n通过 where 简化 trait boundfn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 &#123;&#125;\n\nfn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32    where T: Display + Clone,          U: Clone + Debug&#123;&#125;\n\n使用特征约束有条件地实现方法或特征实现方法可以有条件地只为那些实现了特定 trait 的类型实现方法\n只有那些为 T 类型实现了 PartialOrd trait（允许比较）和 Display trait（允许打印）的 Pair&lt;T&gt; 才会实现 cmp_display 方法\nuse std::fmt::Display;struct Pair&lt;T&gt; &#123;    x: T,    y: T,&#125;// impl Pair&lt;i32&gt; &#123;//     fn new(x: i32, y: i32) -&gt; Self &#123;//         Self &#123; x, y &#125;//     &#125;// &#125;impl&lt;T&gt; Pair&lt;T&gt; &#123;    fn new(x: T, y: T) -&gt; Self &#123;        Self &#123; x, y &#125;    &#125;&#125;impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; &#123;    fn cmp_display(&amp;self) &#123;        if self.x &gt;= self.y &#123;            println!(&quot;The largest member is x = &#123;&#125;&quot;, self.x);        &#125; else &#123;            println!(&quot;The largest member is y = &#123;&#125;&quot;, self.y);        &#125;    &#125;&#125;\n\n返回实现了 trait 的类型impl Trait 语法在返回值中使用 impl Trait 语法，来返回实现了某个 trait 的类型\nfn returns_summarizable() -&gt; impl Summary &#123;    Weibo &#123;        username: String::from(&quot;horse_ebooks&quot;),        content: String::from(&quot;of course, as you probably already know, people&quot;),    &#125;&#125;\n\ndyn trait 语法返回实现了某个 trait（动态 trait） 的类型\n动态 trait 对象指定某种指针例如 &amp; 引用或 Box&lt;T&gt; 智能指针，还有 dyn keyword，以及指定相关的 trait 来创建 trait 对象\nfn returns_summarizable(switch: bool) -&gt; Box&lt;dyn Summary&gt;  &#123;    if switch &#123;        Box::new(Post &#123;            title: String::from(                &quot;Penguins win the Stanley Cup Championship!&quot;,            ),            author: String::from(&quot;Iceburgh&quot;),            content: String::from(                &quot;The Pittsburgh Penguins once again are the best \\                 hockey team in the NHL.&quot;,            ),        &#125;)    &#125; else &#123;        Box::new(Weibo &#123;            username: String::from(&quot;horse_ebooks&quot;),            content: String::from(                &quot;of course, as you probably already know, people&quot;,            ),        &#125;)    &#125;&#125;\n\n通过 derive 派生特征形如 #[derive(Debug)] 的代码是一种特征派生语法，被 derive 标记的对象会自动实现对应的默认特征代码，继承相应的功能\n\nDebug 特征有一套自动实现的默认代码，当给一个结构体标记后，就可以使用 println!(&quot;&#123;:?&#125;&quot;, s) 的形式打印该结构体的对象\nCopy 特征也有一套自动实现的默认代码，当标记到一个类型上时，可以让这个类型自动实现 Copy 特征，进而可以调用 copy 方法，进行自我复制\n\n#[derive(Debug, Clone)]struct Point &#123;    x: i32,    y: i32,&#125;fn main() &#123;    let p1 = &#123; x: 0, y: 1&#125;;    let p2 = p1;    println!(&quot;p1: &#123;:?&#125;&quot;, p1); // 可以打印，因为实现了 Copy 特征&#125;\n\n用于程序员输出的 DebugDebug trait 用于开启格式化字符串中的调试格式，允许以调试目的来打印一个类型的实例，可以在程序执行的特定时间点观察其实例\n例如，在使用 assert_eq! 宏时，Debug trait 是必须的。如果等式断言失败，这个宏就把给定实例的值作为参数打印出来，就能看到两个实例为什么不相等\n默认值的 DefaultDefault trait 会创建一个类型的默认值，Default 派生的实现调用了类型每部分的 default 函数，这意味着类型中所有的字段或值必须实现了 Default 才能派生 Default \n#[derive(Default)]pub struct Post &#123;    pub title: String,   // 标题    pub author: String,  // 作者    pub content: String, // 内容&#125;let post1 = Post::default();\n\n在 Option&lt;T&gt; 实例上使用 unwrap_or_default 方法时，Default trait 是必须的。如果 Option&lt;T&gt; 是 None，unwrap_or_default 将返回存储在 Option&lt;T&gt; 中 T 类型的 Default::default 的结果\nlet post2 = None.unwrap_or_default();\n\n练习题trait 的定义与实现use std::fmt::Display;// 不要需改 Item 的定义trait Item&lt;T = String&gt; &#123;    type Output: Display;    fn summarize(&amp;self) -&gt; Self::Output;&#125;// 不要需改 Apple 结构的定义struct Apple &#123;    name: String,&#125;impl Item for Apple &#123;    type Output = String; // 增加    fn summarize(&amp;self) -&gt; String &#123;        self.name.to_string()    &#125;&#125;// 不要需改 weibo 结构的定义struct Weibo &#123;    author: String,    content: String,&#125;impl Item for Weibo &#123;    type Output = String; // 增加    fn summarize(&amp;self) -&gt; String &#123;        format!(&quot;@&#123;&#125;:&#123;&#125;&quot;, self.author, self.content)    &#125;&#125;pub struct Container &#123;    // items: Vec&lt;Item&gt;,    items: Vec&lt;Box&lt;dyn Item&lt;Output = String&gt;&gt;&gt;, // 修改&#125;impl Container &#123;    pub fn iterator(&amp;self) &#123;        // for item in self.items &#123;        for item in &amp;self.items &#123; // 修改            println!(&quot;&#123;&#125;&quot;, item.summarize());        &#125;    &#125;&#125;fn main() &#123;    let apple = Apple &#123;        name: &quot;Apple&quot;.to_string(),    &#125;;    let w = Weibo &#123;        author: &quot;weibo&quot;.to_string(),        content: &quot;hello&quot;.to_string(),    &#125;;    let container = Container &#123;        // items: vec![apple, w],        items: vec![Box::new(apple), Box::new(w)], // 修改    &#125;;    container.iterator();&#125;\n","categories":["Rust - IB课程"],"tags":["Rust"]},{"title":"IB-Rust-智能指针&box","url":"/2025/06/04/74-IB-Rust-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88&box/","content":"Codes in lesson16\n智能指针智能指针概述智能指针（Smart Pointers）是一类数据结构，不仅包含一个指针，还附带一些额外的元数据和功能。智能指针实现了 Deref 和 Drop 两个 trait，使得它们可以像指针一样解引用并在离开作用域时自动清理资源\n智能指针作用\n资源管理\n自动管理资源的分配和释放，避免内存泄漏\n\n\n所有权与借用\nRust 的所有权系统通过智能指针来确保内存安全，避免数据竞争和悬垂指针\n\n\n复杂数据结构\n通过智能指针可以构建复杂的数据结构，如递归结构、共享数据等\n\n\n\nBOX&lt;T&gt;\nBox&lt;T&gt; 将类型 T 的值分配在堆上，而不是栈上\n当 Box 被销毁时，堆上的数据也会被销毁\n\nBox 的底层实现\n底层原理\nBox&lt;T&gt; 实际上是一个智能指针，内部包含一个指向堆上分配内存的裸指针\n当 Box&lt;T&gt; 被销毁时，其 Drop trait 会被调用，释放堆上的内存\n\n\n内存分配\nRust 使用系统的全局分配器（如 malloc 和 free）来管理堆内存\nBox::new 分配内存，Drop 释放内存\n\n\n安全性\nRust 的所有权系统确保 Box&lt;T&gt; 的内存安全。所有权转移时，堆内存的生命周期也会随之变化\n\n\n\nBox 的使用场景堆分配Box 最常见的用途是将数据分配在堆上，而不是栈上。这在处理较大数据结构、或数据结构的大小在编译时不确定时尤为重要\nlet b = Box::new(5);println!(&quot;b = &#123;&#125;&quot;, b);\n\n动态大小类型（DST）Box 允许处理动态大小类型，如 str 和 [T]\nlet s: Box&lt;str&gt; = &quot;Hello, world!&quot;.into();println!(&quot;s = &#123;&#125;&quot;, s);let arr: Box&lt;[i32]&gt; = vec![1, 2, 3, 4, 5].into_boxed_slice();println!(&quot;arr = &#123;:?&#125;&quot;, arr);\n\n递归数据结构递归数据结构需要指针类型引用自身，而 Box 提供了这一功能\nenum List &#123;    Cons(i32, Box&lt;List&gt;),    Nil,&#125;use List::&#123;Cons, Nil&#125;;fn main() &#123;    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));&#125;\n\n类型擦除Box&lt;dyn Trait&gt; 用于类型擦除，允许在运行时决定类型\ntrait Animal &#123;    fn speak(&amp;self);&#125;struct Dog;struct Cat;impl Animal for Dog &#123;    fn speak(&amp;self) &#123;        println!(&quot;Woof!&quot;);    &#125;&#125;impl Animal for Cat &#123;    fn speak(&amp;self) &#123;        println!(&quot;Meow!&quot;);    &#125;&#125;fn main() &#123;    let animals: Vec&lt;Box&lt;dyn Animal&gt;&gt; = vec![Box::new(Dog), Box::new(Cat)];    for animal in animals.iter() &#123;        animal.speak();    &#125;&#125;\n\ndyn 关键字dyn 关键字用于指定动态分发的类型，允许在运行时决定具体类型，可用于实现动态分发的 trait 对象\n内存管理和性能优化通过使用 Box，可以控制内存的分配和释放，从而优化性能和内存使用。例如，将大型数据结构放在堆上，而不是栈上，从而避免栈溢出\nlet large_array = Box::new([0u8; 1_000_000]);println!(&quot;Large array allocated on the heap.&quot;);\n\nBox 的优缺点\n优点\n提供堆内存分配，支持复杂数据结构\n与 Rust 的所有权系统完美集成，确保内存安全\n动态分配对象，实现类型擦除\n\n\n缺点\n需要堆内存分配和释放，可能带来性能开销\n不适合需要频繁分配和释放的场景\n\n\n\nDrop、Derefb 和 DerefMut\nDrop Trait\nDrop trait 定义了当一个值离开作用域时应该执行的操作\n例如：Box&lt;T&gt; 在超出作用域时会自动调用其 Drop trait，释放堆上的内存\n\n\nDeref Trait\nDeref trait 定义了如何将一个类型转换为引用\n例如：Box&lt;T&gt; 实现了 Deref，所以可以通过 * 运算符解引用获取其内部数据\n\n\n\nDrop TraitDrop trait 用于自定义当值离开作用域时执行的代码，通常用于释放资源（例如内存、文件句柄、网络连接等）\n定义和实现Drop trait 定义了一个 drop 方法，当值被释放时，Rust 会自动调用这个方法\npub trait Drop &#123;  fn drop(&amp;mut self);&#125;\n\nstruct Resource &#123;    name: String,&#125;// 正确实现标准库的 Drop traitimpl Drop for Resource &#123;    fn drop(&amp;mut self) &#123;        println!(&quot;&#123;&#125; is dropped&quot;, self.name);    &#125;&#125;fn box_study() &#123;    let _r1 = Resource &#123;        name: &quot;r1&quot;.to_string(),    &#125;;    &#123;        let _r2 = Resource &#123;            name: &quot;r2&quot;.to_string(),        &#125;;    &#125;  // r2 在这里离开作用域&#125;  // r1 在这里离开作用域fn main() &#123;    box_study();&#125;\n\nDeref TraitDeref trait 用于重载解引用运算符（*），允许定义自定义指针类型的解引用行为\n定义和实现Deref trait 定义了一个 deref 方法，该方法返回指向目标类型的引用\npub trait Deref &#123;  type Target: ?Sized;  fn deref(&amp;self) -&gt; &amp;Self::Target;&#125;\nuse std::ops::Deref;fn main() &#123;  let x = 5;  let y = MyBox::new(x);  println!(&quot;x = &#123;&#125;&quot;, x);  // 触发解引用运算符重载  // 等价于 *(y.deref())（编译器自动转换）  println!(&quot;y = &#123;&#125;&quot;, *y);&#125;struct MyBox&lt;T&gt;(T);// 构造函数实现impl&lt;T&gt; MyBox&lt;T&gt; &#123;    fn new(x: T) -&gt; MyBox&lt;T&gt; &#123;        MyBox(x)    &#125;&#125;impl&lt;T&gt; Deref for MyBox&lt;T&gt; &#123;  // 关联类型  type Target = T;  fn deref(&amp;self) -&gt; &amp;T &#123;    println!(&quot;deref called&quot;);    // 访问元组结构体的第一个字段    &amp;self.0  &#125;&#125;\n\nDerefMut Trait与 Deref 类似，DerefMut 用于重载可变解引用运算符（*），允许对自定义类型进行可变解引用\n定义和实现pub trait DerefMut: Deref &#123;  fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target;&#125;\n\nimpl&lt;T&gt; DerefMut for MyBox&lt;T&gt; &#123;  fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target &#123;    println!(&quot;deref called&quot;);    // 访问元组结构体的第一个字段    &amp;mut self.0  &#125;&#125;\n\n课后作业作业 1: 内存管理和性能优化创建一个大型数组并将其分配到堆上，然后测量和比较分配在堆和栈上的性能差异。\n创建一个包含 1_000_000 个元素的数组，分别将其分配在堆和栈上。使用 std::time::Instant 来测量分配和访问时间。\nuse std::time::Instant;fn main() &#123;  test_stack_allocation();  test_heap_allocation();&#125;fn test_stack_allocation() &#123;  // 栈上分配测试 (1,000,000 个整数)  let n = 1_000_000;  // 分配  let start = Instant::now();  let mut arr: [u32; 1_000_000] = [0; 1_000_000]; // 改用u32避免负数问题  let duration = start.elapsed();  println!(&quot;分配时间: &#123;:?&#125;&quot;, duration); // 分配时间: 58.75µs  // 写入  let start = Instant::now();  for i in 0..n &#123;      arr[i] = i as u32;  &#125;  let duration = start.elapsed();  println!(&quot;写入时间: &#123;:?&#125;&quot;, duration); // 写入时间: 7.7795ms  // 读取和求和  let start = Instant::now();  let mut sum: u64 = 0; // 使用u64来容纳大数字  for i in 0..n &#123;      sum += arr[i] as u64; // 将每个元素转为u64  &#125;  let duration = start.elapsed();  println!(&quot;读取时间: &#123;:?&#125;\\n&quot;, duration); // 读取时间: 7.601417ms&#125;fn test_heap_allocation() &#123;  // 堆上分配测试 (1,000,000 个整数)  let n = 1_000_000;  // 分配  let start = Instant::now();  let mut arr = Box::new([0u32; 1_000_000]); // 明确类型为u32  let duration = start.elapsed();  println!(&quot;分配时间: &#123;:?&#125;&quot;, duration); // 分配时间: 421.75µs  // 写入  let start = Instant::now();  for i in 0..n &#123;      arr[i] = i as u32;  &#125;  let duration = start.elapsed();  println!(&quot;写入时间: &#123;:?&#125;&quot;, duration); // 写入时间: 6.979958ms  // 读取和求和  let start = Instant::now();  let mut sum: u64 = 0;  for i in 0..n &#123;      sum += arr[i] as u64;  &#125;  let duration = start.elapsed();  println!(&quot;读取时间: &#123;:?&#125;&quot;, duration); // 读取时间: 7.15825ms&#125;\n\n作业2：实现一个简单的文件系统模拟\n目标实现一个简单的文件系统模拟，其中包含文件和文件夹的概念。文件夹可以包含文件和其他文件夹。使用 Box 来管理内存，并实现对文件系统的基本操作（如创建文件、创建文件夹、列出文件和文件夹）。\n\n作业要求\n\n定义 FileSystem trait 和 Node 枚举\nFileSystem trait 包含 create_file、create_folder 和 list_contents 方法。\nNode 枚举包含 File 和 Folder 变体。\n\n\n实现 FolderNode 结构体\nFolderNode 实现 FileSystem trait，包含 name 和 contents 字段。\n使用 Box 管理 contents 中的子节点。\n\n\n实现文件系统的基本操作\ncreate_file 方法在文件夹中创建文件。\ncreate_folder 方法在文件夹中创建子文件夹。\nlist_contents 方法列出文件夹的所有内容。\n\n\n测试文件系统的操作\n创建根文件夹并添加文件和文件夹。\n创建子文件夹并添加文件。\n列出文件夹的内容并输出文件系统结构。\n\n\n\n\n提示使用 Box 来管理 Folder 中的子节点。使用递归方法来遍历和列出文件和文件夹的内容。考虑使用 Vec 来存储文件夹的子节点。\n\n\ntrait FileSystem &#123;    fn create_file(&amp;mut self, name: &amp;str) -&gt; Result&lt;(), String&gt;;    fn create_folder(&amp;mut self, name: &amp;str) -&gt; Result&lt;(), String&gt;;    fn list_contents(&amp;self, indent: usize);&#125;// 定义 Node 枚举，包含：文件节点 和 文件夹节点enum Node &#123;    // File 和 Folder 是变体的名称    // (FileNode) 和 (FolderNode) 是变体关联的数据类型    File(FileNode),    Folder(FolderNode),&#125;// 文件节点结构struct FileNode &#123;    name: String,&#125;// 文件夹节点结构struct FolderNode &#123;    name: String,    contents: Vec&lt;Box&lt;Node&gt;&gt;, // 使用 Box&lt;Node&gt; 存储子节点&#125;impl FileSystem for FolderNode &#123;    fn create_file(&amp;mut self, name: &amp;str) -&gt; Result&lt;(), String&gt; &#123;        // 检查是否同名节点已存在        // *node 对 &amp;Box&lt;Node&gt; 解引用得到 Box&lt;Node&gt;        // **node 对 Box&lt;Node&gt; 解引用得到 Node 值        // &amp;**Node 取得对 Node 的引用（&amp;Node），为了避免所有权的移动        if self.contents.iter().any(|node| match &amp;**node &#123;            Node::File(f) =&gt; f.name == name,            Node::Folder(f) =&gt; f.name == name,        &#125;) &#123;            return Err(&quot;Name already exists&quot;.to_string());        &#125;        // 创建新文件        self.contents.push(Box::new(Node::File(FileNode &#123;            name: name.to_string(),        &#125;)));        Ok(())    &#125;    fn create_folder(&amp;mut self, name: &amp;str) -&gt; Result&lt;(), String&gt; &#123;        // 检查是否同名节点已存在        if self.contents.iter().any(|node| match &amp;**node &#123;            Node::File(f) =&gt; f.name == name,            Node::Folder(f) =&gt; f.name == name,        &#125;) &#123;            return Err(&quot;Name already exists&quot;.to_string());        &#125;        // 创建新文件夹        self.contents.push(Box::new(Node::Folder(FolderNode &#123;            name: name.to_string(),            contents: Vec::new(),        &#125;)));        Ok(())    &#125;fn list_contents(&amp;self, indent: usize) &#123;        // 递归列出所有内容        // .iter() 遍历 self.contents 中的每个元素（&amp;Box&lt;Node&gt; 类型）        // .enumerate() 会将迭代器转换为新的迭代器，新迭代器产生元组 (index, item)        for (i, node) in self.contents.iter().enumerate() &#123;            let is_last = i == self.contents.len() - 1;            let prefix = if is_last &#123; &quot;└──&quot; &#125; else &#123; &quot;├──&quot; &#125;;            let item_indent = indent + 2;            match &amp;**node &#123;                // &#123;:indent$&#125; 功能：创建指定数量的空格缩进                // indent$ 是一个 ​​命名参数占位符                // indents 的值为 item_indent                Node::File(file) =&gt; println!(                    &quot;&#123;:indent$&#125;&#123;&#125; &#123;&#125; (File)&quot;,                    &quot;&quot;,                    prefix,                    file.name,                    indent = item_indent                ),                Node::Folder(folder) =&gt; &#123;                    // 打印子文件夹名称作为父文件夹的子项                    println!(                        &quot;&#123;:indent$&#125;&#123;&#125; &#123;&#125; (Folder)&quot;,                        &quot;&quot;,                        prefix,                        folder.name,                        indent = item_indent                    );                    folder.list_contents(item_indent + 2);                &#125;            &#125;        &#125;    &#125;&#125;fn main() &#123;    // 创建根文件夹    let mut root = FolderNode &#123;        name: &quot;Root&quot;.to_string(),        contents: Vec::new(),    &#125;;    // 在根目录添加文件和文件夹    // 使用 .unwrap() 使得出现错误后 painc 退出程序    root.create_file(&quot;document.txt&quot;).unwrap();    root.create_folder(&quot;Pictures&quot;).unwrap();    root.create_folder(&quot;Music&quot;).unwrap();    // 在 Pictures 文件夹中添加文件    // .iter_mut() 获取集合的​​可变引用迭代器    // matches! 宏检查是否匹配模式（名字为 Pictures 的文件夹    // .map() 将 &amp;mut Box&lt;Node&gt; 类型转为 &amp;mut Node 类型    // pictures 的类型为 &amp;mut FolderNode    if let Some(Node::Folder(pictures)) = root        .contents        .iter_mut()        .find(|n| matches!(&amp;***n, Node::Folder(f) if f.name == &quot;Pictures&quot;))        .map(|n| &amp;mut **n)    &#123;        pictures.create_file(&quot;photo1.jpg&quot;).unwrap();        pictures.create_file(&quot;photo2.jpg&quot;).unwrap();    &#125;    // 在 Music 文件夹中添加文件    if let Some(Node::Folder(music)) = root        .contents        .iter_mut()        .find(|n| matches!(&amp;***n, Node::Folder(f) if f.name == &quot;Music&quot;))        .map(|n| &amp;mut **n)    &#123;        music.create_file(&quot;song1.mp3&quot;).unwrap();        music.create_folder(&quot;Classical&quot;).unwrap();    &#125;    // 列出整个文件系统结构    println!(&quot;File System Structure:&quot;);    root.list_contents(0);&#125;\n","categories":["Rust - IB课程"],"tags":["Rust"]},{"title":"IB-Rust-迭代器","url":"/2025/06/14/81-IB-Rust-%E8%BF%AD%E4%BB%A3%E5%99%A8&%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B/","content":"Codes in lesson23\n什么是迭代器？\n迭代器模式：对一系列项执行某些任务\n迭代器负责：\n遍历每个项\n确定序列（遍历）何时完成\n\n\nRust 的迭代器：\n懒惰的：除非调用消费迭代器的方法，否则迭代器本身没有任何效果\n\n\n\nlet v1 = vec![1, 2, 3];let v1_iter = v1.iter();// rust 的迭代器是懒惰的，除非调用消费迭代器的方法，否则本身没有效果for val in v1_iter &#123;    println!(&quot;got: &#123;val&#125;&quot;);&#125;\n\n迭代器的实现迭代器是一个能够逐一生成元素的对象。它提供了一个统一的接口，用于遍历容器中的元素，同时保证了类型安全和内存安全\n在 Rust 中，迭代器是实现了 Iterator trait 的对象。该 trait 定义了一个 next 方法，用于返回下一个元素\n所有迭代器都实现了 Iterator Trait，其定义于标准库，大致如下：\npub trait Iterator&#123;    type Item;    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;    // methods with default implementations elided&#125;\n\ntype Item 和 Self::item 定义了与此该 trait 关联的类型。实现 Iterator trait 需要定义一个 Item 类型，用于 next 方法的返回类型（迭代器的返回类型）\n关联类型关联类型是 Trait 中的类型占位符，它可以用于 Trait 的方法签名中，定义出包含某些类型的 Trait，而在实现前无需知道这些类型是什么\n关联类型与泛型的区别\n范型\n每次实现 Trait 时标注类型\n可以为一个类型多次实现某个 Trait（不同的泛型参数）\n\n\n关联类型\n无需标注类型\n无法为单个类型多次实现某个 Trait\n\n\n\nstruct Counter &#123;&#125;pub trait Iterator &#123;    type Item;    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;    // methods with default implementations elided&#125;impl Iterator for Counter &#123;    type Item = u32;    fn next(&amp;mut self) -&gt; Option&lt;u32&gt; &#123;        None    &#125;&#125;// // conflicting implementations of trait `Iterator` for type `Counter`// impl Iterator for Counter &#123;//     type Item = String;//     fn next(&amp;mut self) -&gt; Option&lt;String&gt; &#123;//         None//     &#125;// &#125;pub trait Iterator2&lt;T&gt; &#123;    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;&#125;impl Iterator2&lt;u32&gt; for Counter &#123;    fn next(&amp;mut self) -&gt; Option&lt;u32&gt; &#123;        None    &#125;&#125;impl Iterator2&lt;String&gt; for Counter &#123;    fn next(&amp;mut self) -&gt; Option&lt;String&gt; &#123;        None    &#125;&#125;\n\n简单迭代器let numbers = vec![1, 2, 3, 4, 5];let mut iter = numbers.iter(); // 创建迭代器（必须使用 mut）while let Some(num) = iter.next() &#123; // 使用迭代器逐一获取元素    println!(&quot;&#123;&#125;&quot;, num);&#125;\n\n\nnumbers.iter() 创建了一个迭代器，该迭代器按顺序返回 numbers 向量中的每个元素\niter.next() 返回迭代器中的下一个元素。如果没有更多元素，返回 None\n\n几个迭代的方法\n.iter()：在不可变引用上创建迭代器\n.into_iter()：创建的迭代器会获得所有权\n.iter_mut()：迭代可变的引用\n\n消耗迭代器的方法在标准库中，Iterator trait 有一些带默认实现的方法\n\n调用 next 的方法叫做“消耗型适配器”\n因为调用它们会把迭代器消耗尽\n\n\nsum 方法 也会耗尽迭代器\n取得迭代器的所有权\n通过反复调用 next，遍历所有元素\n每次迭代，把当前元素添加到一个总和里，迭代结束，返回总和\n\n\n\nlet v1 = vec![1, 2, 3];let v1_iter = v1.iter();let total: i32 = v1_iter.sum();println!(&quot;total: &#123;total&#125;&quot;);\n\n产生其他迭代器的方法定义在 Iterator trait 上的另外一些方法叫做“迭代器适配器”，可以把迭代器转换为不同种类的迭代器\n可以通过链式调用使用多个迭代器适配器来执行复杂的操作，这种调用可读性较高\nmap 方法.map() 允许对迭代器中的每个元素应用一个函数，并返回一个新的迭代器\nlet numbers = vec![1, 2, 3, 4, 5];let squares: Vec&lt;_&gt; = numbers.iter().map(|x| x * x).collect();println!(&quot;&#123;:?&#125;&quot;, squares);\n\n\n.map() 将一个闭包应用于每个元素，这里是计算平方\n.collect() 是消耗型适配器，将迭代器的结果收集到一个容器中，这里是 Vec&lt;i32&gt;\n\nfilter 方法.filter() 允许根据条件筛选元素，并返回满足条件的元素的迭代器\nlet numbers = vec![1, 2, 3, 4, 5];let even_numbers: Vec&lt;_&gt; = numbers.iter().filter(|&amp;x| x % 2 == 0).collect();println!(&quot;&#123;:?&#125;&quot;, even_numbers);\n\n\n.filter() 筛选出所有满足闭包条件（偶数）的元素\n\n自定义迭代器可以通过实现 Iterator trait 来创建自己的迭代器。必须实现 next 方法，定义迭代器如何产生下一个元素\nstruct Counter &#123;    count: u32,&#125;impl Counter &#123;    fn new() -&gt; Counter &#123;        Counter &#123; count: 0 &#125;    &#125;&#125;impl Iterator for Counter &#123;    type Item = u32;    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123;        self.count += 1;        if self.count &lt;= 5 &#123;            Some(self.count)        &#125; else &#123;            None        &#125;    &#125;&#125;fn main() &#123;    let mut counter = Counter::new();    while let Some(count) = counter.next() &#123;        println!(&quot;&#123;&#125;&quot;, count);    &#125;&#125;\n\n\nCounter 结构体实现了 Iterator trait，next 方法每次返回下一个计数值，直到 5 为止\n\n课后作业：实现自定义迭代器请你实现一个自定义迭代器，用于生成斐波那契数列。你的迭代器应该支持无限生成斐波那契数，直到用户停止迭代。\n\n任务要求：\n实现一个结构体 Fibonacci，并为它实现 Iterator trait。\n在 next 方法中生成下一个斐波那契数。\n编写一个测试函数，输出前 10 个斐波那契数。\n\n\n提示：\n你可以使用两个字段来存储当前和前一个斐波那契数。\ntake 方法是一个迭代器适配器，用于限制生成的数量。\n注意边界条件，例如处理第一个和第二个斐波那契数。\n\n\n\n示例：struct Fibonacci &#123;    // 在这里定义所需的字段&#125;impl Fibonacci &#123;    fn new() -&gt; Self &#123;        // 初始化结构体    &#125;&#125;impl Iterator for Fibonacci &#123;    type Item = u64;    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123;        // 实现斐波那契数生成逻辑    &#125;&#125;fn main() &#123;    let fib = Fibonacci::new();    for number in fib.take(10) &#123;        println!(&quot;&#123;&#125;&quot;, number);    &#125;&#125;\n\n额外挑战（可选）：\n修改迭代器，使其可以接受一个上限参数，当生成的斐波那契数超过这个上限时停止生成。\n实现一个 into_vec 方法，将生成的斐波那契数列转换为一个 Vec&lt;u64&gt;。\n\nstruct Fibonacci &#123;    cur: u64,    next: u64,    count: u64,    limit: u64,&#125;impl Fibonacci &#123;    fn new(limit: u64) -&gt; Self &#123;        Fibonacci &#123;            cur: 1,            next: 1,            count: 1,            limit: limit,        &#125;    &#125;    fn into_vec(&amp;mut self) -&gt; Vec&lt;u64&gt; &#123;        let mut v = vec![];        while let Some(count) = self.next() &#123;            v.push(count);        &#125;        v    &#125;&#125;impl Iterator for Fibonacci &#123;    type Item = u64;    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123;        let cur = self.cur;        self.cur = self.next;        self.next = cur + self.next;        if (self.count &lt;= self.limit) &#123;            self.count += 1;            Some(cur)        &#125; else &#123;            None        &#125;    &#125;&#125;fn main() &#123;    let mut fib = Fibonacci::new(5);    // for number in fib.take(10) &#123;    //     println!(&quot;&#123;&#125;&quot;, number);    // &#125;    for number in fib.into_vec().iter() &#123;        println!(&quot;&#123;&#125;&quot;, number);    &#125;&#125;\n","categories":["Rust - IB课程"],"tags":["Rust"]},{"title":"IB-Rust-macro宏","url":"/2025/06/11/79-IB-Rust-macro%E5%AE%8F/","content":"Codes in lesson21\n常用宏println!(&quot;Hello, world!&quot;); // 常用println! &#123;&quot;Hello, world!&quot;&#125;;println![&quot;Hello, world!&quot;];let v = vec![1, 2, 3, 4, 5];assert_eq!(1, 10);panic!(&quot;Something went wrong!&quot;);\n\n声明宏声明宏（Declarative Macros），也称为 macro_rules!，是最常⻅的宏类型。它们允许通过模式匹配来⽣成代码\n#[macro_export]macro_rules! say_hello &#123;    // 表示 0 个参数的情况    () =&gt; &#123;        println!(&quot;Hello, world!&quot;);    &#125;;&#125;fn main() &#123;    say_hello!();    say_hello! &#123;&#125;;    say_hello![];&#125;\n\n实现变长参数宏比起函数，可以实现变长参数\n变长参数是通过一种叫“重复模式”的机制实现的，它由三部分组成：\n\n​​捕获组​​ $( ... )：这表示一组可以重复的内容​- ​分隔符​​ ,：用来分隔多个参数（可以是其他符号）​- ​重复指示器​ * 或 + -​：表示这组内容可以重复多少次\n\nmacro_rules! my_macro &#123;    // 模式部分    // 捕获组 分隔符 重复指示器    ($($arg:expr),*) =&gt; &#123;        // 宏体中的重复代码        $(            // 这里处理每个 $arg            println!(&quot;Got argument: &#123;&#125;&quot;, $arg);        )*    &#125;;&#125;\n\n\n​​$($arg:expr)​​：捕获一个表达式并命名为 $arg\n$arg 是变量名（可以自定义）\n:expr 表示匹配的表达式类型​- ​,​​：每个参数之间的分隔符​​- *​​：表示这个模式可以匹配0次或多次\n+：表示匹配1次或多次（至少一个参数）\n\n\n\n处理不同的参数类型表达式（expressions）\n$($arg:expr),*  // 匹配任意表达式，如：1, &quot;text&quot;, 2+3, function_call()\n\n标识符（identifiers）\n$($name:ident),*  // 匹配变量名，如：x, my_var, data\n\n类型（types）\n$($t:ty),*  // 匹配类型名，如：i32, String, Vec&lt;u8&gt;\n\n任意令牌（tokens）\n$($token:tt),*  // 匹配任何语法元素，如：&gt;, ?, -&gt;, +=\n\n多种分隔符自定义分隔符，且支持不同分隔符的多个模式\nmacro_rules! print_multiple &#123;    // 空格分隔的模式    ($($arg:expr) *) =&gt; &#123;        $(            println!(&quot;Arg: &#123;&#125;&quot;, $arg);        )*    &#125;;    // 逗号分隔的模式    ($($arg:expr), *) =&gt; &#123;        $(            println!(&quot;Arg: &#123;&#125;&quot;, $arg);        )*    &#125;;    // 分号分隔的模式    ($($arg:expr); *) =&gt; &#123;        $(            println!(&quot;Arg: &#123;&#125;&quot;, $arg);        )*    &#125;;&#125;print_multiple![1 2 3];print_multiple![4, 5, 6];print_multiple![7; 8; 9];\n\n过程宏过程宏（Procedural Macros）允许使⽤函数⽣成代码，分为三种类型：\n\n派生宏\n属性宏（Attribute-like macro）\n函数宏（Function-like macro）\n\n过程宏在​​编译时​​执行，需要：\n\n作为独立的 crate 编写\n在 toml 文件中特殊标记（proc-macro &#x3D; true）\n接收 TokenStream 作为输入\n输出新的 TokenStream\n\n过程宏配置Cargo.toml 文件内容：\n[lib]proc-macro = true[dependencies]syn = &quot;2.0&quot;     # Rust语法解析器quote = &quot;1.0&quot;   # 代码生成器proc-macro2 = &quot;1.0&quot; # 过程宏工具\n\n项目结构：\nmy_macros/├── Cargo.toml└── src/    ├── main.rs          # 主入口    ├── derive_macros.rs # 派生宏    ├── attr_macros.rs  # 属性宏    └── fn_macros.rs    # 函数式宏\n\n派生宏派生宏 #[derive(MyMacro)] 用于自动为结构体和枚举实现 trait\n​​#[derive(Debug)]自动实现 std::fmt::Debug trait，用于调试输出\n#[derive(Debug)]struct Point &#123; x: i32, y: i32 &#125;println!(&quot;&#123;:?&#125;&quot;, Point &#123; x: 1, y: 2 &#125;); // Point &#123; x: 1, y: 2 &#125;\n\n​​#[derive(Clone)]自动实现 Clone trait，允许值复制\n#[derive(Clone)]struct Data &#123;    content: String,&#125;fn main() &#123;    let data = Data &#123; content: &quot;Hello&quot;.to_string() &#125;;    let cloned_data = data.clone();&#125;\n\n​​#[derive(Copy)]将类型标记为复制语义（需同时实现 Clone）\n#[derive(Copy, Clone)]struct Position &#123;    x: u8,    y: u8,&#125;fn main() &#123;    let pos1 = Position &#123; x: 5, y: 10 &#125;;    let pos2 = pos1; // 复制而非移动&#125;\n\n​​#[derive(PartialEq, Eq)]实现相等比较操作符 &#x3D;&#x3D; 和 !&#x3D;\n#[derive(PartialEq, Eq)]struct UserId(u64);fn main() &#123;    let id1 = UserId(1001);    let id2 = UserId(1002);    assert!(id1 != id2);&#125;\n\n​​#[derive(PartialOrd, Ord)]实现比较操作符 &lt;, &gt;, &lt;&#x3D;, &gt;&#x3D;\n#[derive(PartialOrd, Ord, PartialEq, Eq)]struct Priority(u8);fn main() &#123;    let p_low = Priority(1);    let p_high = Priority(10);    assert!(p_low &lt; p_high);&#125;\n\n​​#[derive(Default)]自动生成默认值实现\n#[derive(Default)]struct Settings &#123;    timeout: u32,    retry_count: u8,&#125;fn main() &#123;    let settings = Settings::default(); // timeout=0, retry_count=0&#125;\n\n属性宏属性宏 #[my_macro] 用于自定义属性处理\n#[cfg]用于条件编译\n#[cfg(target_os = &quot;windows&quot;)]fn get_system_info() -&gt; String &#123;    &quot;Windows system&quot;.to_string()#[cfg(target_os = &quot;linux&quot;)]fn get_system_info() -&gt; String &#123;    &quot;Linux system&quot;.to_string()&#125;fn main() &#123;    println!(&quot;Running on: &#123;&#125;&quot;, get_system_info());&#125;\n\n#[test]用于单元测试\n#[cfg(test)]mod tests &#123;    #[test]    fn test_addition() &#123;        assert_eq!(2 + 2, 4);    &#125;    #[test]    #[should_panic(expected = &quot;out of bounds&quot;)]    fn test_panic() &#123;        vec![1, 2, 3][10];    &#125;&#125;\n\n#[allow] &#x2F; #[warn] &#x2F; #[deny]用于代码检查控制\n#[allow(unused_variables)] // 允许未使用变量fn unused_example() &#123;    let x = 5; // 不会产生警告&#125;#[warn(missing_docs)] // 文档缺失警告pub struct NoDocumentation;#[deny(deprecated)] // 拒绝使用已弃用项目fn no_deprecated() &#123;    // 使用已弃用方法将导致编译错误&#125;\n\n#[repr]用于内存表示控制\n#[repr(C)] // C语言兼容内存布局struct CCompatible &#123;    x: u32,    y: u32,&#125;#[repr(packed)] // 无填充紧凑布局struct PackedData &#123;    flag: u8,    value: u32,&#125;\n\n函数宏函数宏 my_macro!() 是类似函数调用的宏\nprintln! &#x2F; format!用于格式化输出\nlet name = &quot;Alice&quot;;let age = 30;// 标准输出println!(&quot;Hello, &#123;&#125;! You are &#123;&#125; years old.&quot;, name, age);// 创建格式化字符串let greeting = format!(&quot;Hello, &#123;&#125;! Age: &#123;&#125;&quot;, name, age);\n\nvec!用于向量创建\n// 空向量let empty: Vec&lt;i32&gt; = vec![];// 指定元素的向量let numbers = vec![1, 2, 3, 4, 5];// 重复元素的向量let zeros = vec![0; 10]; // 10个0\n\nassert! &#x2F; assert_eq! &#x2F; assert_ne!用于测试断言\nfn calculate(a: i32, b: i32) -&gt; i32 &#123;    a + b&#125;fn main() &#123;    let result = calculate(2, 3);    assert!(result == 5);    assert_eq!(result, 5);    assert_ne!(result, 10);    // 带自定义消息    assert!(        result &gt; 0,         &quot;Result must be positive, got &#123;&#125;&quot;,         result    );&#125;\n\npanic!用于触发恐慌\nfn divide(numerator: f64, denominator: f64) -&gt; f64 &#123;    if denominator == 0.0 &#123;        panic!(&quot;Division by zero!&quot;);    &#125;    numerator / denominator&#125;\n\nfile!, line!, column!用于展示代码位置信息\nfn log(message: &amp;str) &#123;    println!(        &quot;[&#123;&#125;:&#123;&#125;:&#123;&#125;] &#123;&#125;&quot;,         file!(),         line!(),         column!(),        message    );&#125;fn main() &#123;    log(&quot;Starting program&quot;); // [src/main.rs:12:5] Starting program&#125;\n\nconcat!用于连接文字\nconst VERSION_STRING: &amp;str = concat!(    &quot;App v&quot;,     env!(&quot;CARGO_PKG_VERSION&quot;),     &quot; built at &quot;,     env!(&quot;BUILD_TIMESTAMP&quot;));fn main() &#123;    println!(&quot;&#123;&#125;&quot;, VERSION_STRING);&#125;\n\n课后习题通过 macro_rules! 实现对应的 macro，并通过测试 case\nassert_eq!(repeat!(&quot;x&quot;,3) ,&quot;xxx&quot;);assert_eq!(sum!(1,2,3,4,5), 15);assert_eq!(max_value!(1,8,9), 9);\n\n#[macro_export]macro_rules! repeat &#123;    // 基本情况：重复0次    ($item:expr, 0) =&gt; &#123;        &quot;&quot;    &#125;;    // 基本实现：重复n次    ($item:expr, $n:expr) =&gt; &#123;&#123;        // 创建足够大的字符串空间以容纳所有重复项        let mut result = String::with_capacity($item.len() * $n);        for _ in 0..$n &#123;            result.push_str($item);        &#125;        result    &#125;&#125;;&#125;macro_rules! sum &#123;    // 基本情况：单个元素    ($x:expr) =&gt; &#123; $x &#125;;    // 基本实现：递归处理多个元素    // $($y:expr),+ 匹配 除了第一个参数后面的所有参数    ($x:expr, $($y:expr),+) =&gt; &#123;&#123;        // $ 说明后面的 ($y),+ 是新的匹配参数        $x + sum!($($y),+)    &#125;&#125;;&#125;/// 查找多个值中的最大值的宏macro_rules! max_value &#123;    // 基本情况：两个值比较    ($x:expr, $y:expr) =&gt; &#123;        if $x &gt; $y &#123; $x &#125; else &#123; $y &#125;    &#125;;    // 递归处理多个值    ($x:expr, $($y:expr),+) =&gt; &#123;        max_value!($x, max_value!($($y),+))    &#125;;&#125;\n","categories":["Rust - IB课程"],"tags":["Rust"]},{"title":"IB-Rust-闭包","url":"/2025/06/11/80-IB-Rust-%E9%97%AD%E5%8C%85/","content":"Codes in lesson22\n闭包介绍\n什么是闭包？\n\n闭包是一个可以捕获所在环境中的变量的匿名函数\n闭包通过 || 符号定义，可以像普通函数一样调用，但与函数不同，闭包可以访问外部作用域的变量\n\n\n闭包的特点\n\n可以捕获周围作用域的变量\n支持作为参数传递给其他函数\n可以返回闭包作为函数的返回值\n闭包通常通过类型推断来确定参数和返回值的类型\n\n\n\n闭包定义let add_one = |x: i32| -&gt; i32 &#123; x + 1 &#125;;println!(&quot;&#123;&#125;&quot;, add_one(5));  // 输出：6\n\n省略类型的闭包Rust 可以推断闭包的参数和返回值类型，因此在很多情况下可以省略类型声明\nlet add_one = |x| x + 1;println!(&quot;&#123;&#125;&quot;, add_one(5));  // 输出：6\n\n闭包的使用作为函数参数闭包可以作为函数的参数传递，从而实现更灵活的代码结构\nfn apply_to_3&lt;F&gt;(f: F) -&gt; i32where    F: Fn(i32) -&gt; i32,&#123;    f(3)&#125;let double = |x| x * 2;println!(&quot;&#123;&#125;&quot;, apply_to_3(double));  // 输出：6\n\n捕获环境变量闭包可以捕获并使用其定义所在环境中的变量\nlet x = 4;// // can&#x27;t capture dynamic environment in a fn item// fn equal_to_x(z: i32) &#123;//     z = x;// &#125;let equal_to_x = |z| z == x;let y = 4;assert!(equal_to_x(y));\n\n\n闭包的三种捕获方式\n\n按值捕获（move 语义）：将环境变量的所有权移入闭包\n按引用捕获：通过引用捕获环境变量\n按可变引用捕获：通过可变引用捕获环境变量\n\nlet mut num = 5;// 默认按引用捕获，获取 num 的引用let add_num = |x: i32| x + num;println!(&quot;&#123;&#125;&quot;, add_num(3));  // 输出：8// 按可变引用捕获，获取 num 的可变引用let mut change_num = |x: i32| num += x;change_num(5);println!(&quot;&#123;&#125;&quot;, num);  // 输出：10\n\n闭包的原理\n自动实现的函数类型\n\nFn、FnMut 和 FnOnce 是 Rust 提供的三种函数闭包类型，分别表示按引用捕获、按可变引用捕获和按值捕获\n\n\n闭包的类型推断\n\nRust 能够根据闭包的使用上下文推断出闭包的具体类型\nFn、FnMut 和 FnOnce 是闭包在不同情况下自动实现的 trait\n\n\n生命周期与闭包\n\n闭包可以捕获引用，但需要保证引用的生命周期超过闭包的生命周期\n\n\n\nlet s = String::from(&quot;hello&quot;);let closure = || println!(&quot;&#123;&#125;&quot;, s);closure();  // 正常运行，因为 s 在closure 之前有效\n\n\n创建闭包时，通过闭包对环境值的使用，Rust 能推断出具体使用哪个 trait:\n\n所有的闭包都实现了 FnOnce\n没有 move 捕获变量的实现了 FnMut\n无需可变访问捕获变量的闭包实现了 Fn\n\nmove 关键字在参数列表前使用 move 关键字，可以强制闭包取得它所使用用的环境值的所有权。一般用于：将闭包传递给新线程以移动数据使其归新线程所有\nlet x = vec![1, 2, 3];let equal_to_x = move |z| z = x; // drop xprintln!(&quot;can&#x27;t use x here: &#123;:?&#125;&quot;, x);let y = vec![1,2,3];equal_to_x(y); // drop yprintln!(&quot;can&#x27;t use y here: &#123;:?&#125;&quot;, y);\n\n课后习题假设你正在开发一个博客系统，其中每个用户可以查看不同的文章页面。页面的渲染是一个计算密集型的过程，可能涉及数据库查询、模板渲染等操作。因此，为了优化性能，你决定在服务器端实现一个缓存系统。\n要求：\n\n实现 PageCache 结构体：\n该结构体应缓存根据 用户ID 和 文章ID 渲染的页面。\n你需要为该结构体实现一个 get_page 方法，该方法接受 用户ID 和 文章ID，并返回渲染后的页面内容。\n如果相同的 用户ID 和 文章ID 已经渲染过，则 get_page 应直接返回缓存的页面，而不是重新渲染。\n\n\n\n通用性：\n\nPageCache 应支持任意类型的 用户ID（例如，u32 或 String）和 文章ID。\n缓存的内容应为渲染后的 HTML页面（String 类型）。\n\n示例：\nfn main() &#123;    let mut page_cache = PageCache::new(|user_id: &amp;str, article_id: u32| -&gt; String &#123;        println!(&quot;Rendering page for user &#123;&#125; and article &#123;&#125;&quot;, user_id, article_id);        format!(&quot;Rendered HTML content for user &#123;&#125; and article &#123;&#125;&quot;, user_id, article_id)    &#125;);    // 第一次调用，会执行页面渲染    println!(&quot;&#123;&#125;&quot;, page_cache.get_page(&quot;user1&quot;, 42)); // 输出 &quot;Rendering page for user1 and article 42&quot; 和 &quot;Rendered HTML content for user user1 and article 42&quot;        // 第二次调用，直接返回缓存结果    println!(&quot;&#123;&#125;&quot;, page_cache.get_page(&quot;user1&quot;, 42)); // 仅输出 &quot;Rendered HTML content for user user1 and article 42&quot;，不再渲染    // 不同用户查看同一文章，会重新渲染    println!(&quot;&#123;&#125;&quot;, page_cache.get_page(&quot;user2&quot;, 42)); // 输出 &quot;Rendering page for user2 and article 42&quot; 和 &quot;Rendered HTML content for user user2 and article 42&quot;&#125;\n\nuse std::collections::HashMap;use std::hash::Hash;struct PageCache&lt;K, V&gt; &#123;    cache: HashMap&lt;(K, V), String&gt;,&#125;impl&lt;K, V&gt; PageCache&lt;K, V&gt;where    K: Clone + Eq + Hash,    V: Clone + Eq + Hash,&#123;    fn new() -&gt; Self &#123;        PageCache &#123;            cache: HashMap::new(),        &#125;    &#125;    fn get_page&lt;F&gt;(&amp;mut self, user_id: K, article_id: V, render: F) -&gt; String    where        F: FnOnce(&amp;K, &amp;V) -&gt; String, // FnOnce 确保闭包只能被调用一次    &#123;        // 缓存键        let cache_key = (user_id.clone(), article_id.clone());        // 检查缓存是否存在        if let Some(content) = self.cache.get(&amp;cache_key) &#123;            // 缓存命中            content.clone()        &#125; else &#123;            // 缓存未命中：调用渲染函数生成新内容            let content = render(&amp;user_id, &amp;article_id);            // 将新内容存入缓存（使用原始数据避免克隆开销）            self.cache.insert((user_id, article_id), content.clone());            content        &#125;    &#125;&#125;fn main() &#123;    // 创建空缓存实例    let mut page_cache = PageCache::new();    // 第一次调用：执行渲染并缓存结果    println!(        &quot;&#123;&#125;&quot;,        page_cache.get_page(&quot;user1&quot;, 42, |user_id, article_id| &#123;            println!(                &quot;Rendering page for user &#123;&#125; and article &#123;&#125;&quot;,                user_id, article_id            );            format!(                &quot;Rendered HTML content for user &#123;&#125; and article &#123;&#125;&quot;,                user_id, article_id            )        &#125;)    );    // 第二次调用：相同用户和文章 - 直接返回缓存    println!(        &quot;&#123;&#125;&quot;,        page_cache.get_page(&quot;user1&quot;, 42, |_, _| &#123;            // 这个闭包在缓存命中时不会执行            unreachable!(&quot;This should never be called when cache exists&quot;);        &#125;)    );    // 不同用户：重新执行渲染    println!(        &quot;&#123;&#125;&quot;,        page_cache.get_page(&quot;user2&quot;, 42, |user_id, article_id| &#123;            println!(                &quot;Rendering page for user &#123;&#125; and article &#123;&#125;&quot;,                user_id, article_id            );            format!(                &quot;Rendered HTML content for user &#123;&#125; and article &#123;&#125;&quot;,                user_id, article_id            )        &#125;)    );&#125;","categories":["Rust - IB课程"],"tags":["Rust"]},{"title":"IB-Rust-测试","url":"/2025/06/14/82-IB-Rust-%E6%B5%8B%E8%AF%95/","content":"Codes in lesson24.1\nCodes in lesson24.2\nUnit Test测试结构基本单元测试使用 #[cfg(test)] 属性标记测试模块：\n#[cfg(test)]mod tests &#123;    // 导入要测试的模块    use super::*;        #[test]    fn it_works() &#123;        assert_eq!(2 + 2, 4);    &#125;        #[test]    fn test_add() &#123;        assert_eq!(add(1, 2), 3);    &#125;&#125;\n\n常用测试宏​​assert!​​验证布尔表达式为 true\n#[test]fn test_assert() &#123;    let result = true;    assert!(result);&#125;\n\n​​assert_eq!​​比较两个值是否相等\n#[test]fn test_equality() &#123;    assert_eq!(&quot;hello&quot;, &quot;hello&quot;);&#125;\n\n​​assert_ne!​​比较两个值是否不相等\n#[test]fn test_inequality() &#123;    assert_ne!(&quot;foo&quot;, &quot;bar&quot;);&#125;\n\n​​should_panic​​测试是否如预期般 panic\n#[test]#[should_panic(expected = &quot;除数为零&quot;)]fn test_divide_by_zero() &#123;    1 / 0;&#125;\n\n测试生命周期测试函数生命周期使用 #[test] 标记的函数有独立的生命周期：\n\n每个测试在自己的线程中运行\n测试失败只会导致该线程崩溃，不会影响其他测试\n返回值必须是 () 类型（单元类型）\n\n测试前准备与清理使用 setup 和 teardown 函数进行测试环境的准备和清理：\n#[cfg(test)]mod tests &#123;    struct TestFixture &#123;        value: i32,    &#125;    impl TestFixture &#123;        fn new() -&gt; Self &#123;            println!(&quot;创建测试环境&quot;);            TestFixture &#123; value: 42 &#125;        &#125;    &#125;    impl Drop for TestFixture &#123;        fn drop(&amp;mut self) &#123;            println!(&quot;清理测试环境&quot;);        &#125;    &#125;        #[test]    fn test_with_fixture() &#123;        let fixture = TestFixture::new();        assert_eq!(fixture.value, 42);    &#125;&#125;\n\n多测试共享环境使用生命周期更长的结构体：\n#[cfg(test)]mod tests &#123;    static mut TEST_VALUE: i32 = 0;        #[test]    fn test_one() &#123;        unsafe &#123; TEST_VALUE = 42 &#125;;        assert_eq!(unsafe &#123; TEST_VALUE &#125;, 42);    &#125;    #[test]    fn test_two() &#123;        assert_eq!(unsafe &#123; TEST_VALUE &#125;, 0);    &#125;&#125;\n\n测试私有函数Rust 允许在测试中访问私有函数：\nmod my_module &#123;    pub fn public_func() -&gt; i32 &#123;        private_func()    &#125;    fn private_func() -&gt; i32 &#123;        42    &#125;        #[cfg(test)]    mod tests &#123;        use super::*;        #[test]        fn test_private_func() &#123;            assert_eq!(private_func(), 42);        &#125;    &#125;&#125;\n\n高级测试功能忽略测试使用 #[ignore] 标记暂时不运行的测试：\n#[test]#[ignore = &quot;功能尚未实现&quot;]fn expensive_test() &#123;    // 耗时的测试&#125;\n\n测试组合使用组合多个属性：\n#[test]#[ignore]#[should_panic(expected = &quot;预期错误&quot;)]fn complex_test() &#123;    // ...&#125;\n\n数据驱动测试使用循环或宏创建多组测试数据：\n#[test]fn test_addition() &#123;    let test_cases = vec![        (1, 1, 2),        (2, 3, 5),        (-1, 1, 0),        (0, 0, 0),    ];    for (a, b, expected) in test_cases &#123;        assert_eq!(a + b, expected);    &#125;&#125;\n\n测试运行与管理运行测试# 运行所有测试cargo test# 运行特定测试（名称匹配）cargo test test_add# 运行被忽略的测试cargo test -- --ignored# 在测试通过时显示输出cargo test -- --nocapture# 单线程运行测试（避免状态共享问题）cargo test -- --test-threads=1\n\n测试覆盖率使用 tarpaulin 或 cargo llvm-cov 获取测试覆盖率：\n# 安装 tarpaulincargo install cargo-tarpaulin# 运行测试覆盖率cargo tarpaulin --ignore-tests\n\nIntegration TestRust 集成测试 用于测试库的公共 API，验证多个模块协同工作的情况。与单元测试关注内部实现不同，集成测试从外部用户的角度验证程序功能\n集成测试核心概念位置与约定默认放在项目根目录的 tests 目录中，每个测试文件都是独立的 crate，Cargo自动发现并运行这些测试\nproject/├── Cargo.toml├── src/│   └── lib.rs└── tests/    ├── integration_test1.rs    ├── integration_test2.rs    └── common/        └── mod.rs  # 共享辅助代码\n\n注意：使用 common&#x2F;mod.rs 而不是 common.rs\n基本特点\n仅能访问公共API\n测试完整工作流程\n模拟外部依赖\n可测试多个模块组合行为\n\n创建集成测试基本结构// tests/basic_integration.rsuse my_library;  // 导入被测试的库#[test]fn test_add() &#123;    assert_eq!(my_library::add(2, 3), 5);&#125;\n\n运行集成测试cargo test --test integration_test_name  # 运行特定测试文件cargo test                               # 运行所有测试（包括单元测试）\n\n高级集成测试技巧共享辅助代码在 tests&#x2F;common&#x2F;mod.rs 中创建共享功能：\n// tests/common/mod.rspub fn setup() &#123;    println!(&quot;测试环境准备&quot;);    // 数据库连接、网络模拟等&#125;pub fn teardown() &#123;    println!(&quot;清理测试环境&quot;);&#125;\n\n在测试文件中使用：\n// tests/advanced_integration.rsmod common;use common::&#123;setup, teardown&#125;;use my_library;#[test]fn test_complex_operation() &#123;    setup(); // set up    let result = my_library::complex_operation();    assert!(result.is_ok());    teardown(); // tear down&#125;\n\n测试模块组织// tests/api/mod.rs - 核心测试模块pub mod v1;pub mod v2;// tests/api/v1.rs - API版本1测试#[test]fn test_api_v1() &#123; /* ... */ &#125;\n\n集成测试报告# 生成 HTML 报告cargo test --test integration_tests -- --format json | cargo2html -o report.html# 使用 cargo-tarpaulin 获取覆盖率cargo tarpaulin --integration-tests --out Html\n\nDoc Tests文档测试通过允许将测试代码直接嵌入到文档注释中，来确保文档示例始终与代码行为保持一致，该机制极大增强了 Rust 生态系统的文档质量\n基本概念什么是文档测试？Rust 支持将可执行代码示例直接嵌入到文档注释中。当运行 cargo test 时，这些代码块会被提取、编译并作为测试运行，目标是确保文档中的示例始终正确有效\n核心价值\n​​文档与代码同步​​：示例代码随功能变化自动更新​- ​可信文档​​：用户可信任通过测试的文档示例​- ​开发者便利​​：编写文档的同时就创建了测试用例\n\n基础语法基本文档测试/// 计算两数之和////// # 示例////// ```/// let sum = my_crate::add(2, 3);/// assert_eq!(sum, 5);/// ```pub fn add(a: i32, b: i32) -&gt; i32 &#123;    a + b&#125;\n\n模块级文档测试//! # My Crate//!//! 提供数学运算功能//!//! ## 示例//!//! ```//! use my_crate;//!//! let result = my_crate::multiply(3, 4);//! assert_eq!(result, 12);//! ```pub fn multiply(a: i32, b: i32) -&gt; i32 &#123;    a * b&#125;\n\n文档测试工作机制编译与执行流程\n​​文档解析​​：rustdoc 提取文档中的代码块​2. ​测试代码生成​​：\n自动添加 extern crate 语句\n将代码包装到 fn main() &#123; ... &#125; 中\n添加必要的 use 语句​3. ​独立编译​​：每个文档测试作为独立 crate 编译​​4. 测试执行​​：编译后作为普通测试运行\n\n\n\n生成的测试代码（示例）原始文档注释：\nlet result = add(2, 3);assert_eq!(result, 5);\n\n实际执行的测试代码：\nextern crate my_crate;use my_crate::add;fn main() &#123;    let result = add(2, 3);    assert_eq!(result, 5);&#125;#[test]fn test_name() &#123;    main();&#125;\n\n高级使用技巧隐藏辅助代码使用 # 隐藏辅助代码（在文档中不显示，但在测试中包含）：\n/// ```/// # // 这行在文档中隐藏/// # fn setup() -&gt; String &#123; String::from(&quot;world&quot;) &#125;/// let s = setup();/// assert_eq!(s, &quot;world&quot;);/// ```\n\n文档展示效果：\nlet s = setup();assert_eq!(s, &quot;world&quot;);\n\n测试错误处理使用 should_panic 属性测试预期 panic：\n/// ```should_panic/// # struct NonPositive;/// my_crate::divide(10, 0); // 应当 panic/// ```pub fn divide(a: i32, b: i32) -&gt; i32 &#123;    if b == 0 &#123;        panic!(&quot;除零错误&quot;);    &#125;    a / b&#125;\n\n编译期测试使用 compile_fail 确保代码无法编译：\n/// ```compile_fail/// // 类型不匹配示例/// let s: String = 42; // 无法将整数转换为字符串/// ```\n\n定制测试属性通过内联属性控制测试行为：\n/// ```no_run/// // 这段代码会编译但不会运行/// let result = fetch_data_from_internet();/// ```/// ```ignore/// // 完全忽略此测试代码/// not_implemented_yet();/// ```\n\n使用返回值测试直接在文档注释中返回值：\n/// ```/// # use my_crate::sqrt;/// assert_eq!(sqrt(9.0)?, 3.0); // 使用 ? 返回错误/// # Ok::&lt;(), &amp;&#x27;static str&gt;(())/// ```\n\n文档测试属性控制Crate 级属性配置在 lib.rs 或 main.rs 顶部全局配置：\n#![doc(test(attr(    // 为所有文档测试启用 unstable 特性    allow(unused_imports),    feature(staged_api))))]#![doc(test(attr(deny(warnings))))] // 将所有警告视为错误\n\n文档测试最佳实践\n测试文档覆盖原则\n每个公共 API 都应该有文档测试\n重点关注边界情况和错误处理\n避免过度测试简单 getter&#x2F;setter\n\n\n性能优化策略\n保持示例简洁（不超过 10-15 行）\n复杂逻辑拆分为多个测试\n\n\n\nBenchesRust 的基准测试 (Benchmarks) 是用于评估代码性能的核心工具。Rust 提供了强大的基准测试框架，帮助开发者对代码性能进行定量分析和优化\n基准测试概览基准测试的目的\n​​性能度量​​：测量代码执行时间​- ​性能对比​​：比较不同实现的速度差异​- ​回归检测​​：防止性能退化​​- 优化依据​​：确定优化点并量化效果\n\n基准测试的特点\n​​精确测量​​：使用高精度计时器​- ​统计分析​​：计算平均值、离群值等​​- 内存分析​​：可集成内存分配器​​- 编译器优化控制​​：通过 black_box 避免过度优化\n\n原生基准测试框架（test crate）Rust 标准库提供了内置基准测试支持，但需要 nightly 版本：\n#![feature(test)]extern crate test;use test::Bencher;#[bench]fn bench_add(b: &amp;mut Bencher) &#123;    b.iter(|| &#123;        (0..1000).sum::&lt;u64&gt;()    &#125;);&#125;\n\n关键组件\n​​Bencher​​：基准测试控制器​- ​iter 方法​​：包含要测量的代码​​- black_box​​：防止编译器优化\n\n编译与运行rustup run nightly cargo bench\n\n输出示例：\ntest bench_add ... bench:       1,234 ns/iter (+/- 123)\n\nExamplesRust 中的示例测试是位于项目 examples&#x2F; 目录下的可执行文件，它们作为项目的高级文档，展示如何使用库的实际应用场景。与文档测试中的小代码片段不同，示例测试提供了更完整、更真实的用法演示\n项目结构与约定标准目录结构my_crate/├── Cargo.toml├── src/│   └── lib.rs└── examples/    ├── basic_usage.rs    ├── advanced_usage.rs    └── demo_setup/        ├── main.rs        └── helper.rs\n\n命名约定\n文件: examples&#x2F;some_example.rs\n二进制名称: cargo run –example some_example\n\n创建基础示例// examples/basic_demo.rsuse my_crate::&#123;add, multiply&#125;;fn main() &#123;    // 展示基本功能    println!(&quot;2 + 3 = &#123;&#125;&quot;, add(2, 3));    println!(&quot;2 × 3 = &#123;&#125;&quot;, multiply(2, 3));    // 包含错误处理    match my_crate::divide(10, 2) &#123;        Ok(result) =&gt; println!(&quot;10 / 2 = &#123;&#125;&quot;, result),        Err(e) =&gt; println!(&quot;Error: &#123;&#125;&quot;, e),    &#125;&#125;\n\n测试与验证指令编译验证cargo test --examples  # 尝试编译所有示例cargo build --examples  # 构建所有示例\n\n运行测试cargo run --example basic_democargo run --example network_client\n\n多文件示例使用目录包含多个源文件：\nexamples/└── complex_demo/    ├── main.rs    ├── network.rs    └── processors.rs\n\n在 Cargo.toml 中配置：\n[[example]]name = &quot;complex_demo&quot;path = &quot;examples/complex_demo/main.rs&quot;\n\n目录结构规范.├── Cargo.lock├── Cargo.toml├── src/│   ├── lib.rs│   ├── main.rs│   └── bin/│       ├── named-executable.rs│       ├── another-executable.rs│       └── multi-file-executable/│           ├── main.rs│           └── some_module.rs├── benches/  # 基准测试│   ├── large-input.rs│   └── multi-file-bench/│       ├── main.rs│       └── bench_module.rs├── examples/  # 示例│   ├── simple.rs│   └── multi-file-example/│       ├── main.rs│       └── ex_module.rs└── tests/  # 集成测试    ├── some-integration-tests.rs    └── multi-file-test/        ├── main.rs        └── test_module.rs\n\n课后习题参考如下模版，创建并发布一个 crate 到 crates.io\n关注点：\n\n单元测试\n继承测试\ndoc 测试\nexamples\n项目规范\n\n!()[https://github.com/ibuidl/template-lib-crate]\n进阶修改 ci.yaml，通过 github actions 自动更新 crate\n","categories":["Rust - IB课程"],"tags":["Rust"]},{"title":"IB-Rust-并发2","url":"/2025/06/16/84-IB-Rust-%E5%B9%B6%E5%8F%912/","content":"Codes in lesson26\n使用共享来实现并发\nGo 语言：不要用共享内存来通信，要用通信来共享内存\nRust 支持通过共享状态来实现并发\nChannel 类似单所有权：一旦将值的所有权转移至 Channeel，就无法使用它了\n共享内存并发类似多所有权：多个线程可以同时访问同一块内存\n\n使用 Mutex 来每次只允许一个线程来访问数据\nMutex 是 mutualexclusion（互斥锁）的简写\n在同一时刻，Mutex 只允许一个线程来访问某些数据\n想要访问数据：\n线程必须首先获取互斥锁（lock）\nlock 数据结构是 mutex 的一部分，它能跟踪谁对数据拥有独占访问权\n\n\n\nMutex 的两条规则\n在使用数据之前，必须尝试获取锁（lock）\n使用完 mutex 所保护的数据，必须对数据进行解锁，以便其它线程可以获取锁\n\nMutex&lt;T&gt; 的 API通过 Mutex::new(数据) 来创建 Mutex&lt;T&gt;（智能指针）\n\n访问数据前，通过 lock 方法来获取锁\n会阻塞当前线程\nlock 有可能会失败\n返回的是 MutexGuard（智能指针，实现了 Deref 和 Drop 两个 trait）\n\n\n\nlet m = Mutex::new(5); // 5 就是要保护的数据&#123;    let mut num = m.lock().unwrap();    *num = 6;    // 因为 MutexGuard 实现了 Deref 和 Drop Trait    // 在离开这个作用域的时候会自动释放掉，就会自动解锁，所以不需要我们解锁&#125;println!(&quot;m=&#123;:?&#125;&quot;, m); // m=Mutex &#123; data: 6, poisoned: false, .. &#125;\n\n使用 Arc&lt;T&gt; 来进行原子引用记数\nArc&lt;T&gt; 和 Rc&lt;T&gt;类似，它可以用于并发情景\nA:atomic 原子的\n\n\n为什么所有的基础类型都不是原子的？为什么标准库类型不默认使用 Arc&lt;T&gt;？\n这是因为需要性能作为代价\n\n\nArc&lt;T&gt; 和 RC&lt;T&gt; 的 API 是相同的\n\n// let counter = Rc::new(Mutex::new(0));let counter = Arc::new(Mutex::new(0));let mut handles = vec![];for _ in 0..10 &#123;    // let counter = Rc::clone(&amp;counter);    // error: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely    // Rc 没有实现 Send Trait    // 所以在智能指针中，说 Rc 只能在单线程中使用    let counter = Arc::clone(&amp;counter);    let handle = thread::spawn(move || &#123;        let mut num = counter.lock().unwrap();        *num += 1;    &#125;);    handles.push(handle);&#125;for handle in handles &#123;    handle.join().unwrap();&#125;println!(&quot;Result: &#123;&#125;&quot;, *counter.lock().unwrap()); // error: borrow of moved value: `counter`\n\nRefCell&lt;T&gt;&#x2F;Rc&lt;T&gt; vs Mutex&lt;T&gt;&#x2F;Arc&lt;T&gt;\nMutex&lt;T&gt; 提供了内部可变性，和 Cell 家族一样\n我们使用 RefCell&lt;T&gt; 来改变 Rc&lt;T&gt; 里面的内容\n我们使用 Mutex&lt;T&gt; 来改变 Arc&lt;T&gt; 里面的内容\n注意：Mutex&lt;T&gt; 有死锁风险\n\nSend 和 Sync trait\nRust 语言的并发特性较少，目前讲的并发特性都来自标准库（而不是语言本身）\n无需局限于标准库的并发，可以自己实现并发\n在 Rust 语言中有两个并发概念：\nstd::marker::Sync 和 std::marker::Send 这两个 trait\n\n\n\nSend：允许线程间转移所有权\n实现 Send trait 的类型可在线程间转移所有权\nRust 中几乎所有的类型都实现了 Send\n但 Rc&lt;T&gt; 没有实现 Send，它只用于单线程情景\n\n\n任何完全由 Send 类型组成的类型也被标记为 Send\n除了原始指针之外，几乎所有的基础类型都是 Send\n\nSync：允许从多线程访问\n实现 Sync 的类型可以安全的被多个线程引用\n也就是说：如果 T 是 Sync，那么 &amp;T 就是 Send\n引用可以被安全的送往另一个线程\n\n\n基础类型都是 Sync\n完全由 Sync 类型组成的类型也是 Sync\n但 Rc&lt;T&gt; 不是 Sync 的\nRefCell&lt;T&gt; 和 Cell&lt;T&gt; 家族也不是 Sync 的\n而 Mutex&lt;T&gt; 是 Sync 的\n\n\n\n课后习题：实现一个多线程任务调度器\n任务描述\n你需要编写一个简单的多线程任务调度器，它能够接收多个任务，并将这些任务分发到多个工作线程中执行。调度器使用 Channel 进行任务的分发和结果的收集。你需要使用 Rust 的 Send 和 Sync 特性来确保任务调度器在多线程环境中的安全性。\n\n\n具体要求\n任务结构：\n定义一个 Task 结构体，表示需要执行的任务。任务包含一个唯一的 id 和一个用于执行的闭包。\n\n\n调度器结构：\n创建一个 Scheduler 结构体，包含一个任务队列和一个线程池。调度器应当使用 channel 来分发任务到不同的工作线程。\n\n\n功能实现：\n调度器应当具有以下功能：\n添加任务：向调度器添加一个任务。\n启动调度器：启动多个线程，开始从任务队列中获取任务并执行。\n获取结果：在所有任务完成后，收集并打印每个任务的执行结果。\n\n\n多线程安全：\n通过使用 Arc 和 Mutex 确保任务队列在多个线程之间的安全访问。\n确保任务的结果能够正确地在线程之间传递和收集。\n\n\n\n问题提示\n任务队列：\n使用 Mutex 来保护任务队列，确保多个线程不会同时修改队列中的数据。\n使用 Arc 来共享任务队列的所有权，使得多个线程能够访问同一个任务队列。\n\n\n任务分发：\n使用 channel 来将任务的完成状态发送回主线程，从而可以在主线程中收集和打印任务完成的结果。\n\n\n线程池：\n通过循环创建多个工作线程，每个线程从任务队列中取出任务并执行。线程池的大小可以通过 Scheduler 的构造函数来指定。\n\n\n任务执行：\n每个任务都应该是一个闭包，使用 Box&lt;dyn FnOnce()&gt; 将其存储在 Task 结构体中。\n\n\n\nuse std::collections::VecDeque;use std::sync::&#123;    Arc, Mutex,    mpsc::&#123;self, Receiver, Sender&#125;,&#125;;use std::thread;use std::time::Duration;/// 任务结构体struct Task &#123;    id: usize,    // 任务执行逻辑（装箱闭包）    // 1、基础闭包类型: FnOnce() -&gt; String    //   - FnOnce(): 可被调用一次的闭包    //   - -&gt; String: 返回字符串结果    // 2、+ Send: 添加线程安全约束，可在线程间安全传递    // 3、dyn: 允许包装多种不同类型的闭包实现    // 4、Box&lt;...&gt;: 堆内存分配，将动态大小的特征对象固定在堆内存    f: Box&lt;dyn FnOnce() -&gt; String + Send&gt;,&#125;impl Task &#123;    /// 创建新任务    // &#x27;static: 无外部引用依赖    fn new(id: usize, f: impl FnOnce() -&gt; String + Send + &#x27;static) -&gt; Self &#123;        Task &#123; id, f: Box::new(f) &#125;    &#125;    /// 执行任务    fn execute(self) -&gt; String &#123;        (self.f)()    &#125;&#125;/// 调度器结构体struct Scheduler &#123;    // 1、VecDeque：双端队列数据结构，方便先进先出、头部移除    // 2、​​Mutex（互斥锁）​：确保同时只有一个线程访问队列    // 3、​Arc(原子引用计数)​​：实现跨线程共享所有权，Arc::clone() 会增加引用计数    task_queue: Arc&lt;Mutex&lt;VecDeque&lt;Task&gt;&gt;&gt;, // 线程安全任务队列    result_sender: Sender&lt;(usize, String)&gt;, // 结果发送端    result_receiver: Option&lt;Receiver&lt;(usize, String)&gt;&gt;, // 结果接收端    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,   // 工作线程句柄&#125;impl Scheduler &#123;    /// 创建新的调度器    fn new(thread_count: usize) -&gt; Self &#123;        // 创建用于传递结果的通道        let (tx, rx) = mpsc::channel();        Scheduler &#123;            task_queue: Arc::new(Mutex::new(VecDeque::new())),            result_sender: tx,            result_receiver: Some(rx),            threads: Vec::with_capacity(thread_count), // 预分配线程存储空间        &#125;    &#125;    /// 添加任务到调度器    fn add_task(&amp;mut self, id: usize, task: impl FnOnce() -&gt; String + Send + &#x27;static) &#123;        let mut queue = self.task_queue.lock().unwrap(); // 获取队列锁        queue.push_back(Task::new(id, task)); // 添加新任务    &#125;    /// 启动调度器和工作线程    fn run(&amp;mut self) &#123;        let result_sender = self.result_sender.clone();        let task_queue = Arc::clone(&amp;self.task_queue);        let thread_count = self.threads.capacity();        // 创建工作线程池        for _ in 0..thread_count &#123;            let task_queue = Arc::clone(&amp;task_queue);            let result_sender = result_sender.clone();            // 创建并启动工作线程            let handle = thread::spawn(move || &#123;                loop &#123;                    // 从任务队列中获取任务                    let task = &#123;                        let mut queue = task_queue.lock().unwrap();                        queue.pop_front()                    &#125;;                    match task &#123;                        Some(task) =&gt; &#123;                            // 先获取任务ID再执行                            let id = task.id;                            let result = task.execute();                            // 发送结果到通道                            result_sender.send((id, result)).unwrap();                        &#125;                        None =&gt; &#123;                            // 队列为空，检查是否需要继续运行                            let queue = task_queue.lock().unwrap();                            if queue.is_empty() &#123;                                // 短暂睡眠后重试                                thread::sleep(Duration::from_millis(10));                            &#125;                        &#125;                    &#125;                &#125;            &#125;);            self.threads.push(handle);        &#125;    &#125;    /// 等待任务完成并收集结果    fn wait_completion(&amp;mut self) -&gt; Vec&lt;(usize, String)&gt; &#123;        // 首先收集所有任务ID        let task_count = &#123;            let queue = self.task_queue.lock().unwrap();            queue.len()        &#125;;        // 从通道接收结果        let receiver = self.result_receiver.take().unwrap();        let mut results = Vec::with_capacity(task_count);        // 等待并收集所有结果        for _ in 0..task_count &#123;            match receiver.recv() &#123;                Ok((id, result)) =&gt; &#123;                    // 修复处：先复制/借用再移动，避免所有权问题                    println!(&quot;任务 &#123;&#125; 完成: &#123;&#125;&quot;, id, &amp;result);                    results.push((id, result));                &#125;                Err(e) =&gt; &#123;                    println!(&quot;接收结果出错: &#123;&#125;&quot;, e);                    break;                &#125;            &#125;        &#125;        // 清除任务队列        let mut queue = self.task_queue.lock().unwrap();        queue.clear();        results    &#125;&#125;fn main() &#123;    // 1. 初始化调度器（4个工作线程）    let mut scheduler = Scheduler::new(4);    // 2. 添加任务（模拟10个耗时任务）    for i in 0..10 &#123;        scheduler.add_task(i, move || &#123;            // 计算任务耗时（动态变化），并转换为u64类型            let sleep_ms = 200 + (i * 50) % 300;            let sleep_duration = Duration::from_millis(sleep_ms as u64);            thread::sleep(sleep_duration);            // 返回格式化任务结果            format!(&quot;任务 &#123;&#125; 处理完成 (耗时 &#123;&#125;ms)&quot;, i, sleep_ms)        &#125;);    &#125;    // 3. 启动调度器（创建工作线程）    scheduler.run();    // 4. 等待任务完成并收集结果    let results = scheduler.wait_completion();    // 5. 输出最终汇总    println!(&quot;\\n所有任务完成结果:&quot;);    for (id, result) in results &#123;        println!(&quot;任务 &#123;&#125;: &#123;&#125;&quot;, id, result);    &#125;&#125;\n\n完善进阶\n任务优先级：扩展调度器，使其能够按照任务的优先级顺序执行。\n任务取消：实现任务的取消功能，当任务队列中存在未完成的任务时，支持中止这些任务的执行。\n结果收集：扩展调度器，使其能够返回每个任务的执行结果，而不仅仅是打印任务完成状态。\n\nuse std::cmp;use std::collections::BinaryHeap;use std::sync::&#123;    Arc,    Mutex,    atomic::&#123;AtomicBool, Ordering&#125;, // 明确从atomic模块导入Ordering    mpsc::&#123;self, Receiver, Sender&#125;,&#125;;use std::thread;use std::time::Duration; // 导入标准库的cmp模块/// 带优先级的任务结构体struct Task &#123;    id: usize,    priority: u32,                         // 任务优先级，数值越高优先级越高    cancelled: Arc&lt;AtomicBool&gt;,            // 任务取消标志    f: Box&lt;dyn FnOnce() -&gt; String + Send&gt;, // 移除了Debug trait要求&#125;impl Task &#123;    /// 创建新任务    fn new(        id: usize,        priority: u32,        cancelled: Arc&lt;AtomicBool&gt;,        f: impl FnOnce() -&gt; String + Send + &#x27;static,    ) -&gt; Self &#123;        Task &#123;            id,            priority,            cancelled,            f: Box::new(f),        &#125;    &#125;    /// 执行任务    fn execute(self) -&gt; Option&lt;String&gt; &#123;        // 检查任务是否被取消，使用正确的Ordering变体        if self.cancelled.load(Ordering::Relaxed) &#123;            return None;        &#125;        // 执行任务并返回结果        Some((self.f)())    &#125;&#125;/// 为任务实现排序特性，优先级高的任务排在前面impl PartialEq for Task &#123;    fn eq(&amp;self, other: &amp;Self) -&gt; bool &#123;        self.priority == other.priority    &#125;&#125;impl Eq for Task &#123;&#125;impl PartialOrd for Task &#123;    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;cmp::Ordering&gt; &#123;        // 使用正确的路径        Some(self.cmp(other))    &#125;&#125;impl Ord for Task &#123;    fn cmp(&amp;self, other: &amp;Self) -&gt; cmp::Ordering &#123;        // 使用正确的路径        // 注意：BinaryHeap是最大堆，所以优先级高的任务应该排在前面        // 因此返回other和self的比较结果        other.priority.cmp(&amp;self.priority)    &#125;&#125;/// 增强版调度器结构体struct Scheduler &#123;    task_queue: Arc&lt;Mutex&lt;BinaryHeap&lt;Task&gt;&gt;&gt;, // 使用最大堆实现优先级队列    result_sender: Sender&lt;(usize, Option&lt;String&gt;)&gt;, // 结果发送端（包含任务取消情况）    result_receiver: Option&lt;Receiver&lt;(usize, Option&lt;String&gt;)&gt;&gt;, // 结果接收端    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,     // 工作线程句柄    stop_flag: Arc&lt;AtomicBool&gt;,               // 停止所有线程的标志    cancellation_flags: Arc&lt;Mutex&lt;Vec&lt;Arc&lt;AtomicBool&gt;&gt;&gt;&gt;, // 所有任务的取消标志    thread_count: usize,                      // 存储线程数量&#125;impl Scheduler &#123;    /// 创建新的调度器    fn new(thread_count: usize) -&gt; Self &#123;        // 创建用于传递结果的通道        let (tx, rx) = mpsc::channel();        Scheduler &#123;            task_queue: Arc::new(Mutex::new(BinaryHeap::new())),            result_sender: tx,            result_receiver: Some(rx),            threads: Vec::with_capacity(thread_count),            stop_flag: Arc::new(AtomicBool::new(false)),            cancellation_flags: Arc::new(Mutex::new(Vec::new())),            thread_count, // 存储线程数量        &#125;    &#125;    /// 添加任务到调度器    fn add_task(        &amp;mut self,        id: usize,        priority: u32,        task: impl FnOnce() -&gt; String + Send + &#x27;static,    ) -&gt; Arc&lt;AtomicBool&gt; &#123;        // 创建任务取消标志        let cancelled = Arc::new(AtomicBool::new(false));        // 存储取消标志以便后续管理        let mut flags = self.cancellation_flags.lock().unwrap();        flags.push(Arc::clone(&amp;cancelled));        drop(flags);        let mut queue = self.task_queue.lock().unwrap();        queue.push(Task::new(id, priority, Arc::clone(&amp;cancelled), task));        // 返回取消标志，允许外部取消此任务        cancelled    &#125;    /// 启动调度器和工作线程    fn run(&amp;mut self) &#123;        let result_sender = self.result_sender.clone();        let task_queue = Arc::clone(&amp;self.task_queue);        let stop_flag = Arc::clone(&amp;self.stop_flag);        // 创建工作线程池        for _ in 0..self.thread_count &#123;            // 使用存储的线程数量            let task_queue = Arc::clone(&amp;task_queue);            let result_sender = result_sender.clone();            let stop_flag = Arc::clone(&amp;stop_flag);            // 创建并启动工作线程            let handle = thread::spawn(move || &#123;                while !stop_flag.load(Ordering::Relaxed) &#123;                    // 从任务队列中获取任务                    let task = &#123;                        let mut queue = task_queue.lock().unwrap();                        queue.pop()                    &#125;;                    match task &#123;                        Some(task) =&gt; &#123;                            // 先获取任务ID再执行                            let id = task.id;                            let result = task.execute();                            // 发送结果到通道，包含任务取消情况                            result_sender.send((id, result)).unwrap();                        &#125;                        None =&gt; &#123;                            // 短暂睡眠后重试，避免忙等待消耗CPU                            thread::sleep(Duration::from_millis(10));                        &#125;                    &#125;                &#125;            &#125;);            self.threads.push(handle);        &#125;    &#125;    /// 取消所有待处理任务    fn cancel_all(&amp;self) &#123;        // 设置全局取消标志        self.stop_flag.store(true, Ordering::Relaxed);        // 设置所有任务的取消标志        let flags = self.cancellation_flags.lock().unwrap();        for flag in flags.iter() &#123;            flag.store(true, Ordering::Relaxed);        &#125;    &#125;    /// 等待任务完成并收集结果    fn wait_completion(&amp;mut self) -&gt; Vec&lt;(usize, Option&lt;String&gt;)&gt; &#123;        // 获取任务总数        let task_count = &#123;            let queue = self.task_queue.lock().unwrap();            queue.len()        &#125;;        // 从通道接收结果        let receiver = self.result_receiver.take().unwrap();        let mut results = Vec::with_capacity(task_count);        // 等待并收集所有结果        for _ in 0..task_count &#123;            match receiver.recv() &#123;                Ok((id, result)) =&gt; &#123;                    if let Some(ref res) = result &#123;                        println!(&quot;任务 &#123;&#125; 完成: &#123;&#125;&quot;, id, res);                    &#125; else &#123;                        println!(&quot;任务 &#123;&#125; 已取消&quot;, id);                    &#125;                    results.push((id, result));                &#125;                Err(e) =&gt; &#123;                    println!(&quot;接收结果出错: &#123;&#125;&quot;, e);                    break;                &#125;            &#125;        &#125;        // 清除任务队列和取消标志        &#123;            let mut queue = self.task_queue.lock().unwrap();            queue.clear();            let mut flags = self.cancellation_flags.lock().unwrap();            flags.clear();        &#125;        results    &#125;    /// 优雅关闭调度器    fn shutdown(&amp;mut self) &#123;        // 取消所有任务        self.cancel_all();        // 等待所有线程结束        while let Some(handle) = self.threads.pop() &#123;            handle.join().unwrap_or_else(|_| println!(&quot;线程终止出错&quot;));        &#125;    &#125;&#125;fn main() &#123;    // 1. 初始化调度器（4个工作线程）    let mut scheduler = Scheduler::new(4);    // 2. 添加不同优先级的任务    let mut task_flags = Vec::new();    // 添加10个不同优先级的任务    for i in 0..10 &#123;        // 生成优先级，并将usize转换为u32        let priority = ((i % 3 + 1) * 10) as u32; // 确保结果为u32类型        // 获取取消标志并存储        let flag = scheduler.add_task(i, priority, move || &#123;            // 计算任务耗时（动态变化），并转换为u64类型            let sleep_ms = 200 + (i * 50) % 300;            let sleep_duration = Duration::from_millis(sleep_ms as u64);            thread::sleep(sleep_duration);            // 返回格式化任务结果            format!(&quot;任务 &#123;&#125; 处理完成 (耗时 &#123;&#125;ms)&quot;, i, sleep_ms)        &#125;);        task_flags.push((i, flag));    &#125;    // 3. 启动调度器（创建工作线程）    scheduler.run();    // 4. 模拟中途取消部分任务    thread::sleep(Duration::from_millis(200));    println!(&quot;\\n取消部分任务...&quot;);    for (id, flag) in &amp;task_flags &#123;        // 取消ID为奇数的任务        if id % 2 == 1 &#123;            flag.store(true, Ordering::Relaxed);            println!(&quot;已取消任务 &#123;&#125;&quot;, id);        &#125;    &#125;    // 5. 等待任务完成并收集结果    let results = scheduler.wait_completion();    // 6. 输出任务执行汇总    println!(&quot;\\n任务执行结果汇总:&quot;);    println!(        &quot;&#123;: &lt;6&#125; &#123;: &lt;8&#125; &#123;: &lt;8&#125; &#123;&#125;&quot;,        &quot;任务ID&quot;, &quot;优先级&quot;, &quot;状态&quot;, &quot;结果&quot;    );    println!(&quot;&#123;&#125;&quot;, &quot;-&quot;.repeat(50));    for (id, result) in results &#123;        // 查找任务的优先级        let priority = task_flags            .iter()            .find(|(task_id, _)| *task_id == id)            .and_then(|(_, flag)| &#123;                scheduler                    .cancellation_flags                    .lock()                    .unwrap()                    .iter()                    .find(|f| Arc::ptr_eq(f, flag))                    .and_then(|_| &#123;                        scheduler                            .task_queue                            .lock()                            .unwrap()                            .iter()                            .find(|t| t.id == id)                            .map(|t| t.priority)                    &#125;)            &#125;)            .unwrap_or(0);        let status = match &amp;result &#123;            Some(_) =&gt; &quot;完成&quot;,            None =&gt; &quot;取消&quot;,        &#125;;        let result_str = result.as_ref().map(String::as_str).unwrap_or(&quot;已取消&quot;);        println!(&quot;&#123;:&lt;8&#125; &#123;:&lt;10&#125; &#123;:&lt;10&#125; &#123;&#125;&quot;, id, priority, status, result_str);    &#125;    // 7. 优雅关闭调度器    scheduler.shutdown();&#125;\n","categories":["Rust - IB课程"],"tags":["Rust"]},{"title":"IB-Rust-并发1","url":"/2025/06/16/83-IB-Rust-%E5%B9%B6%E5%8F%911/","content":"Codes in lesson25\n并发与并行的区别\n并发（Concurrency）：多个任务在时间上交替执行\n并行（Parallelism）：多个任务同时执行\n\n进程与线程\n在大部分 OS 里，代码运行在进程（process）中，OS同时管理多个进程\n在程序里，各独立部分可以同时运行，运行这些独立部分的就是线程（thread）\n多线程运行 可以提升性能表现 和 增加复杂性，但无法保障各线程的执行顺序\n\n\n\n多线程导致的问题\n竞争状态，线程以不一致的顺序访问数据或资源\n死锁，两个线程彼此等待对方使用完所持有的资源，线程无法继续\n只在某些情况下发生的 Bug，很难可靠地复制现象和修复\n\n实现线程的方式\n通过调用 OS 的 API 来创建线程：1:1模型\n需要较小的运行时\n\n\n语言自己实现的线程（绿色线程）：M:N模型（Go语言）\n需要更大的运行时\n\n\nRust：需要权衡运行时的支持\nRust 标准库仅提供 1:1模型 的线程\n\nRust 如何创建线程通过 thread::spawn 函数可以创建新线程，其参数是一个闭包（在新线程里运行的代码）\nuse std::thread;use std::time::Duration;fn thread_study() &#123;    thread::spawm(|| &#123;        for i in 1..10 &#123;            println!(&quot;hi number &#123;&#125; from the spawned thread!&quot;, i);            thread::sleep(Duration::from_millis(1));        &#125;    &#125;);    for i in 1..5 &#123;        println!(&quot;hi number &#123;&#125; from the main thread!&quot;, i);        thread::sleep(Duration::from_millis(1));    &#125;&#125;\n\n通过 join Handle 来等待所有线程完成thread::spawn 函数的返回值类型是 JoinHandle\nJoinHandle 持有值的所有权，调用其 join 方法，会阻止当前运行线程的执行，直到 handle 所表示的线程终结\nlet handle = thread::spawn(|| &#123;    for i in 1..10 &#123;        println!(&quot;hi number &#123;&#125; from the spawned thread!&quot;, i);        thread::sleep(Duration::from_millis(1));    &#125;&#125;);for i in 1..5 &#123;    println!(&quot;hi number &#123;&#125; from the main thread!&quot;, i);    thread::sleep(Duration::from_millis(1));&#125;handle.join().unwrap();\n\n使用 move 闭包\nmove 闭包通常和 thread::spawn 函数一起使用，它允许使用用其它线程的数据\n创建线程时，把值的所有权从一个线程转移到另一个线程\n\nlet v = vec![1, 2, 3];// error: closure may outlive the current function, but it borrows `v`, which is owned by the current functionlet handle = thread::spawn(move || &#123;    println!(&quot;Here is a vector: &#123;:?&#125;&quot;, v);&#125;);// drop(v); // error: use of moved value: `v`handle.join().unwrap();\n\n多线程通信消息传递一种流行且能保证安全并发的技术是：消息传递，线程（或 Actor）通过彼此发送消息（数据）来进行通信\n\nGo 语言：不要用共享内存来通信，要用通信来共与享内存（与 Rust 相似）\nRust：Channel（标准库提供）\n\nChannel\nChannel 包含：发送端、接收端\n调用发送端的方法，发送数据\n接收端会检查和接收到达的数据\n如果发送端、接收端中任意一端被丢弃了，那么 Channel 就又“关闭”了\n\n创建 channel\n使用 mpsc::channel 函数来创建 Channel\nmpsc 表示multiple producer,single consumer（多个生产者、一个消者）\n返回一个 tuple（元组）：里面元素分别是发送端、接收端\n\n\n使用 mpsc::sync_channel 来创建带缓冲区的 channel\n入参为缓冲区大小，当缓冲区塞满时进行阻塞\n\n\n\nuse std::sync::mpsc;fn thread_study() &#123;    let (tx, rx) = mpsc::channel();    thread::spawn(move || &#123;        let vals = vec![            String::from(&quot;hi&quot;),            String::from(&quot;from&quot;),            String::from(&quot;the&quot;),            String::from(&quot;thread&quot;),        ];        for val in vals &#123;            tx.send(val).unwrap();            thread::sleep(Duration::from_millis(200));        &#125;    &#125;);    for received in rx &#123;        println!(&quot;Got: &#123;received&#125;&quot;);    &#125;&#125;\n\n总结\n发送端的 send 方法\n参数：想要发送的数据\n返回：Result&lt;T,E&gt;\n如果有问题(例如接收端已经被丢弃)，就返回一个错误语\n\n\n\n\n接收端的方法\nrecv 方法：阻止当前线程执行，直到 Channel 中有值被送来\n一旦有值收到，就返回 Result&lt;T,E&gt;\n当发送端关闭，就会收到一个错误\n\n\ntry_recv 方法：不会阻塞,\n立即返回 Result&lt;T,E&gt;:\n有数据达到：返回 Ok，里面包含着数据\n否则，返回错误\n\n\n通常会使用循环调用来检查 try_recv 的结果\n\n\n\n\n\n课后习题1：实现多线程文件处理器你需要编写一个多线程文件处理器，它从一个通道（channel）中接收文件路径，并在线程池中处理这些文件。文件处理的具体任务可以是读取文件内容并打印到控制台。你需要使用 Rust 的带缓冲区的 channel 来控制并发线程的数量，从而限制同时处理的文件数量。\n\n具体要求\n文件处理任务：\n定义一个函数 process_file，该函数接受一个文件路径，读取文件内容，并将内容打印到控制台。\n\n\n多线程控制：\n创建一个带缓冲区的 channel，用于在主线程和工作线程之间传递文件路径。\n使用多线程来实现文件处理的并发性，限制线程的并发数量（例如，最多同时处理 4 个文件）。\n\n\n主线程作为生产者：\n主线程负责向通道发送文件路径。假设我们有 10 个文件路径要处理。\n\n\n工作线程作为消费者：\n创建多个工作线程，每个线程从通道中接收文件路径，并调用 process_file 函数来处理文件。\n\n\n\nuse std::path::PathBuf;use std::sync::mpsc;use std::&#123;fs, thread&#125;;// 读取文件内容并打印fn process_file(path: PathBuf) &#123;    // PathBuf 类型，代表文件路径    match fs::read_to_string(&amp;path) &#123;        Ok(content) =&gt; println!(            &quot;文件：&#123;:?&#125;\\n内容：\\n&#123;&#125;\\n&#123;&#125;&quot;,            path,            content,            &quot;-&quot;.repeat(20) // 分割线        ),        Err(e) =&gt; eprintln!(&quot;无法读取文件 &#123;:?&#125;：&#123;&#125;&quot;, path, e),    &#125;&#125;/*    主线程 (生产者)        │        ▼    [主通道] (同步通道，缓冲区=4) → 控制最大待处理任务数        │        ▼    任务分发线程 (协调者)        │        ▼ (轮询分发)    [子通道1] → 工作线程1 (消费者)    [子通道2] → 工作线程2 (消费者)    [子通道3] → 工作线程3 (消费者)    [子通道4] → 工作线程4 (消费者)*/// 关闭顺序：// 1. 主线程完成发送 → drop(tx) → 主通道关闭// 2. 分发线程收完所有任务 → 循环结束 → 销毁所有 child_tx// 3. 每个工作线程的 child_rx 接收端关闭 → 退出循环// 4. 工作线程自然结束 → 分发线程 join → 主线程结束fn main() &#123;    // 模拟包含10个文件路径的向量（file1.txt 到 file10.txt）    let files = (1..=10)        .map(|i| PathBuf::from(format!(&quot;file&#123;&#125;.txt&quot;, i)))        .collect::&lt;Vec&lt;PathBuf&gt;&gt;();    // 创建带缓冲区的通道 - 缓冲区大小 = 最大并发数    // 当缓冲区满（4个任务等待）时，发送操作 (tx.send()) 会阻塞    // 只有当工作线程从接收端取走任务后，发送操作才能继续    // 实现任务的流量控制，防止生产者过快生产任务    let (tx, rx) = mpsc::sync_channel(4); // 缓冲区大小 = 最大并发数    // 创建工作线程池    let mut workers = vec![];    // 单个工作线程负责从通道接收任务    let worker = thread::spawn(&#123;        // 所有权转移，确保线程安全        move || &#123;            println!(&quot;任务分发线程已启动&quot;);            // 使用向量存储工作线程            let mut child_workers = vec![];            // 创建4个工作线程            for id in 0..4 &#123;                // mpsc::channel() 为每个工作线程创建独立的异步通道                // child_tx：任务分发线程使用的发送端                // child_rx：工作线程使用的接收端                let (child_tx, child_rx) = mpsc::channel();                let child_worker = thread::spawn(move || &#123;                    println!(&quot;工作线程 &#123;&#125; 已启动&quot;, id);                    // 迭代接收文件路径                    for path in child_rx.iter() &#123;                        println!(&quot;工作线程 &#123;&#125; 正在处理：&#123;:?&#125;&quot;, id, path);                        process_file(path);                    &#125;                    println!(&quot;工作线程 &#123;&#125; 已结束&quot;, id);                &#125;);                // 存储所有工作线程的发送端和句柄                child_workers.push((child_tx, child_worker));            &#125;            // 轮询方式分发任务            let mut index = 0;            for path in rx.iter() &#123;                // 选择下一个工作线程                let (child_tx, _) = &amp;child_workers[index];                // 发送任务到工作线程                child_tx.send(path).expect(&quot;向工作线程发送任务失败&quot;);                // 移动到下一个工作线程                index = (index + 1) % child_workers.len();            &#125;            // 关闭所有子通道            for (child_tx, _) in &amp;child_workers &#123;                drop(child_tx.clone());            &#125;            // 等待所有工作线程完成            for (_, child_worker) in child_workers &#123;                child_worker.join().expect(&quot;工作线程异常退出&quot;);            &#125;            println!(&quot;任务分发线程已结束&quot;);        &#125;    &#125;);    workers.push(worker);    // 主线程作为生产者发送文件路径    for file in files &#123;        println!(&quot;主线程发送: &#123;:?&#125;&quot;, file);        tx.send(file).expect(&quot;发送文件路径失败&quot;);    &#125;    // 关闭发送通道    drop(tx);    // 等待任务分发线程完成    for worker in workers &#123;        worker.join().expect(&quot;任务分发线程异常退出&quot;);    &#125;    println!(&quot;所有任务已完成&quot;);&#125;\n\n课后习题2：使用 Channel 实现程序的优雅停止在这道练习中，你需要编写一个多线程程序，该程序会创建多个工作线程，持续处理任务。在接收到停止信号时，所有工作线程应该优雅地停止工作，并确保所有未完成的任务都被处理完毕。\n\n具体要求\n你将使用 Rust 的 channel 来实现任务的调度和优雅停止机制。\n工作线程：\n创建一个工作线程池，工作线程从通道接收任务并处理。\n工作线程应能够响应停止信号，并在完成当前任务后优雅地退出。\n\n\n\n\n任务结构：\n任务可以是简单的打印操作，模拟一些耗时工作，例如打印任务 ID 并暂停一段时间。\n\n\n优雅停止：\n通过发送一个特殊的停止信号，通知所有工作线程停止接收新的任务，并在完成当前任务后退出。\n确保所有已接收的任务都被处理完毕。\n\n\n主线程控制：\n主线程应当能够发送任务，也能够在适当的时候发送停止信号，触发工作线程的优雅停止。\n\n\n\nuse std::fmt;use std::sync::mpsc::&#123;self, Receiver, Sender&#125;;use std::thread;use std::time::Duration;// 任务类型定义#[derive(Debug, Clone)]enum Task &#123;    // 常规任务，包含任务ID    Job(i32),    // 停止信号，要求所有工作线程优雅退出    Terminate,&#125;// 为 Task 实现自定义显示impl fmt::Display for Task &#123;    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result &#123;        match self &#123;            Task::Job(id) =&gt; write!(f, &quot;任务 #&#123;&#125;&quot;, id),            Task::Terminate =&gt; write!(f, &quot;停止信号&quot;),        &#125;    &#125;&#125;fn main() &#123;    // 创建4个工作线程及其通道    let mut worker_txs = Vec::new(); // 存储工作线程的发送端    let mut workers = Vec::new(); // 存储工作线程的句柄    // 创建停止通知通道    let (stop_tx, stop_rx) = mpsc::channel();    // 创建并启动4个工作线程    for id in 0..4 &#123;        // 为每个工作线程创建专用通道        let (worker_tx, worker_rx) = mpsc::channel();        // worker_tx 存储在 worker_txs 中，供主线程发送任务        worker_txs.push(worker_tx);        // 为每个工作线程创建专用的停止通知发送端        let thread_stop_tx = stop_tx.clone();        let worker = thread::spawn(move || &#123;            // worker_rx 传递给工作线程，用于接收任务            worker_thread(id, worker_rx, thread_stop_tx);        &#125;);        workers.push(worker);    &#125;    // 创建可变的任务分发函数（闭包）    let mut current_worker = 0;    let mut send_task = |task: Task| &#123;        // 添加 mut 关键字使闭包可变        worker_txs[current_worker].send(task).unwrap();        current_worker = (current_worker + 1) % worker_txs.len();    &#125;;    // 发送10个任务    for task_id in 1..=10 &#123;        let task = Task::Job(task_id);        println!(&quot;[主线程] 发送任务: &#123;&#125;&quot;, task);        send_task(task); // 调用可变闭包进行分发    &#125;    // 发送4个 Task::Terminate 停止信号    // 每个工作线程都会收到一个停止信号    println!(&quot;[主线程] 发送停止信号，等待工作线程完成当前任务...&quot;);    for _ in 0..4 &#123;        send_task(Task::Terminate); // 调用可变闭包    &#125;    // 等待工作线程发送停止确认    let mut stopped_workers = 0;    while stopped_workers &lt; 4 &#123;        // 主线程阻塞在 stop_rx.recv() 上        match stop_rx.recv() &#123;            Ok(worker_id) =&gt; &#123;                println!(&quot;[主线程] 收到工作线程&#123;&#125;的停止确认&quot;, worker_id);                stopped_workers += 1;            &#125;            Err(_) =&gt; &#123;                // 如果通道意外关闭，跳出循环                println!(&quot;[主线程] 停止通道已关闭&quot;);                break;            &#125;        &#125;    &#125;    // 关闭所有工作线程通道（通知工作线程退出）    for tx in worker_txs &#123;        drop(tx); // 显式关闭通道    &#125;    // 等待所有工作线程结束    for worker in workers &#123;        worker.join().unwrap();    &#125;    println!(&quot;[主线程] 所有工作线程已退出，程序结束&quot;);&#125;/// 工作线程函数fn worker_thread(    id: u8,    rx: Receiver&lt;Task&gt;,    stop_tx: Sender&lt;u8&gt;, // 用于通知主线程本线程已停止) &#123;    println!(&quot;[工作线程&#123;&#125;] 已启动&quot;, id);    // 处理任务的循环    // 给循环命名 task_loop    &#x27;task_loop: for task in rx.iter() &#123;        match task &#123;            Task::Job(task_id) =&gt; &#123;                println!(&quot;[工作线程&#123;&#125;] 开始处理: &#123;&#125;&quot;, id, Task::Job(task_id));                // 模拟任务处理                let duration = Duration::from_millis(200 + (task_id as u64 % 4) * 100);                thread::sleep(duration);                println!(&quot;[工作线程&#123;&#125;] 完成处理: &#123;&#125;&quot;, id, Task::Job(task_id));            &#125;            Task::Terminate =&gt; &#123;                println!(&quot;[工作线程&#123;&#125;] 接收到停止信号，准备退出&quot;, id);                // 通知主线程本线程已收到停止信号                stop_tx.send(id).unwrap();                break &#x27;task_loop;            &#125;        &#125;    &#125;    // 处理通道中剩余的任务（在停止信号之后发送的任务）    println!(&quot;[工作线程&#123;&#125;] 处理剩余任务...&quot;, id);    for task in rx.iter() &#123;        match task &#123;            Task::Job(task_id) =&gt; &#123;                println!(&quot;[工作线程&#123;&#125;] 处理剩余任务: #&#123;&#125;&quot;, id, task_id);                thread::sleep(Duration::from_millis(50)); // 快速处理, 使用较短的休眠时间 (50ms)            &#125;            Task::Terminate =&gt; &#123;                // 忽略额外的停止信号，避免重复处理停止信号            &#125;        &#125;    &#125;    println!(&quot;[工作线程&#123;&#125;] 已完成所有任务，退出&quot;, id);&#125;","categories":["Rust - IB课程"],"tags":["Rust"]},{"title":"IB-Solana-开发入门","url":"/2025/06/19/86-IB-Solana-%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/","content":"Codes in lesson2.1: startup_nativeCodes in lesson2.2: startup_anchorCodes in lesson2.3: startup_anchor_todo\nNative Rust 搭建cargo new --lib &lt;project_name&gt; # new projectcargo add solana-program # 添加依赖\n\n修改编译配置在 Cargo.toml 文件中增加动态链接库：\n[lib]crate-type = [&quot;cdylib&quot;, &quot;lib&quot;]\n\nBuild &amp; Deploysolana config getcargo build-sbf # 构建合约solana program deploy &lt;xxx.so&gt;solana program close &lt;program_id&gt;\n\nPlayground 搭建https://beta.solpg.io/\nAnchor 搭建anchor init &lt;project_name&gt;anchor testanchor deploy\n\nDeploy Failedsolana program show --bufferssolana program close --buffers\n\n课后作业通过 Anchor 框架实现⼀个 项⽬，部署到 devnet\n\n新建 todo\n查看 todo\n删除 todo item\n\n","categories":["Solana - IB课程"],"tags":["Solana"]},{"title":"IB-Solana-基础&环境搭建","url":"/2025/06/18/85-IB-Solana-%E5%9F%BA%E7%A1%80&%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","content":"Sol 源码概览 &amp; 区块链应用\nSolana 区块链的工作原理\n共识协议\n高性能架构\n高并发处理\n低延迟\n\n\nRuntime 模块\n管理账户状态\n智能合约执行\n\n\nPrograms 模块\nToken Program Stake Program\n\n\nRust 和 区块链\n\nSol 课程目标 &amp; 在区块链中的地位\n掌握 Sol 的基础\nSol 开发的 8 大核心概念\nSol 的原生开发、Anchor 框架\nSol 的优势\n开发者趋势\n\nSol 历史、未来、以及发展\n公链核心问题\n开发者\n用户\n资本\n\n\nSol 的叙事\nSol 的运转轨道：人的力量\nSBF\n开发者、黑客松\nmeme\n\n\n生态系统\nStar Atlas, Saber, Audius, gmt\njto, metaora, Kamino, orca, rad, mango, jup\nBONKbot, Drift, blink\n稳定币与商业合作\n涉及硬件 &#x3D;&gt; depin, AI\nsolfare &#x3D;&gt; gas mev\n\n\nSol 的价值是如何积累的\nSol 的牛、熊市案例\nSol 的未来\n\nSol 的架构和常见名词概念常见概念\naccounts\n合约、验证器（validator）\n区块浏览器\naddress\ntransfer\ndApp\ntoken（代币）\nfee\nblock（区块高度）\n租约（管理费）\n签名\n钱包\nphantom（幻影）\nsolflare（gas 优先）\nbackpack\n\n\n\n8 大核心技术\nPOH\nTower BFT\nSealevel\nCloudbreak\nGulf Stream\nTurbine\nPipelining\nArchivers\n\nPoH (Proof of History，历史证明)PoH 不是共识算法，而是一种 ​​加密时钟机制​​\n\n通过可验证延迟函数（VDF）生成不可篡改的时间序列。\n每个节点使用 SHA-256 哈希函数创建连续的哈希链：前一个哈希值作为下一个输入，形成有序的时间戳序列。\n\n​技术优势​​：\n\n​​时间同步去中心化​​：节点无需通信即可验证事件顺序，减少共识开销。 \n​并行交易处理基础​​：交易按 PoH 序列预排序，使后续并行执行成为可能。\n确认速度提升：交易顺序在共识前已确定，对比传统 PBFT（拜占庭容错），区块确认速度提升 ​​10 倍​​以上。\n\nTower BFT（塔式拜占庭容错）Tower BFT 是在 PoH 基础上优化的 BFT 共识算法，通过 ​​投票锁定机制​ ​实现快速终局性（Finality）：\n\n验证者投票支持区块，锁定时间呈指数增长（1 Slot → 2 Slots → 4 Slots）。\n当超过 ​​2&#x2F;3 验证者​​ 投票支持时，区块立即确认。​​技术优势：\n​降低通信复杂度​​：PoH 提供全局时钟，投票消息减少至常数级（传统 PBFT 需 O(N²) 通信）。\n​抗分叉能力​​：锁定机制强制节点对早期投票负责，减少恶意分叉风险。\n\nSealevel（并行智能合约引擎）Sealevel 是首个支持 ​​分片内并行执行 ​​的运行时环境，通过交易预声明状态依赖实现：\n\n交易需显式声明读写账户（如 Account A (读), B (写)）。\n无冲突交易分配至多线程并行执行；冲突交易按序处理。​​技术优势：​​​- ​GPU 多核利用率​​：支持数千个 GPU 核心同时处理交易，吞吐量提升百倍。​- ​动态资源调度​​：结合 Cloudbreak 数据库，实现状态访问的并发优化。\n\nCloudbreak（水平扩展状态数据库）Cloudbreak 是 SSD 优化的数据结构，支持 ​​32 线程并发读写​​\n\n账户数据分片存储于多个 SSD，通过内存映射文件（mmap）加速访问。\n顺序写入优化：采用追加写入（append-only）减少随机操作，提升 I&#x2F;O 效率。​\n\nGulf Stream（无内存池交易转发）Gulf Stream 通过预知领导者轮换顺序（PoS 机制），将交易 ​​直接推送给未来领导者​​：\n\n客户端交易引用最近确认的区块哈希，有效期约 24 秒。\n验证者提前执行交易，失败则丢弃，减轻内存压力。​​技术优势：​​​- ​零内存池阻塞​​：传统链（如以太坊）内存池常达 10 万笔，Solana 仅需处理几秒内的交易。​- ​领导者切换加速​​：新区块生产无需等待未确认交易，切换时间降至 800 毫秒。\n\nTurbine（区块传播协议）Turbine 是受 BitTorrent 启发的分片传输方案：\n\n将区块拆分为 ​​64 KB 数据包​​，附加 Reed-Solomon 纠删码（容错率 33%）。\n领导者按权益权重将数据包分发给顶级验证者，后者逐层广播至全网。​​技术优势​​：\n带宽效率提升​​：传播复杂度从 O(N) 降至 O(log N)，支持 4 万节点在 400 毫秒内同步。 \n​抗网络攻击​​：纠删码确保即使 1&#x2F;3 数据包丢失，区块仍可完整恢复。\n\nPipelining（流水线交易验证）Pipelining 借鉴 CPU 流水线设计，四阶段硬件并行处理：\n​1. ​数据获取​​（网卡） → 2. ​​签名验证​​（GPU） → 3. ​​银行处理​​（CPU） → 4. ​​写入账本​​（磁盘）\n​技术实现：\n\nGPU 并行验证数万签名，TPU（交易处理单元）单机处理 50,000 TPS。\n验证者同时运行 TPU（区块生产）和 TVU（区块验证）双流水线。\n\nArchivers（分布式账本存储）Archivers 将历史数据分片存储于轻量级节点（归档器）：\n\n验证者将账本拆分为碎片，通过纠删码分发至归档器网络。\n归档器硬件门槛低（普通硬盘即可），通过存储证明（PoRep）确保数据完整性。​​生态应用：​​\n与 Filecoin 合作（Old Faithful 计划），实现 PB 级历史数据去中心化存储。\n新节点同步速度提升 ​​10 倍​​，降低参与门槛。\n\n总结Solana 八大技术通过紧密协作解决区块链“不可能三角”：\n\n​​可扩展性​​：PoH + Sealevel + Turbine 实现 65,000 TPS。\n去中心化​​：Archivers 降低存储门槛，全球节点超 2,000 个。​​\n安全性​​：Tower BFT 确保 1–2 秒终局性，抗 33% 拜占庭节点。\n\nSol 三种类型账户\n数据账户存储数据\n系统拥有的账户\nPDA（程序派生地址）账户\n存储智能合约 &#x3D;&gt; 状态\n\n\n\n\n程序账户存储可执行程序\n原生账户\n\nSolana 技术基础区块链区块链是由⼀系列按时间顺序链接的区块组成的。每个区块包含三部分：\n\n区块头（Block Header）：\n前⼀个区块的哈希（Previous Block Hash）：链接到链上前⼀个区块的加密哈希值，确保数据不可篡改。\n时间戳（Timestamp）：记录创建区块的时间。\n默克尔根（Merkle Root）：所有交易数据的哈希值，确保数据完整性。\n\n\n区块体（Block Body）：\n交易列表（Transactions）：包含区块中所有的交易记录。\n\n\n区块哈希（Block Hash）：\n当前区块的哈希值：通过对区块头数据进⾏哈希计算⽣成，作为下⼀个区块的前⼀个区块哈希。\n\n\n\n交易流程区块链中的交易流程可以简化为以下⼏个步骤：\n\n交易创建：⽤户 创建⼀笔交易，将资⾦或数据发送给⽤户 。\n交易⼴播：该交易被⼴播到区块链⽹络中，所有节点接收到交易信息。\n交易验证：⽹络中的矿⼯或验证节点对交易进⾏验证，确保交易的合法性。\n交易打包：验证通过的交易被打包进区块中，并由矿⼯竞争挖矿（在 PoW 的情况下）。\n交易确认：新创建的区块被添加到区块链上，交易得到确认。\n\n共识机制共识机制是区块链⽹络中所有节点就数据达成⼀致的⽅式。以常⻅的⼯作量证明（Proof of Work, PoW）为例：\n\n⼯作量证明（Pow）：矿⼯通过计算⼯作量来解决⼀个复杂的数学问题，第⼀个解出问题的矿⼯可以将其区块添加到区块链中。\n\n智能合约智能合约是部署在区块链上的⾃执⾏代码，能根据预定条件⾃动执⾏交易\n去中⼼化⽹络（P2P）区块链是由分布在全球的节点组成的去中⼼化⽹络，这些节点共同维护和更新区块链的状态。每个节点都有⼀份完整的区块链副本。\n环境搭建xcodexcode-select -p # check if installedxcode-select --install # install\n\nSolana-cli安装：\nsh -c &quot;$(curl -sSfL https://release.anza.xyz/stable/install)&quot; # new version (recommend)sh -c &quot;$(curl -sSfL https://release.solana.com/stable/install)&quot; # old version\n\n升级：\nagave-install update # new versionsolana-install update # old version\n\n检查：\nsolana -V\n\nAnchor安装：\ncargo install --git https://github.com/coral-xyz/anchor avm --locked --force\n\n如碰到失败（版本不兼容）可尝试如下⽅案：\ncargo install --git https://github.com/coral-xyz/anchor --tag v0.30.1anchor-cli --force\navm install latestavm use latest\n\n验证：\nanchor -V\n\n创建钱包命令行\n默认钱包地址为 ~/.config/solana/id.json\n\nsolana-keygen new # --force overwritesolana-keygen new -o ~/.config/solana/id2.json # 创建多个钱包solana config set -k ~/.config/solana/id.json # 设置为默认钱包\n\nPlayground通过 Playground 创建：https://beta.solpg.io/\n\n右上角 -&gt; wallet -&gt; Add\n创建后会自动 airdrop 5 SOL\n\n\n\n空投代币solana airdrop 5\nor 通过 faucet 领取 https://faucet.solana.com/\n查看账户交易通过区块浏览器查看账户交易：https://explorer.solana.com/address/[钱包地址]?cluster=devnet\n例如：https://explorer.solana.com/address/9XCHWjLS6vhQXubtRCP8cfZKG7JT44HSbJuuW6cLwWVp\n本地部署验证节点solana-test-validator\nsolana config get # get configsolana config set --url localhost # 配置 本地主机验证器solana config set --url testnet # 配置 test net\n\nsolana-cli 常见用法# 获取当前环境solana config get# 配置环境solana config set --url &lt;net&gt;# 创建钱包solana-keygen new# 获取当前账户地址solana address# 获取账户余额solana balance &lt;pub_key&gt;# 转账solana transfer &lt;recipient_public_key&gt; &lt;amount&gt; --from &lt;sender_keypair_path&gt;# 举例solana transfer 9k3V7trvz5sT2o4wat2JhpiURujfLV9JcB4268XGp3W8 0.1 --from ~/.config/solana/id1.json\n\n课后练习练习 solana-cli 的常⻅⽤法：\n\n切换到 devnet\n创建多个钱包\n领取空投\n通过 cli 实现各个钱包之间转账交易\n查看账户余额\n通过区块浏览器查看交易记录\n\n","categories":["Solana - IB课程"],"tags":["Solana"]},{"title":"IB-Solana-账户&简单交互","url":"/2025/06/21/87-IB-Solana-%E8%B4%A6%E6%88%B7&%E7%AE%80%E5%8D%95%E4%BA%A4%E4%BA%92/","content":"Codes in lesson3\n账户\n数据账户，用来存储数据\n系统所有账户\n程序派生账户（PDA）\n\n\n程序账户，用来存储可执行程序\n原生账户，指 Solana 上的原生程序，例如：System，Stake，以及 Vote\n\n账户结构体\nAccount\nAccountInfo\n\nAccount#[derive(Deserialize, PartialEq, Eq, Clone, Default)]#[serde(rename_all = &quot;camelCase&quot;)]pub struct Account &#123;    /// lamports in the account -- Sol 余额，lamports 是最小单位    pub lamports: u64,    /// data held in this account -- 存储数据，和合约或用户相关    #[serde(with = &quot;serde_bytes&quot;)]    pub data: Vec&lt;u8&gt;,    /// the program that owns this account. If executable, the program that loads this account.  -- 所有者的数据和权限    pub owner: Pubkey,    /// this account&#x27;s data contains a loaded program (and is now read-only)  -- data 中存放的是否为可执行代码    pub executable: bool,    /// the epoch at which this account will next owe rent -- 租金，存储程序在 Sol 上需要收费    pub rent_epoch: Epoch,&#125;\n\nAccountInfo/// Account information#[derive(Clone)]#[repr(C)]pub struct AccountInfo&lt;&#x27;a&gt; &#123;    /// Public key of the account -- 公钥，账户唯一标识    pub key: &amp;&#x27;a Pubkey,    /// The lamports in the account.  Modifiable by programs. -- Sol 余额    pub lamports: Rc&lt;RefCell&lt;&amp;&#x27;a mut u64&gt;&gt;,    /// The data held in this account.  Modifiable by programs. -- 同 Account    pub data: Rc&lt;RefCell&lt;&amp;&#x27;a mut [u8]&gt;&gt;,    /// Program that owns this account -- 同 Account    pub owner: &amp;&#x27;a Pubkey,    /// The epoch at which this account will next owe rent -- 同 Account    pub rent_epoch: Epoch,    /// Was the transaction signed by this account&#x27;s public key? -- 当前交易是否被该账户的公钥签名了    pub is_signer: bool,    /// Is the account writable? -- 是否能被修改    pub is_writable: bool,    /// This account&#x27;s data contains a loaded program (and is now  read-only) -- 同 Account    pub executable: bool,&#125;\n\nAccount &amp; AccountInfo 对比\nAccountInfo：\n更轻量级，包含对区块链上现有账户数据的引用。\n用于在 Solana 程序（智能合约）内部处理账户。\n适合在链上处理和操作账户数据。\n\n\nAccount：\n更完整的账户表示，包含账户的所有数据副本。\n常用于客户端或测试环境中，用于模拟或获取完整的账户状态。\n适合离线处理或全局管理账户数据。\n\n\n\n要点\n账户是用来存放数据的\n每个账户都有一个独一无二的地址\n每个账户大小不能超过 10MB\n账户大小是静态的\n账户数据存储需要付租金\n默认的账户所有者是“系统程序”\n\n程序派生账户（PDA）相关概念：https://solana.com/zh/docs/core/pda\nPDA 注意事项\n不能直接签名交易\n限制: PDA 账户没有私钥，因此无法像普通账户那样签名交易。\n影响: 这意味着 PDA 无法自主发起交易，它只能被相关的 智能合约程序 用作 数据存储或执行 操作。这确保了 PDA 只能在程序的控制下使用。\n\n\n地址碰撞的可能性\n限制: 在理论上，虽然非常罕见，使用相同的程序 ID 和相同的种子值可以生成相同的 PDA 地址。\n影响: 这意味着在设计智能合约时，开发者必须谨慎选择种子值，以确保不会产生地址碰撞。一般来说，通过使用唯一的种子（比如用户的公钥和其他独特的数据），可以避免这种问题。\n\n\nPDA 地址的最大长度\n限制: PDA 的种子值组合在一起不能超过 32 字节（bytes）。\n影响: 如果数据太大，可能无法直接作为种子使用，可能需要对数据进行哈希处理或其他方式来适应这个限制。\n\n\n生成 PDA 的计算成本\n限制: PDA 是通过哈希函数计算生成的，这个过程消耗计算资源。\n影响: 在性能敏感的应用中，频繁生成 PDA 可能增加链上计算的成本，影响程序的执行效率。因此，在设计程序时需要平衡性能和安全性。\n\n\n单一程序的访问\n限制: PDA 账户是由一个特定的程序生成和控制的，只有这个程序可以操作该 PDA 账户。\n影响: 虽然这提供了很强的安全性，但也意味着不能轻易地跨程序共享 PDA 账户。如果多个程序需要访问相同的数据，可能需要复杂的设计或数据复制。\n\n\n内存账户的使用\n限制: 如果 PDA 被用作 Solana 上的内存账户（即需要存储较多的数据），这些账户的大小是有限制的，超过一定大小需要支付更高的费用来增加内存租金。\n影响: 需要考虑 PDA 账户的数据量，避免不必要的存储开销，或者拆分数据存储到多个 PDA 账户中。\n\n\n\nPDA 应用场景\n用户状态管理：只有智能合约可以访问，保障用户状态数据隐私性\n去中心化金融（DeFi）协议\nNFT 元数据存储\nDAO（去中心化自治组织）投票系统\n时间锁合约\n多签（Multisig）钱包\n去中心化身份验证\n\n开发使用的 Rust 库\nsolana_client（客户端）\nsolana_sdk（操作 Sol）\nsolana_program（合约）\n\n实战\n启动本地环境：solana-test-validator\n更改 solana 配置，链接到本地开发环境\n创建本地账户\n给新建账户空投 sol\n使用 SDK\n空投 sol\n获取账号信息\n转移 sol\n\n\n通过 JsonRpc 获取账户信息\n\ncurl http://127.0.0.1:8899 -s -X \\  POST -H &quot;Content-Type: application/json&quot; -d &#x27;  &#123;    &quot;jsonrpc&quot;: &quot;2.0&quot;,    &quot;id&quot;: 1,    &quot;method&quot;: &quot;getAccountInfo&quot;,    &quot;params&quot;: [      &quot;mjvFkAaysJHDbEAvcJVd6Q2ZKb9kTeGPx6rAqVVQcUR&quot;,      &#123;        &quot;encoding&quot;: &quot;base58&quot;      &#125;    ]  &#125;&#x27;\n&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:&#123;&quot;context&quot;:&#123;&quot;apiVersion&quot;:&quot;2.2.17&quot;,&quot;slot&quot;:100523&#125;,&quot;value&quot;:&#123;&quot;data&quot;:[&quot;&quot;,&quot;base58&quot;],&quot;executable&quot;:false,&quot;lamports&quot;:9999995000,&quot;owner&quot;:&quot;11111111111111111111111111111111&quot;,&quot;rentEpoch&quot;:18446744073709551615,&quot;space&quot;:0&#125;&#125;,&quot;id&quot;:1&#125;\n","categories":["Solana - IB课程"],"tags":["Solana"]},{"title":"IB-Solana-SPLToken合约创建","url":"/2025/06/26/89-IB-Solana-SPLToken%E5%90%88%E7%BA%A6%E5%88%9B%E5%BB%BA/","content":"Codes in lesson5.1Codes in lesson5.2\n代币创建（Create Token） 与 铸造（Mint）核心概念账户模型基础\n数据账户\n原生账户、代币账户、状态账户\n铸币账户\n\n\n程序账户\n\n如何判断一个账户的类型？​​\n​步骤 1​​：检查 executable（判断是程序账户 or 数据账户）如果为 true -&gt; ​​程序账户​​如果为 false -&gt; 数据账户​步骤 2​​：检查 owner（判断是哪一种 数据账户）11111111... -&gt; ​​原生账户​​（系统程序拥有的数据账户）Tokenkeg... -&gt; ​​代币账户​​（SPL 程序拥有的数据账户）其他程序 ID -&gt; ​​状态账户​​（其他程序拥有的数据账户）步骤 3：检查数据内容（判断是哪种代币账户）Mint 结构体 -&gt; 铸币账户Account 结构体 -&gt; 代币持有账户（即狭义上的代币账户）\n\n1、数据账户（Data Account）\n数据账户（Data account）是存储状态的“容器”，是 Solana 区块链上的​​基础存储单元\n每个账户需要支付​​租金​​以维持数据存储，余额低于阈值可能导致账户被​​回收清除​\n只有​​所有者程序​​可以修改账户数据，其他程序只能读取（除非特别授权）\n2、程序账户（Program Account）\n程序账户（Program account）存储可执行代码的“智能合约”，是 Solana 上的“智能合约容器”\n程序账户是特殊类型的数据账户（executable&#x3D;true），基于 ​​Berkeley Packet Filter（BPF）​​虚拟机\n部署流程：\n1. 创建普通账户（executable=false）2. 向账户写入已编译的 BPF 字节码3. 设置 executable=true 并更改所有者\n\n3、原生账户（Native Account）\n\n原生账户（Native account）是存储和管理 SOL，由系统程序（1111111…）拥有\n每个公钥自动拥有一个原生账户：当用户生成密钥对时，账户即存在（余额为 0）\n简单操作：\nSOL 转账\n支付交易费用\n质押参与网络共识\n\n\n\n4、代币账户\n\n广义上（代币账户体系）\n\n代币账户分为：铸币账户 和 代币持有账户\n由 SPL Token 程序（Tokenkeg…）拥有\n\n\n狭义上（代币持有账户，Token Account）\n\n代币持有账户 存储和管理 特定用户对某种 SPL 代币（如 USDC 这类自定义代币）的余额\n代币持有账户 必须关联一个 铸币账户（多对一）\n关联代币账户（ATA）是特殊的 Token Account\n\n\n\n5、关联代币账户（Associated Token Account）\n\n关联代币账户（ATA）是 Token Account 的一种特殊类型，简化了 SPL Token 的账户管理\nATA 会自动与一个钱包地址绑定，每个代币账户（Token Account）和每个铸币账户（Mint Account）对应一个唯一的 ATA\n​​首次接收代币时，系统会自动生成 ATA 并支付租金（存储费用）\n​钱包&#x2F;交易所可通过算法推导用户的所有 ATA 地址，统一管理资产\n\n5、铸币账户（Mint Account）\n\n铸币账户定义一种特定 SPL 代币的基本属性和全局信息\n一个铸币账户可以关联多个代币账户（代币持有账户）\n\n数据结构：\npub struct Mint &#123;    pub mint_authority: Option&lt;Pubkey&gt;, // 铸币权限（谁能创建新代币）    pub supply: u64,                   // 代币总供应量    pub decimals: u8,                  // 小数位数（决定代币最小单位）    pub is_initialized: bool,          // 是否已初始化    pub freeze_authority: Option&lt;Pubkey&gt; // 冻结权限（谁能冻结账户）&#125;\n\n6、状态账户（State Account）\n\n状态账户存储​​应用程序特定的状态数据\n​​​由​​自定义程序拥有（既不是系统程序，也不是 SPL Token 程序）\n是 Solana 账户系统中最灵活的数据存储形式\n\n常见 owner：\n\n自定义程序（最常见）\n​由​开发者部署的智能合约​​\n比如：投票程序、游戏程序、DeFi 协议\n\n\n中间件程序\nDAO 治理程序\n\n核心组件\n铸币账户 (Mint Account)\n​​代币账户 (Token Account)​​\n关联令牌账户 (Associated Token Account, ATA)\n\n创建代币（Create Token &#x2F; Create Mint Account）的流程底层流程\n创建账户容器：在区块链上分配空间\n设置所有权：将新账户的所有权赋予 SPL Token 程序\n初始化代币参数：写入代币的元数据\n\n完整代码use solana_client::nonblocking::rpc_client::RpcClient;use solana_sdk::&#123;    commitment_config::CommitmentConfig, native_token::LAMPORTS_PER_SOL, program_pack::Pack,    signature::Keypair, signer::Signer, system_instruction::create_account,    transaction::Transaction,&#125;;use spl_token::&#123;instruction::initialize_mint2, state::Mint, ID as TOKEN_PROGRAM_ID&#125;;#[tokio::main]async fn main() -&gt; anyhow::Result&lt;()&gt; &#123;    // 1.1 建立 RPC 客户端连接    let client = RpcClient::new_with_commitment(        String::from(&quot;http://127.0.0.1:8899&quot;), // 本地 Solana 节点        CommitmentConfig::confirmed(),          // 确认级别    );    // 1.2 创建必要的密钥对    let authority_keypair = Keypair::new(); // 既是 支付账户，也是 权限账户    let mint_account = Keypair::new();     // 新代币的铸币账户    // 2.1 确定铸币账户大小    let mint_account_len = Mint::LEN; // 固定 82 字节    // 2.2 计算最小租金    // 当前约为 0.002 SOL（租全年的费用）    let mint_account_rent = client        .get_minimum_balance_for_rent_exemption(mint_account_len)        .await?;   // 3.1 创建系统指令   let create_mint_account_ix = create_account(       &amp;authority_keypair.pubkey(),    // 支付账户：从该账户扣除租金和交易费       &amp;mint_account.pubkey(),        // 新账户地址：新创建的铸币账户地址       mint_account_rent,            // 租金金额：代币账户存储所需租金       mint_account_len as u64,       // 账户数据空间大小（82字节）       &amp;TOKEN_PROGRAM_ID,             // 账户所有者（SPL Token 程序，是一个固定值！）   );   // 4.1 创建初始化指令   let initialize_mint_ix = initialize_mint2(       &amp;TOKEN_PROGRAM_ID,               // SPL Token 程序 ID       &amp;mint_account.pubkey(),         // 要初始化的铸币账户       &amp;authority_keypair.pubkey(),    // 铸币权限账户（可创建新代币）       Some(&amp;authority_keypair.pubkey()),// 冻结权限账户（可选，设为 None 表示无冻结权限）       9,                              // 精度（9位小数）   )?;   // 5.1 请求空投   // 为支付账户添加 5 SOL（测试网/开发网专有）   let transaction_signature = client       .request_airdrop(&amp;authority_keypair.pubkey(), 5 * LAMPORTS_PER_SOL)       .await?;   // 5.2 等待空投确认   loop &#123;    // 确保资金到位后才进行下一步       if client.confirm_transaction(&amp;transaction_signature).await? &#123;           break;       &#125;   &#125;    // 6.1 创建交易   let mut transaction = Transaction::new_with_payer(       // 两个指令打包到同一交易：创建空账户容器 + 初始化代币参数       &amp;[create_mint_account_ix, initialize_mint_ix],       // 支付账户       Some(&amp;authority_keypair.pubkey()),   );   // 6.2 交易签名   transaction.sign(       // 签名者：支付账户（支付租金和交易费）+ 铸币账户（证明对新账户的控制权）       &amp;[&amp;authority_keypair, &amp;mint_account],       // 最新区块哈希（防止重放攻击的交易唯一标识）                client.get_latest_blockhash().await?,   );   // 6.3 发送并确认交易   match client.send_and_confirm_transaction(&amp;transaction).await &#123;       Ok(signature) =&gt; println!(&quot;Transaction Signature: &#123;&#125;&quot;, signature),       Err(err) =&gt; eprintln!(&quot;Error sending transaction: &#123;&#125;&quot;, err),   &#125;    Ok(())&#125;\n\n铸造代币（Mint）到 关联令牌账户（ATA）的流程核心概念\n铸造（Mint）：创建新的代币单位并添加到流通中\n代币分配：将新创建的代币分配给特定用户\n\n完整代码use solana_client::nonblocking::rpc_client::RpcClient;use solana_sdk::&#123;    commitment_config::CommitmentConfig, native_token::LAMPORTS_PER_SOL, program_pack::Pack,    signature::Keypair, signer::Signer, system_instruction::create_account,    transaction::Transaction,&#125;;use spl_associated_token_account::&#123;    get_associated_token_address, instruction::create_associated_token_account_idempotent,&#125;;use spl_token::&#123;    instruction::&#123;initialize_mint2, mint_to_checked&#125;,    state::Mint,    ID as TOKEN_PROGRAM_ID,&#125;;#[tokio::main]async fn main() -&gt; anyhow::Result&lt;()&gt; &#123;    // =====================================================================    // 1.0 初始化环境    // =====================================================================    // 1.1 建立 RPC 客户端连接    let client = RpcClient::new_with_commitment(        String::from(&quot;http://127.0.0.1:8899&quot;), // 本地 Solana 节点        CommitmentConfig::confirmed(),          // 确认级别    );    // 1.2 创建必要的密钥对    let authority_keypair = Keypair::new(); // 既是 支付账户，也是 权限账户    let mint_account = Keypair::new();     // 新代币的铸币账户    // 1.3 计算关联令牌账户（ATA）地址    // 使用确定性算法计算用户对该代币的专属地址    let associated_token_account =        get_associated_token_address(&amp;authority_keypair.pubkey(), &amp;mint_account.pubkey());    // =====================================================================    // 2.0 准备阶段    // =====================================================================        // 调用 setup 函数 创建代币（Create Token / Create Mint Account）和 ATA    setup(&amp;client, &amp;authority_keypair, &amp;mint_account).await?;    // =====================================================================    // 3.0 铸造阶段 - 铸造代币到ATA（核心流程）    // =====================================================================    // 3.1 获取代币精度（小数位数）    let mint_decimals = client        .get_token_account_balance(&amp;associated_token_account)        .await?        .decimals;    // 3.2 计算铸造数量    // 1个完整代币    // 公式: 数量 = 完整代币数量 × 10^小数位数    let amount_to_mint = 1 * 10_u64.pow(mint_decimals as u32);    // 3.3 构建铸造指令    let mint_to_ix = mint_to_checked(        &amp;TOKEN_PROGRAM_ID,              // SPL 代币程序地址        &amp;mint_account.pubkey(),         // 铸币账户地址        &amp;associated_token_account,      // 目标 ATA 地址        &amp;authority_keypair.pubkey(),    // 铸币权限账户        // 签名者列表，提供多签支持（这里只有铸币权限账户）        &amp;[&amp;authority_keypair.pubkey()],        amount_to_mint,                 // 铸造数量        mint_decimals,                  // 代币精度（用于验证数量有效性）    )?;    // 3.4 创建交易    let mut transaction = Transaction::new_with_payer(        // 仅包含铸造指令        &amp;[mint_to_ix],        // 支付账户        Some(&amp;authority_keypair.pubkey()),    );    // 3.5 获取最新区块哈希（防止重放攻击的交易唯一标识）       let latest_blockhash = client.get_latest_blockhash().await?;    // 3.6 交易签名    // 铸币权限账户（authority_keypair）授权操作    transaction.sign(&amp;[&amp;authority_keypair], latest_blockhash);    // 3.7 发送并确认交易    match client.send_and_confirm_transaction(&amp;transaction).await &#123;        Ok(signature) =&gt; println!(&quot;铸造成功! 交易签名: &#123;&#125;&quot;, signature),        Err(err) =&gt; eprintln!(&quot;铸造失败: &#123;&#125;&quot;, err),    &#125;    Ok(())&#125;// =====================================================================// 2.0 准备阶段// - 创建代币（Create Token / Create Mint Account），同上// - 创建关联令牌账户（ATA）// =====================================================================async fn setup(...) -&gt; anyhow::Result&lt;()&gt; &#123;    // 2.1 空投 SOL 作为初始资金    let transaction_signature = client        .request_airdrop(&amp;authority_keypair.pubkey(), 5 * LAMPORTS_PER_SOL)        .await?;        // 2.2 等待空投确认    loop &#123;        if client.confirm_transaction(&amp;transaction_signature).await? &#123;            break;        &#125;    &#125;        // 2.3 设置代币参数    let decimals = 9; // 代币小数位数        // 2.4 计算铸币账户所需租金    let mint_account_len = Mint::LEN; // 铸币账户固定大小（82字节）    let mint_account_rent = client        .get_minimum_balance_for_rent_exemption(mint_account_len)        .await?;        // 2.5 创建铸币账户容器    let create_mint_account_ix = create_account(        &amp;authority_keypair.pubkey(), // 支付账户        &amp;mint_account.pubkey(),     // 新账户地址        mint_account_rent,          // 租金金额        mint_account_len as u64,    // 账户大小        &amp;TOKEN_PROGRAM_ID,          // 所有者：SPL代币程序    );        // 2.6 初始化铸币账户    let initialize_mint_ix = initialize_mint2(        &amp;TOKEN_PROGRAM_ID,              // SPL 代币程序        &amp;mint_account.pubkey(),         // 目标铸币账户        &amp;authority_keypair.pubkey(),    // 铸币权限账户        Some(&amp;authority_keypair.pubkey()), // 冻结权限账户（可选）        decimals,                       // 小数位数    )?;        // 2.7 创建关联令牌账户（ATA）    let create_ata_ix = create_associated_token_account_idempotent(        &amp;authority_keypair.pubkey(), // 支付账户：从该账户扣除租金和交易费        &amp;authority_keypair.pubkey(), // 钱包地址（代币所有者）        &amp;mint_account.pubkey(),      // 铸币账户地址        &amp;TOKEN_PROGRAM_ID,           // 账户所有者（SPL Token 程序，是一个固定值！）    );        // 2.8 打包并发送准备交易    let mut transaction = Transaction::new_with_payer(        // 三个指令打包到同一交易：创建空账户容器 + 初始化代币参数 + 创建ATA账户        &amp;[create_mint_account_ix, initialize_mint_ix, create_ata_ix],        // 支付账户        Some(&amp;authority_keypair.pubkey()),    );        // 2.9 交易签名    transaction.sign(        // 签名者：支付账户（支付租金和交易费）+ 铸币账户（证明对新账户的控制权）        &amp;[authority_keypair, mint_account],        // 最新区块哈希（防止重放攻击的交易唯一标识）           client.get_latest_blockhash().await?,    );        // 2.10 发送并确认交易    client.send_and_confirm_transaction(&amp;transaction).await?;        Ok(())&#125;\n\nSolana 项目结构核心文件：\n\nprocessor.rs：核心业务逻辑，处理指令\nstate.rs：定义账户的状态和扩展字段\ninstruction.rs：定义各种代币操作的指令\nerror.rs：定义了程序可能抛出的错误\nlib.rs：程序入口点，汇总各个模块\n\n实现 Token 交互合约项目初始化新建项目新建合约项目 contract 和 调用合约的项目 cli\n项目配置contract 依赖添加：\ncargo add solana-programcargo add borsh spl-token spl-associated-token-account\n\ncontract Cargo.toml 文件：\n[package]name = &quot;token&quot;version = &quot;0.1.0&quot;edition = &quot;2024&quot;[dependencies]borsh = &quot;1.5.7&quot;solana-program = &quot;2.3.0&quot;# 忽略入口文件spl-associated-token-account = &#123; version = &quot;7.0.0&quot;, features = [    &quot;no-entrypoint&quot;,] &#125;# 忽略入口文件spl-token = &#123; version = &quot;8.0.0&quot;, features = [&quot;no-entrypoint&quot;] &#125;[lib]crate-type = [&quot;cdylib&quot;, &quot;lib&quot;][features]no-entrypoint = []\n\ncli 依赖添加：\ncargo add spl-token borsh spl-associated-token-account solana-program solana-sdk solana-client\n\n编译部署编译：\ncargo build-sbf\n\n部署：\nsolana program deploy ./target/sbpf-solana-solana/release/token.so\n"},{"title":"IB-Solana-token解析","url":"/2025/06/23/88-IB-Solana-token%E8%A7%A3%E6%9E%90/","content":"solana 上的代币代币是代表对各种资产所有权的数字资产。代币化使得财产权的数字化成为可能，是管理 可替代和不可替代资产 的基本组成部分\n\n可替代代币 代表同类型和同价值的可互换和可分割资产（例如 USDC）\n不可替代代币（NFT） 代表不可分割资产的所有权（例如艺术品）\n半可替代代币（如股权代币）\n\nSPL（Solana Program Library）SPL Token 是 Solana 上的一套智能合约标准，类似于以太坊的 ERC-20 和 ERC-721 标准，但针对 Solana 的高性能架构进行了优化\nSPL Token 它定义了在 Solana 上创建、管理和交易代币的规则和接口，包含：\n\n​​代币程序​​：核心逻辑合约\n​​账户标准​​：定义代币存储结构​​- 指令集​​：标准化的操作接口\n\n核心组件\n代币程序（Token Program）包含与网络上的代币（包括可替代和不可替代）交互的所有指令逻辑。\n铸币账户（Mint Account）代表一种特定类型的代币，并存储关于代 币的全局元数据，如总供应量和铸造权限（有权创建新代币单位的地址）。\n代币账户（Token Account）跟踪特定地址拥有的特定类型代币（铸 造账户）的单位数量。\n关联代币账户（Associated Token Account）\n\nToken Program（代币程序）Token Program（代币程序）是 Solana 上的智能合约，负责处理所有代币操作的核心逻辑。它提供了一套标准化的接口，支持创建和管理各种类型的代币\n核心功能​​账户初始化​​：创建铸币账户和代币账户​​代币铸造​​：增发新的代币单位​​代币转移​​：在账户间转移代币​​代币销毁​​：减少代币供应量​​权限管理​​：控制铸币、冻结等权限​​委托操作​​：允许第三方临时管理代币\nMint Account（铸币账户）Mint Account（铸币账户）是代币的“定义文件”，存储代币的全局元数据。每个铸币账户代表一种独特的代币类型。\n属性\nDecimals（小数位数）：定义代币的最小单位，通常是 0 到 9（创建后不可更改）\nSupply（供应量）：代币的当前总供应量\nMint Authority（铸币权限）：可以铸造新的代币的账户，用于控制增发\nFreeze Authority（冻结权限）：可以冻结或解冻代币账户的权限（可选）\n​​唯一标识​​：每个铸币账户地址对应一种代币\n\n功能\n铸造代币：当 Mint Authority 执行铸币操作时，新的代币会增加到总供应量中，并分配给指定的 Token Account\n销毁代币：减少总供应量\n\nToken Account（代币账户）Token Account（代币账户）存储特定用户持有的特定代币的数量和状态信息。每个代币账户：\n\n关联一个铸币账户（代币类型）\n关联一个所有者（用户或程序）\n记录当前余额\n\n属性\nAmount（余额）：账户中持有的代币数量\nOwner（账户拥有者）：控制该账户的用户或合约地址\nMint（铸币账户关联）：该账户与哪个 Mint Account 相关联\nDelegate（代理账户）：可以被授权管理该账户的其他账户（可选）\nState（状态）：账户是否处于冻结状态\n\n功能\n接受和发送代币：Token Account 可以接受其他账户的代币，并通过转账指令将其发送给其他账户\n代理权限管理：可以设置 Delegate 来授权第三方管理该账户的代币\n\nAssociated Token Account（关联代币账户）Associated Token Account（ATA）是 Token Account 的一种特殊类型，简化了 SPL Token 的账户管理\nATA 是自动与一个钱包地址绑定的账户，每个代币账户 Token Account 和每个铸币账户 Mint Account 对应一个唯一的 ATA，该账户类型极大简化了代币管理\n传统代币账户的问题假设 Alice 想给 Bob 发送 USDC：\n\nAlice 需要知道 Bob 的 USDC 账户地址如果 Bob 还没有 USDC 账户，Alice 无法发送Bob 必须手动创建账户并告诉 Alice 地址整个过程繁琐且容易出错ATA 如何解决问题\n\n使用 ATA 解决问题\nAlice 通过公式计算 Bob 的 USDC 邮箱地址如果邮箱不存在，Alice 可以顺便创建它直接发送 USDC 到计算出的地址Bob 自动收到 USDC，无需任何操作\n\n特点\n唯一性：每个钱包地址只能有一个和某个 Mint 关联的 ATA\n自动生成：Solana 提供了工具来自动生成 ATA，处理钱包地址与代币账户之间的关联，方便用户管理不同的 SPL Token\n\nToken 命令创建 Tokenspl-token create-token\n\nspl-token create-token --decimals 2 --name &quot;My Token&quot; --symbol &quot;MTK&quot; --url &quot;https://my.token.url&quot;\n\n查看 Token 账户spl-token account-info --address &lt;token_address&gt;\n\nSPL Token Mint  Address: HHfsG1zwz175BTtRiL8LqXhzgjUFXNBf7YtXsjfyMMvJ # TOKEN_MINT_ADDRESS  Program: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA  Supply: 0  Decimals: 9  Mint authority: WoFtMc6fw3C4EkJr2JYfH4kEAd75sChvsz5HR5Q3joU # wallet pubkey  Freeze authority: (not set)\n\n创建 Associated Token Accountspl-token create-account &lt;TOKEN_MINT_ADDRESS&gt;\n\nCreating account 91HoZZtpRoGrHnFTRqu4Yf2VAZVDymEzRBKnVGT7f4s7 # ATASignature: 3CFByMJ7mH5rUgE5FZYSCjj7J5Zd2PavG1vWvTCzVKs1n3QiHvvrd2CPPaFZiHFzsjp953Ta4kBpf3g4X3bDmzMP\n\n创建 Token Accountspl-token create-account &lt;TOKEN_MINT_ADDRESS&gt; &lt;ACCOUNT_KEYPAIR&gt;\n\nCreating account DbXozEQpYYFJGnUNvwfYbYvP8iqiqMV7N8BwDf59vpro # TOKEN_ACCOUNT_ADDRESSSignature: 5sRBKd8fTQZmZyNkvVYgqDmbU4CCDqxf9o2pbEn7ZPC7JwqbYVLNtRjTuDErF2sjTsCob9fjLQ7xmhqQHkMNr2xz\n\nmint自动 mint 到 ATA（关联代币账户）中spl-token mint &lt;TOKEN_MINT_ADDRESS&gt; &lt;amount&gt;\n\nMinting 100 tokens  Token: HHfsG1zwz175BTtRiL8LqXhzgjUFXNBf7YtXsjfyMMvJ  Recipient: 91HoZZtpRoGrHnFTRqu4Yf2VAZVDymEzRBKnVGT7f4s7Signature: 4TC95YXBhhY5WUGBDs622yyWiE3hG7aRU3dZkWxWrQsXFhjr3DpMB4AtX4q2jsudMV8fr3gogabQLvzkaPbh81vu\n\nmint 到 Token Account 中spl-token mint &lt;TOKEN_MINT_ADDRESS&gt; &lt;amount&gt; -- &lt;TOKEN_ACCOUNT_ADDRESS&gt;\n\nMinting 100 tokens  Token: HHfsG1zwz175BTtRiL8LqXhzgjUFXNBf7YtXsjfyMMvJ  Recipient: DbXozEQpYYFJGnUNvwfYbYvP8iqiqMV7N8BwDf59vproSignature: 5STxsFQh5PQfN1zSjVYiTmzcgzwwXzGjpU4gQbTYjrMGT5JgDCQCcXqCVZGeEUnr3WDSKMSAqv68SQqLBoBEuWB7\n","categories":["Solana - IB课程"],"tags":["Solana"]}]