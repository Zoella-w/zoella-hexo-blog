[{"title":"vue 指令语法","url":"/2023/11/06/2-vue%E6%8C%87%E4%BB%A4%E8%AF%AD%E6%B3%95/","content":"指令种类：v-html, v-bind, v-on, v-model, v-slot …\n指令语法如下图所示：\n动态参数（1）动态参数的值应为字符串或 null（null 会移除该绑定）\n（2）动态参数的名称避免使用大写字母，因为会被强制转为小写（someAttr -&gt; someattr）\n&lt;a :[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;&lt;a @[eventName]=&quot;doSomething&quot;&gt;\n\n修饰符修饰符为以点开头的特殊后缀，比如：.prevent 修饰符会告知 v-on 指令对触发的事件调用 event.preventDefault()\n&lt;div @submit.prevent=&quot;onSubmit&quot;&gt;&lt;/div&gt;\n\nv-htmlspan 的内容会被替换为 rawHtml 属性的值，其中的数据绑定会被忽略（注意：使用这种方法容易造成 XSS 漏洞）\n&lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;\n\nv-bind&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;&lt;!--简写--&gt;&lt;div :id=&quot;dynamicId&quot;&gt;&lt;/div&gt;\n\n动态绑定多个值const objOfAttrs = &#123;    id: &#x27;container&#x27;,    class: &#x27;wrapper&#x27;&#125;;\n\n&lt;div :objOfAttrs&gt;&lt;/div&gt;\n\n比如：动态 style class\n&lt;div :style=&quot;&#123;class1: isClass1, class2: isClass2&#125;&quot;&gt;&lt;/div&gt;\n\nv-on&lt;div v-on:click=&quot;onClick&quot;&gt;&lt;/div&gt;&lt;!--简写--&gt;&lt;div @click=&quot;onClick&quot;&gt;&lt;/div&gt;\n\nv-ifv-if, v-else-if, v-else\n注意：v-if 的优先级大于 v-for，二者不建议同时使用（详见 v-for）\ntemplate 上的 v-if如果想要切换不止一个元素，可以在元素外包一个 &lt;template&gt;，并用 v-if 控制（v-show 不能在 template 上使用）\n因为 &lt;template&gt; 是一个不可见的包装器元素，渲染的结果中不会包含该元素\nv-if &amp; v-show（1）原理：v-if 切换时，条件区块会被销毁与重建；v-show 切换时，只会切换 display 属性\n（2）惰性：v-if 是惰性的，如果初始为 false 则不渲染；v-show 初始始终会渲染\n（3）场景：v-if 初始渲染开销较好，不会频繁切换时使用；v-show 切换开销较小，频繁切换时使用\n","categories":["vue - 文档"],"tags":["vue"]},{"title":"vue3 应用的创建&使用","url":"/2023/11/06/1-vue3%E5%BA%94%E7%94%A8%E7%9A%84%E5%88%9B%E5%BB%BA&%E4%BD%BF%E7%94%A8/","content":"创建应用npm create vue@latest\n\n通过CDN使用vue这里使用了提供 npm 包服务的 CDN —— unpkg\n&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;\n\nDOM 中的根组件模板当根组件没有设置 template 选项时，Vue 将自动使用容器的 innerHTML 作为模板\n这种方式通常用于此种“无构建步骤”（通过 CDN 使用 vue）的应用程序\n&lt;div id=&quot;app&quot;&gt;  &lt;button @click=&quot;count++&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/div&gt;\n\nimport &#123; createApp &#125; from &#x27;vue&#x27;;const app = createApp(&#123;  data() &#123;    return &#123;      count: 0    &#125;  &#125;&#125;).mount(&#x27;#app&#x27;);\n\n全局构建上述链接使用 全局构建 版本的 Vue，所有顶层 API 都暴露为全局 Vue 对象的属性\n&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;script&gt;  const &#123; createApp, ref &#125; = Vue;/**  1. 创建应用并挂载 */  createApp(&#123;    setup() &#123;      const message = ref(&#x27;Hello world!&#x27;);      return &#123;        message      &#125;;    &#125;  &#125;).mount(&#x27;#app&#x27;);    /**  2. 分步骤 */  // // a. 创建应用  // const app = createApp(&#123;  //   setup() &#123;  //     const message = ref(&#x27;Hello world!&#x27;);  //     return &#123;  //       message  //     &#125;  //   &#125;;  // &#125;);  // // b. 挂载  // app.mount(&#x27;#app&#x27;);&lt;/script&gt;\n\n导入映射表（Import maps）不使用完整的 CDN URL 引入，而使用 es6 的导入映射表（import maps）\n&lt;script type=&quot;importmap&quot;&gt;  &#123;    &quot;imports&quot;: &#123;      &quot;vue&quot;: &quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;    &#125;  &#125;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;script type=&quot;module&quot;&gt;  import &#123; createApp, ref &#125; from &quot;vue&quot;;  createApp(&#123;    setup() &#123;      const message = ref(&quot;Hello world!&quot;);      return &#123;        message      &#125;;    &#125;  &#125;).mount(&#x27;#app&#x27;);&lt;/script&gt;\n\n拆分模块将代码拆分为单独的 js 文件以便管理\n出于安全原因，es 模块只能通过 http 协议工作，所以需要使用本地的 http 服务器，通过 http 协议提供 index.html。比如：安装 Node.js，在 html 文件所在的文件夹运行 npx serve\n&lt;!-- index.html --&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;script type=&quot;module&quot;&gt;  import &#123; createApp &#125; from &#x27;vue&#x27;;  import MyComponent from &#x27;./my-component.js&#x27;;  createApp(MyComponent).mount(&#x27;#app&#x27;);&lt;/script&gt;\n\n// my-component.jsimport &#123; ref &#125; from &#x27;vue&#x27;;export default &#123;  setup() &#123;    const count = ref(0);    return &#123; count &#125;;  &#125;,  template: `&lt;div&gt;count is &#123;&#123; count &#125;&#125;&lt;/div&gt;`&#125;\n","categories":["vue3 - 文档"],"tags":["vue3","vue"]},{"title":"vue3 响应式","url":"/2023/11/06/3-vue3%E5%93%8D%E5%BA%94%E5%BC%8F/","content":"ref()ref() 返回一个包含属性 value 的对象\nimport &#123; ref &#125; from &#x27;vue&#x27;;export default &#123;    setup() &#123;        const count = ref(0);        function increment() &#123;            count.value++;        &#125;        return &#123;            count,            increment        &#125;    &#125;&#125;\n\n&lt;button @click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;\n\n原理ref 的 .value 属性使得 Vue 可以检测其何时被访问或修改\n当一个组件首次渲染时，Vue 会追踪在渲染过程中使用的每一个 ref；当一个 ref 被修改时，它会触发 追踪它的组件 的重新渲染\n// 伪代码const myRef = &#123;    _value: 0,    get value() &#123;        track(); // 追踪渲染过程中使用的每一个 ref        return this._value;    &#125;,    set value(newValue) &#123;        this._value = newValue;        trigger(); // 触发追踪它的组件的重新渲染    &#125;&#125;\n\n&lt;script setup&gt;使用 &lt;script setup&gt; 简化代码\n&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;;const count = ref(0);function increment() &#123;    count.value++;&#125;&lt;/script&gt;&lt;template&gt;    &lt;button @click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;\n\nDOM 更新时机DOM 更新后，立即执行回调函数\nimport &#123; nextTick &#125; from &#x27;vue&#x27;;async function increment() &#123;    count.value++;    await nextTick();    callback();&#125;\n\n或者\nimport &#123; nextTick &#125; from &#x27;vue&#x27;;function increment() &#123;    count.value++;    nextTick(() =&gt; callback());&#125;\n\nreactive()reactive() 使对象本身具有响应性，当 ref 的值是一个对象时，会在内层调用 reactive\n原理reactive() 返回原始对象的 proxy，允许 Vue 拦截和定义基本操作的行为（如属性查找、赋值、删除等）\nreactive() 的返回值和原始对象不相等\nconst raw = &#123;&#125;;const proxy = reactive(raw);console.log(raw === proxy); // false\n\nreactive() 的局限性（1）有限的值类型：只能用于对象类型（对象、数组、Map、Set），不能用于原始类型；\n（2）不能替换整个对象：替换整个对象会导致响应式连接丢失；\n（3）对解构操作不友好：解构后的变量会丢失响应式连接。\nref 解包ref 作为 reactive 对象属性ref 作为响应式对象的属性时，就像一个普通的属性\nconst count = ref(0);const state = reactive(&#123; count &#125;);console.log(state.count); // 0state.count = 1;console.log(state.count); // 1\n\n在模板中解包在模板渲染上下文中，只有顶级的 ref 才会被解包\n第二个不符合预期是因为，obj.id 未被解包，仍是一个 ref 对象\nconst count = ref(0);const obj = &#123;    id: ref(1)&#125;;\n\n&lt;!-- 符合预期 —— 2 --&gt;&#123;&#123; count + 1 &#125;&#125;&lt;!-- 不符合预期 —— [object Object]1 --&gt;&#123;&#123; obj.id + 1 &#125;&#125;\n\n为了解决该问题，需要将 id 结构为顶级属性\nconst &#123; id &#125; = obj;\n\n&lt;!-- 符合预期 —— 2 --&gt;&#123;&#123; id + 1 &#125;&#125;\n","categories":["vue3 - 文档"],"tags":["vue3","vue"]},{"title":"vue3 计算属性","url":"/2023/11/07/4-vue3%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/","content":"基础computed() 方法接受一个 getter 函数，返回一个计算属性 ref\n因为 ref 会在模板中自动解包，所以在表达式中引用无需 .value\n&lt;script setup&gt;import &#123; reactive, computed &#125; from &#x27;vue&#x27;;const author = reactive(&#123;    name: &quot;Zoella&quot;,    books: [&#x27;vue2&#x27;, &#x27;vue3&#x27;, &#x27;vue4&#x27;]&#125;);const hasBookPublished = computed(() =&gt; &#123;    return author.books.length &gt; 0 ? &#x27;yes&#x27; : &#x27;no&#x27;;&#125;);&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;span&gt;&#123;&#123; author.name &#125;&#125;&lt;/span&gt; has published books:     &lt;span&gt;&#123;&#123; hasBookPublished &#125;&#125;&lt;/span&gt;  &lt;/div&gt;&lt;/template&gt;\n\n计算属性缓存 VS 方法&lt;p&gt;&#123;&#123; calculateBooksMessage() &#125;&#125;&lt;/p&gt;\n\nfunction calculateBooksMessage() &#123;  return author.books.length &gt; 0 ? &#x27;yes&#x27; : &#x27;no&#x27;;&#125;\n\n计算属性比方法节省性能。\n将与上述相同的函数定义为方法，结果和计算属性相同，然而 计算属性值会基于其响应式依赖被缓存，只要author.books不变，就不会重复执行 getter 函数。但是方法总会在重渲染发生时再次执行函数。\n可写计算属性计算属性默认为只读。特殊场景下会用到“可写”的计算属性。\n&lt;script&gt;import &#123; ref, computed &#125; from &#x27;vue&#x27;;const firstName = ref(&#x27;John&#x27;);const lastName = ref(&#x27;Doe&#x27;);const fullName = computed(&#123;  // getter  get() &#123;    return firstName.value + &#x27; &#x27; + lastName.value;  &#125;,  // setter  set(newValue) &#123;    [firstName.value, lastName.value] = newValue.split(&#x27;&#x27;);  &#125;&#125;)&lt;/script&gt;\n\n当运行 fullName.value = &#39;Zoella Wang&#39; 时，setter会被调用，firstName 和 lastName 会随之更新。\n","categories":["vue3 - 文档"],"tags":["vue3","vue"]},{"title":"为什么 vue 组件添加 scoped 后，某些组件样式不生效","url":"/2023/11/14/5-%E4%B8%BA%E4%BB%80%E4%B9%88vue%E7%BB%84%E4%BB%B6%E6%B7%BB%E5%8A%A0scoped%E5%90%8E%E6%9F%90%E4%BA%9B%E7%BB%84%E4%BB%B6%E6%A0%B7%E5%BC%8F%E4%B8%8D%E7%94%9F%E6%95%88/","content":"简述在父组件中修改子组件的某些样式，发现不生效，删去&lt;style scoped&gt;&lt;/style&gt;中的 scoped 后生效。\n原因scoped 实现样式隔离的原理为：\n编译时，父组件的所有标签、子组件的根标签、以及所有的样式 都会加上特殊的标识；\n因为子组件内部的标签都没有此种标识，所以样式就不会生效。\n实例不添加 scoped&lt;!-- 父组件 --&gt;&lt;template&gt;  &lt;div class=&quot;parent&quot;&gt;    &lt;p&gt;Here is parent component&lt;/p&gt;    &lt;TestScoped /&gt;    &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.parent &#123;  color: deepskyblue;&#125;&lt;/style&gt;\n\n&lt;!-- 子组件 --&gt;&lt;template&gt;  &lt;div class=&quot;son&quot;&gt;    &lt;p&gt;Here is son component&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;\n\n编译后：\n&lt;div class=&quot;parent&quot;&gt;    &lt;p&gt;Here is parent component&lt;/p&gt;    &lt;div class=&quot;son&quot;&gt;        &lt;p&gt;Here is son component&lt;/p&gt;    &lt;/div&gt;&lt;/div&gt;\n\np &#123;  color: deepskyblue;&#125;\n\n添加 scoped编译后：\n&lt;div data-v-7ba5bd90 class=&quot;parent&quot;&gt;    &lt;p data-v-7ba5bd90&gt;Here is parent component&lt;/p&gt;    &lt;div data-v-7ba5bd90 class=&quot;son&quot;&gt;        &lt;!-- 没有标识，所以不生效 --&gt;        &lt;p&gt;Here is son component&lt;/p&gt;    &lt;/div&gt;&lt;/div&gt;\n\np[data-v-7ba5bd90] &#123;    color: deepskyblue;&#125;\n\n解决方法深度作用选择器使用 &#x2F;deep&#x2F; 或者 ::v-deep\n/deep/ p &#123;  color: deepskyblue;&#125;/* 或者 */::v-deep p &#123;  color: deepskyblue;&#125;\n\n编译后：\nhtml 结果不变，样式代码变化\n[data-v-7ba5bd90] p &#123;  color: deepskyblue;&#125;\n\n使用无 scoped 的 style&lt;style scoped&gt;p &#123;  color: deepskyblue;&#125;&lt;/style&gt;&lt;style&gt;/* 生效样式代码 */&lt;/style&gt;\n","categories":["vue - 样式"],"tags":["vue","实践问题"]},{"title":"vue class 与 style 绑定","url":"/2023/11/28/6-vue%20class%E4%B8%8Estyle%E7%BB%91%E5%AE%9A/","content":"绑定一个返回对象的计算属性const isActive = ref(true);const error = ref(null);const classObject = computed(() =&gt; (&#123;    active: isActive.value &amp;&amp; !error.value,    &#x27;text-danger&#x27;: error.value &amp;&amp; error.value.type === &#x27;fatal&#x27;&#125;));\n\n&lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt;\n\n子组件继承父组件传入的class有一个根元素的组件子组件的根元素，在渲染时会添加父组件的 class。\n有多个根元素的组件子组件中 :class=&#39;$attrs.class&#39; 的根元素，在渲染时会添加父组件的 class。\n&lt;!-- 子组件 MyComponent.vue --&gt;&lt;p :class=&quot;$attrs.class&quot;&gt;one root element&lt;/p&gt;&lt;span&gt;another root element&lt;/span&gt;\n\n&lt;!-- 父组件 --&gt;&lt;MyComponent class=&quot;fatherClass&quot;/&gt;\n\n渲染后结果：\n&lt;p class=&quot;fatherClass&quot;&gt;one root element&lt;/p&gt;&lt;span&gt;another root element&lt;/span&gt;\n\n內联样式绑定对象const styleObject = reactive(&#123;    color: &quot;red&quot;,    fontSize: &quot;13px&quot;&#125;);\n\n&lt;div :style=&quot;styleObject&quot;&gt;&lt;/div&gt;\n\n绑定对象数组&lt;div :style=&quot;[baseStyle, overriddingStyle]&quot;&gt;&lt;/div&gt;\n\nconst baseStyle = reactive(&#123;    color: &quot;red&quot;,    ...&#125;);const overriddingStyle = reactive(&#123;    color: &quot;black&quot;,    ...&#125;);\n","categories":["vue - 样式","vue3 - 文档"],"tags":["vue3","vue"]},{"title":"v-for","url":"/2023/11/29/7-v-for/","content":"基础&lt;li v-for=&quot;(item, index) in items&quot;&gt;&lt;/li&gt;\n\n可以使用 of 代替 in：\n&lt;li v-for=&quot;(item, index) of items&quot;&gt;&lt;/li&gt;\n\n支持解构语法：\n&lt;li v-for=&quot;&#123;message&#125; in items&quot;&gt;    &#123;&#123; message &#125;&#125;&lt;/li&gt;&lt;li v-for=&quot;(&#123;message&#125;, index) in items&quot;&gt;    &#123;&#123; message &#125;&#125;&lt;/li&gt;\n\n遍历对象属性使用 v-for 遍历对象属性，遍历的顺序和 Object.keys() 返回值的顺序一致\n三个参数依次为 索引、属性名、属性值：\nconst myObject = reactive(&#123;  title: &#x27;How to do lists in Vue&#x27;,  author: &#x27;Jane Doe&#x27;,  publishedAt: &#x27;2016-04-10&#x27;&#125;);\n\n&lt;li v-for=&quot;(index, key, value) in myObject&quot;&gt;&#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/li&gt;\n\n结果为：\n0. title: How to do lists in Vue1. author: Jane Doe2. publishedAt: 2016-04-10\n\nv-for 与 v-ifv-if 比 v-for 优先级高\n错误用法：\n&lt;!-- 此时 v-if 的 todo 还没有定义 --&gt;&lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt;&#123;&#123; todo.name &#125;&#125;&lt;/li&gt;\n\n正确用法：\n&lt;template v-for=&quot;todo in todos&quot;&gt;   &lt;li v-if=&quot;!todo.isComplete&quot;&gt;   &#123;&#123; todo.name &#125;&#125;   &lt;/li&gt;&lt;/template&gt;\n\n通过 key 管理状态Vue 默认按照 “就地更新” 的策略更新通过 v-for 渲染的列表。当数据项的顺序改变时，Vue 不会随之移动 DOM 元素的顺序，而是就地更新每个元素，确保它们在原本指定的索引位置上渲染。\n默认模式是高效的，但只适用于 列表渲染输出的结果不依赖子组件状态或者临时 DOM 状态 (例如表单输入值) 的情况。\n推荐在任何时候为 v-for 提供一个 key attribute，除非所迭代的 DOM 内容非常简单。\n","categories":["vue - 文档"],"tags":["vue"]},{"title":"js 事件","url":"/2023/11/29/8-js%E4%BA%8B%E4%BB%B6/","content":"事件捕获和事件冒泡 是浏览器处理DOM元素事件的两种方式（顺序：先捕获，再冒泡）。\n&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;body&gt;      &lt;div&gt;click me&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\n事件捕获事件捕获从文档根节点开始，逐级向下传播到目标元素。\n点击 div，事件传播方向：document -&gt; html -&gt; body -&gt; div\n事件冒泡事件冒泡指当目标元素触发了某事件时，事件会从该元素开始逐级向上传播，直到文档根节点。\n点击 div，事件传播方向：div -&gt; body -&gt; html -&gt; document\n事件模型DOM0 事件模型DOM0 只在冒泡阶段处理事件处理程序。\n&lt;div onclick=&quot;handleClick&quot;&gt;click&lt;/div&gt;&lt;script&gt;  function handleClick() &#123;    alert(&#x27;clicked&#x27;);  &#125;&lt;/script&gt;\n\nDOM2 事件模型DOM2 在捕获阶段和冒泡阶段都可以处理事件处理程序（更灵活可控）。\n使用：addEventListener() 和 removeEventListener()\n&lt;div id=&quot;myBtn&quot;&gt;click&lt;/div&gt;&lt;script&gt;  function handleClick() &#123;    alert(&#x27;clicked&#x27;);  &#125;  const btn = document.getElementById(&#x27;myBtn&#x27;);  btn.addEventListener(&#x27;click&#x27;, handleClick);&lt;/script&gt;\n\nIE 事件模型功能类似于 DOM0，使用方式上类似于 DOM2。\n使用 attachEvent() 和 detachEvent() 方法。\n&lt;div id=&quot;myBtn&quot;&gt;click&lt;/div&gt;&lt;script&gt;  function handleClick() &#123;    alert(&#x27;clicked&#x27;);  &#125;  const btn = document.getElementById(&#x27;myBtn&#x27;);  btn.attachEvent(&#x27;click&#x27;, handleClick);&lt;/script&gt;\n\njs 实现事件修饰符阻止默认行为 preventDefault比如阻止链接的跳转或表单的提交\ndocument.getElementById(&#x27;btn&#x27;).addEventListener(&#x27;click&#x27;, (event) =&gt; &#123;  event.preventDefault();&#125;);\n\n阻止事件冒泡 stopPropagation()阻止事件传到父元素\ndocument.getElementById(&#x27;btn&#x27;).addEventListener(&#x27;click&#x27;, (event) =&gt; &#123;  event.stopPropagation();&#125;);\n\n一次性事件处理function handleClick(event) &#123;  this.removeEventListener(&#x27;click&#x27;, handleClick); // 点击一次移除监听器&#125;document.getElementById(&#x27;btn&#x27;).addEventListener(&#x27;click&#x27;, handleClick);\n\n获取键盘按键document.addEventListener(&#x27;keydown&#x27;, (event) =&gt; &#123;  console.log(event.key);&#125;);\n\n获取鼠标按键document.addEventListener(&#x27;mousedown&#x27;, (event) =&gt; &#123;  console.log(event.key);&#125;);\n","categories":["JavaScript - 事件"],"tags":["JavaScript"]},{"title":"vue 事件处理","url":"/2023/11/30/9-vue%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/","content":"v-on:click&#x3D;”” 缩写为 @click\n在內联事件处理器中访问事件参数在內联事件中访问原生 DOM 事件：\n向处理器中传入一个 $event 变量&lt;button @click=&quot;warn(&#x27;message1&#x27;, $event)&quot;&gt;Submit&lt;/button&gt;\n\n使用内联箭头函数&lt;button @click=&quot;(event) =&gt; warn(&#x27;message1&#x27;, event)&quot;&gt;Submit&lt;/button&gt;\n\nfunction warn(message, event) &#123;  // 在此处可以访问原生事件  if (event) &#123;    event.preventDefault()  &#125;  alert(message)&#125;\n\n事件修饰符\nstop：调用 event.stopPropagation()，阻止事件继续传播。\nprevent：调用 event.preventDefault()，阻止事件的默认行为。\nself：只当事件是从原始目标元素本身触发时触发回调，如果事件是从内部元素冒泡上来的则不触发。\ncapture：添加事件监听器时使用 capture 模式，即在捕获阶段触发而不是冒泡阶段。\nonce：只触发一次事件，之后移除该监听器。\npassive：提升页面滚动性能，告诉浏览器事件处理函数不会调用 event.preventDefault()。\n\n（1）.stop&lt;div @click.stop=&quot;handleOuterClick&quot;&gt;  &lt;button @click=&quot;handleInnerClick&quot;&gt;内部按钮&lt;/button&gt;&lt;/div&gt;\n\n当内部按钮被点击时，handleOuterClick 不会被触发，因为事件不会继续向外部元素传播。\n（2）.prevent&lt;form @submit.prevent=&quot;handleSubmit&quot;&gt;  &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;&lt;/form&gt;\n\nhandleSubmit 方法中的 event.preventDefault() 将会被调用，从而阻止表单的默认提交行为。\n（3）.self&lt;div @click.self=&quot;handleClick&quot;&gt;只有当点击该div本身时触发&lt;/div&gt;\n\n只有当点击该 div 元素本身时，handleClick 方法才会被触发；div 内部其他元素冒泡上来的事件不会触发。\n（4）.once&lt;button @click.once=&quot;handleClick&quot;&gt;点击我，只触发一次&lt;/button&gt;\n\n当按钮被点击后，handleClick 方法只会被触发一次，之后该事件监听器会被移除。\n（5）.capture&lt;div @click.capture=&quot;handleCaptureClick&quot;&gt;捕获阶段触发&lt;/div&gt;\n\n事件监听器将在捕获阶段（从外向内）触发，而不是在冒泡阶段触发。\n（6）.passive&lt;div @touchstart.passive=&quot;handleTouchStart&quot;&gt;优化页面滚动性能&lt;/div&gt;\n\n告诉浏览器 handleTouchStart 方法不会调用 event.preventDefault()，从而有助于提升页面滚动的性能。\n按键修饰符中的 .enter 就是按键修饰符。### 常规按键- enter- tab- delete (捕获“Delete”和“Backspace”两个按键)- esc- space- up- down- left- right### 系统按键系统按键和常规按键不同的是，与 keyup 一起使用时，只有当系统按键被 **按下** 并松开其他键才会触发。- ctrl- alt- shift- meta举例：``` html&lt;!-- 常规按键 --&gt;&lt;!-- 当 Alt + Enter 抬起时，触发 submit 事件 --&gt;&lt;input @keyup.alt.enter=&quot;submit&quot; /&gt;&lt;!-- 系统按键 --&gt;&lt;!-- 当 按下 ctrl 时触发 --&gt;&lt;div @click.ctrl=&quot;doSth&quot;&gt;A&lt;/div&gt;&lt;!-- 当 按住 ctrl + 抬起其他键 时触发 --&gt;&lt;div @keyup.ctrl=&quot;doSth&quot;&gt;A&lt;/div&gt;\n\n.exact 修饰符.exact 用于确定触发事件的确定组合。\n举例：\n&lt;!-- 当抬起 Ctrl 时，即使同时抬起其他系统按键也会触发 --&gt;&lt;button @keyup.ctrl=&quot;doSth&quot;&gt;A&lt;/button&gt;&lt;!-- 仅当抬起 Ctrl 且未抬起任何其他键时才会触发 --&gt;&lt;button @keyup.ctrl.exact=&quot;doSth&quot;&gt;A&lt;/button&gt;&lt;!-- 仅当没有抬起任何系统按键时触发 --&gt;&lt;button @keyup.exact=&quot;doSth&quot;&gt;A&lt;/button&gt;\n","categories":["vue - 文档"],"tags":["vue"]},{"title":"v-model","url":"/2023/12/05/10-v-model/","content":"基础&lt;input    :value=&quot;text&quot;    @input=&quot;event =&gt; text = event.target.value&quot; /&gt;\n\n用 v-model 简化：\n&lt;input v-model=&quot;text&quot; /&gt;\n\n类型单行&lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;input v-model=&quot;message&quot; placeholder=&quot;edit&quot; /&gt;\n\n多行&lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;textarea v-model=&quot;message&quot; placeholder=&quot;edit&quot;&gt;&lt;/textarea&gt;\n\n复选框label 标签 for 属性的作用：用户点击 label 标签时，浏览器会将焦点转移到与 for 属性值相匹配的表单控件上，从而提高表单的可访问性和易用性。\n&lt;div&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/div&gt;&lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt;&lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt;&lt;label for=&quot;john&quot;&gt;John&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt;&lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt;\n\n单选&lt;div&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/div&gt;&lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot; /&gt;&lt;label for=&quot;one&quot;&gt;One&lt;/label&gt;&lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot; /&gt;&lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt;\n\n选择器单个：\n&lt;div&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/div&gt;&lt;select v-model=&quot;selected&quot;&gt;  &lt;option disabled value=&quot;&quot;&gt;Please select one&lt;/option&gt;  &lt;option&gt;A&lt;/option&gt;  &lt;option&gt;B&lt;/option&gt;  &lt;option&gt;C&lt;/option&gt;&lt;/select&gt;\n\n多个（将值绑定到数组上）：\n&lt;div&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/div&gt;&lt;select v-model=&quot;selected&quot; multiple&gt;  &lt;option&gt;A&lt;/option&gt;  &lt;option&gt;B&lt;/option&gt;  &lt;option&gt;C&lt;/option&gt;&lt;/select&gt;\n\n修饰符.lazy.lazy 修饰符表示在 “change” 事件而不是 “input” 事件触发时更新：\n这意味着数据将在失去焦点后才会同步到视图中，而不是每次输入时都同步。可以用于减少输入框频繁更新视图的情况，尤其是在处理大量输入时可以提高性能。\n&lt;input v-model.lazy=&quot;msg&quot; /&gt;\n\n.number让用户输入自动转换为数字，如果该值无法被 parseFloat() 处理，则将返回原始值。\nnumber 修饰符会在输入框有 type&#x3D;”number” 时自动启用。\n&lt;input v-model.lazy=&quot;msg&quot; /&gt;\n\n.trim默认自动去除用户输入内容中两端的空格：\n&lt;input v-model.trim=&quot;msg&quot; /&gt;\n","categories":["vue - 文档"],"tags":["vue"]},{"title":"vue3 生命周期","url":"/2023/12/05/11-vue3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","content":"vue3 生命周期图示\n\n注册生命钩子用法&lt;script setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;;onMounted(() =&gt; &#123;    console.log(&#x27;now mounted&#x27;);&#125;);&lt;/script&gt;\n\n调用 onMounted 时，Vue 会自动将回调函数注册到当前正被初始化的组件实例上，所以该钩子应当被同步注册。\n这并不意味对 onMounted 的调用必须放在 setup() 或 &lt;script setup&gt; 内的词法上下文中。\nonMounted() 也可以在一个外部函数中调用，只要调用栈是同步的，且最终起源自 setup() 就可以。\n","categories":["vue3 - 文档"],"tags":["vue3","vue"]},{"title":"vue3 侦听器","url":"/2023/12/07/12-vue3%E4%BE%A6%E5%90%AC%E5%99%A8/","content":"基本用法&lt;script setup&gt;import &#123; ref, watch &#125; from &#x27;vue&#x27;;const initVal = ref(&#x27;&#x27;);watch(initVal, (newVal, oldVal) =&gt; &#123;    ...&#125;);&lt;/script&gt;\n\n侦听数据源类型ref（包括计算属性 computed）、响应式对象、getter 函数、多个数据源组成的数组\nconst x = ref(0), y = ref(0);// refwatch(x, (newX) =&gt; &#123;    console.log(`x is $&#123;newX&#125;`);&#125;);// getter 函数watch(    () =&gt; x.value + y.value,    (sum) =&gt; &#123;        console.log(`sum is $&#123;sum&#125;`);    &#125;);// 多个数据源组成的数组watch(    [x, () =&gt; y.value],    ([newX, newY], [oldX, oldY]) =&gt; &#123;        console.log(`x is $&#123;newX&#125; y is $&#123;newY&#125;`);    &#125;);\n\n侦听响应式对象的属性值不能直接监听响应式对象的属性值，而是使用返回该属性的 getter 函数\nconst obj = reactive(&#123; count: 0 &#125;);// 错误，因为 obj.count 是一个 numberwatch(obj.count, () =&gt; &#123;    .console.log(`count is: $&#123;count&#125;`)&#125;);// 正确，使用一个 getter 函数watch(    () =&gt; obj.count,    (count) =&gt; &#123;      console.log(`count is: $&#123;count&#125;`)    &#125;);\n\n深层侦听器给 watch 传响应式对象，会隐式创建深层监听器\nconst obj = reactive(&#123; count: 0 &#125;);watch(obj, (newVal, oldVal) =&gt; &#123;    ...&#125;);obj.count++; // 属性变更时触发\n\n返回一个响应对象的 getter 函数，只在返回不同对象时才会触发回调\nwatch(    () =&gt; source.obj,    () =&gt; &#123;        ... // 仅当 test.obj 被替换时触发    &#125;);\n\n可以显示添加 deep，转为深层侦听器\nwatch(    () =&gt; source.obj,    () =&gt; &#123;        ... // 仅当 test.obj 被替换时触发    &#125;,    &#123; deep: true &#125;);\n\n创建时立即执行的侦听器创建侦听器时，立即执行\nwatch(source,     (newVal, oldVal) =&gt; &#123;&#125;,     &#123; immediate: true &#125;);\n","categories":["vue3 - 文档"],"tags":["vue3","vue"]},{"title":"vue3 组件基础","url":"/2023/12/11/14-vue3%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/","content":"基础父传子defineProps 是仅在 &lt;script setup&gt; 中可用的编译宏命令\n&lt;script setup&gt;defineProps([&#x27;title&#x27;, &#x27;content&#x27;]);&lt;/script&gt;&lt;template&gt;&#123;&#123; title &#125;&#125;&#123;&#123; content &#125;&#125;&lt;/template&gt;\n\n子传父defineEmits 是仅在 &lt;script setup&gt; 中可用的编译宏命令\n&lt;script setup&gt;const emit = defineEmits(&#x27;enlarge-text&#x27;);emit(&#x27;enlarg-text&#x27;); // 抛出事件&lt;/script&gt;\n\nslot 插槽子组件：\n&lt;template&gt;    &lt;div class=&quot;child&quot;&gt;        &lt;span&gt;123&lt;/span&gt;        &lt;slot /&gt;    &lt;/div&gt;&lt;/template&gt;\n\n父组件：\n&lt;template&gt;    &lt;child-component&gt;        &lt;span&gt;hahaha&lt;span&gt;    &lt;/child-component&gt;&lt;/template&gt;\n\n子组件渲染结果为：\n&lt;template&gt;    &lt;div class=&quot;child&quot;&gt;        &lt;span&gt;123&lt;/span&gt;        &lt;span&gt;hahaha&lt;/span&gt;    &lt;/div&gt;&lt;/template&gt;\n\n子组件标签子组件有关闭标签父组件可以子组件传递 slot 内容\n&lt;my-component&gt;&lt;/my-component&gt;\n\n子组件无关闭标签父组件无法向子组件传递 slot 内容\n&lt;my-component /&gt;\n\n动态组件通过 component 组件，和 :is 属性切换动态组件\n&lt;template&gt;    &lt;!-- 点击切换 tab --&gt;    &lt;button v-for=&quot;tab in tabs&quot; @click=&quot;curTab = tab&quot;&gt;       &#123;&#123; tab &#125;&#125;    &lt;/button&gt;    &lt;!-- 动态组件 --&gt;   &lt;component :is=&quot;tabs[curTab]&quot;&gt;&lt;/component&gt;&lt;/template&gt;&lt;script setup&gt;import Home from &#x27;./Home.vue&#x27;;import Posts from &#x27;./Posts.vue&#x27;;import Archive from &#x27;./Archive.vue&#x27;;import &#123; ref &#125; from &#x27;vue&#x27;;const curTab = ref(&#x27;Home&#x27;); // 初始展示 Home 组件const tabs = &#123;    Home,    Posts,    Archive&#125;;&lt;/script&gt;\n\n元素位置限制某些元素对于放在其中的元素类型有限制：&lt;ul&gt;, &lt;ol&gt;, &lt;table&gt;, &lt;select&gt;\n某些元素仅在特定元素中才会显示：&lt;li&gt;, &lt;tr&gt;, &lt;option&gt;\n&lt;table&gt;    &lt;!-- 自定组件在 &lt;table&gt; 中不生效 --&gt;    &lt;post-row&gt;&lt;/post-row&gt;&lt;/table&gt;\n\n解决方案（使用 is 属性）：\n&lt;table&gt;    &lt;tr is=&quot;vue:post-row&quot;&gt;&lt;/tr&gt;&lt;/table&gt;\n","categories":["vue3 - 文档"],"tags":["vue3","vue"]},{"title":"vue3 模板引用","url":"/2023/12/08/13-vue3%E6%A8%A1%E6%9D%BF%E5%BC%95%E7%94%A8/","content":"基础&lt;input ref=&quot;myInput&quot; /&gt;&lt;script setup&gt;    import &#123; ref, onMounted &#125; from &#x27;vue&#x27;;    const myInput = ref(null); // 必须和模版中的 ref 同名        onMounted(() =&gt; &#123;        myInput.value.focus(); // 自动聚焦    &#125;);&lt;/script&gt;\n\n只能在组件挂载后访问模板引用，因为初次渲染时模板引用为 null\n比如：\nwatchEffect(() =&gt; &#123;  if (input.value) &#123;    input.value.focus()  &#125; else &#123;    // 此时还未挂载，或此元素已卸载（例如 v-if=false）  &#125;&#125;)\n\n列表引用&lt;script setup&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;;const list = ref([    /* ... */]);const itemRefs = ref([]);onMounted(() =&gt; &#123;    console.log(itemRefs.value);&#125;);&lt;/script&gt;&lt;template&gt;    &lt;ul&gt;        &lt;li v-for=&quot;item in list&quot; ref=&quot;itemRefs&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;    &lt;/ul&gt;&lt;/template&gt;\n\n函数模板引用每次组件更新时会调用 handleRef：\n&lt;input :ref=&quot;handleRef(el)&quot; /&gt;&lt;script setup&gt;const handleRef = (el) =&gt; &#123;    /*  将 el 赋给 ref 变量 */&#125;;&lt;/script&gt;\n\n组件上的 ref引用获得的值是组件实例：\n&lt;script setup&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;;import Child from &#x27;./Child.vue&#x27;;const child = ref(null);onMounted(() =&gt; &#123;    // child.value 是 &lt;Child/&gt; 组件实例&#125;);&lt;/script&gt;&lt;template&gt;    &lt;Child ref=&quot;child&quot; /&gt;&lt;/template&gt;\n\n父组件对子组件访问权1. 选项式 API 或 不使用 &lt;script setup&gt;父组件对子组件的所有属性和方法有完全的访问权（大多情况下应使用 props 和 emit）。\n2. 使用 &lt;script setup&gt;子组件默认私有，除非子组件在其中通过 defineExpose 宏显示暴露。\n&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;;const a = 1, b = ref(2);// 编译器宏无需导入defineExpose(&#123;    a,    b&#125;);&lt;/script&gt;\n","categories":["vue3 - 文档"],"tags":["vue3","vue"]},{"title":"vue3 组件注册","url":"/2023/12/13/15-vue3%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C/","content":"全局注册所有子组件可以使用全局注册的组件。\n使用 vue 应用实例的 .component() 方法：\nimport &#123; createApp &#125; from &#x27;vue&#x27;;const app = createApp(&#123;&#125;);app.component(&#x27;myComponent&#x27;,&#123;    // 组件的实现&#125;);\n\n对于单文件组件：\nimport MyComponent from &#x27;./App.vue&#x27;app.component(&#x27;MyComponent&#x27;, MyComponent);\n\n链式：\napp.    component(&#x27;ComponentA&#x27;, ComponentA).    component(&#x27;ComponentB&#x27;, ComponentB).    component(&#x27;ComponentC&#x27;, ComponentC);\n\n局部注册优点\ntree-shaking：全局注册的组件，即使不用，也会出现在打包后的 JS 文件中；而局部注册会移除未使用的组件。\n依赖关系明确：全局注册使大型项目中组件的依赖关系不够明确；而局部组件使组件间的依赖关系更加明确。\n\n","categories":["vue3 - 文档"],"tags":["vue3","vue"]},{"title":"vue3 props & emits","url":"/2023/12/15/16-vue3%20props%20&%20emits/","content":"props注意：props 为单向数据流，从父组件流子组件，所以不应该在子组件中修改 props。\n如有需要：\n\n用另一个属性接收该 prop 的初始值；\n基于该 prop 定义一个计算属性；\n向父组件抛出一个事件。\n\n声明使用字符串数组：\n&lt;script setup&gt;const props = defineProps([&#x27;foo&#x27;]);&lt;/script&gt;\n\n使用对象：\n&lt;script setup&gt;const props = defineProps(&#123;    title: String,    likes: Number&#125;);&lt;/script&gt;\n\n静态 prop除了静态字符串，都应该使用变量进行传递。\n&lt;BlogPost title=&quot;this is a title&quot; /&gt;&lt;!-- &lt;BlogPost :likes=&quot;42&quot; /&gt; --&gt;&lt;BlogPost :likes=&quot;post.likes&quot; /&gt;&lt;!-- &lt;BlogPost is-published=&quot;true&quot; /&gt; --&gt;&lt;BlogPost :is-published=&quot;post.isPublished&quot; /&gt;&lt;!-- &lt;BlogPost ids=&quot;[1, 2, 3]&quot; /&gt; --&gt;&lt;BlogPost :ids=&quot;post.ids&quot; /&gt;&lt;!-- &lt;BlogPost author=&quot;&#123; name: &#x27;Zoella&#x27;, age: 22 &#125;&quot; /&gt; --&gt;&lt;BlogPost :author=&quot;post.author&quot; /&gt;\n\n一个对象绑定多个 prop使用无参数的 v-bind，而不是 :prop-name\nconst post = &#123;    id: 1,    title: &quot;this is title&quot;,&#125;;\n\n&lt;BlogPost v-bind=&quot;post&quot; /&gt;\n\nprop 校验defineProps(&#123;  // 多种可能的类型检查（给出 `null` 和 `undefined` 值则会跳过任何类型检查）  propA: [String, Number],  // 必传，且为 String 类型，默认值为 &#x27;defualtVal&#x27;  propB: &#123;    type: String,    required: true,    default: &#x27;defaultVal&#x27;  &#125;,  // 对象类型的默认值  propC: &#123;    type: Object,    // 对象或数组的默认值，必须从一个工厂函数返回。    // 该函数接收组件所接收的原始 prop 作为参数。    default(rawProps) &#123;      return &#123; message: &#x27;hello&#x27; &#125;    &#125;  &#125;,  // 自定义类型校验函数  propD: &#123;    validator(value) &#123;      return [&#x27;success&#x27;, &#x27;warning&#x27;, &#x27;danger&#x27;].includes(value)    &#125;  &#125;,  // 函数类型的默认值  propE: &#123;    type: Function,    default() &#123;      return &#x27;Default function&#x27;    &#125;  &#125;&#125;);\n\nBoolean 类型转换defineProps(&#123;  disabled: Boolean&#125;);\n\n使用时：\n&lt;!-- 等同于 &lt;MyComponent :disabled=&quot;true&quot;&gt;&lt;/MyComponent&gt; --&gt;&lt;MyComponent disabled&gt;&lt;/MyComponent&gt;&lt;!-- 等同于 &lt;MyComponent :disabled=&quot;false&quot;&gt;&lt;/MyComponent&gt; --&gt;&lt;MyComponent&gt;&lt;/MyComponent&gt;\n\nemit事件校验&lt;script setup&gt;const emit = defineEmits(&#123;  // 无校验  click: null,  // 校验 submit 事件  submit: (&#123; email, password &#125;) =&gt; &#123;    if (email &amp;&amp; password) &#123;      return true;    &#125; else &#123;      console.warn(&#x27;Invalid submit event payload!&#x27;)      return false;    &#125;  &#125;&#125;);function submitForm(email, password) &#123;  // 抛出 submit 事件，携带 email, password 参数  emit(&#x27;submit&#x27;, &#123; email, password &#125;);&#125;&lt;/script&gt;\n","categories":["vue3 - 文档"],"tags":["vue3","vue"]},{"title":"vue3 组件 v-model","url":"/2023/12/15/17-vue3%E7%BB%84%E4%BB%B6v-model/","content":"基础父组件：\n&lt;CustomInput v-model=&quot;searchText&quot; /&gt;&lt;!-- 被展开为： --&gt;&lt;!-- &lt;CustomInput    :model-value=&quot;searchText&quot;    @update:model-value=&quot;newValue =&gt; searchText = newValue&quot; /&gt; --&gt;\n\n子组件：\n在引用的子组件中使用 v-model 指令时，子组件的 modelValue prop 默认用于传递输入值，并且会触发名为 update:modelValue 的事件来更新该属性。\n&lt;script setup&gt;// 声明属性 modelValue，这是父组件通过 v-model 传给当前组件的 propdefineProps([&#x27;modelValue&#x27;]);// 声明事件 update:modelValue，用于在当前组件中触发父组件的更新操作defineEmits([&#x27;update:modelValue&#x27;]);&lt;/script&gt;&lt;template&gt;  &lt;!-- 将 modelValue 作为其值，并在输入时触发 update:modelValue 事件 --&gt;  &lt;input    :value=&quot;modelValue&quot;    @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;  /&gt;&lt;/template&gt;\n\n如何更改默认名 modelValue父组件：\n&lt;MyComponent v-model:title=&quot;bookTitle&quot; /&gt;\n\n子组件：\n&lt;!-- MyComponent.vue --&gt;&lt;script setup&gt;defineProps([&#x27;title&#x27;]);defineEmits([&#x27;update:title&#x27;]);&lt;/script&gt;&lt;template&gt;  &lt;input    type=&quot;text&quot;    :value=&quot;title&quot;    @input=&quot;$emit(&#x27;update:title&#x27;, $event.target.value)&quot;  /&gt;&lt;/template&gt;\n\n自定义 v-model 修饰符创建一个自定义修饰符 capitalize，自动将 v-model 绑定输入字符串的第一个字母转为大写：\n&lt;MyComponent v-model.capitalize=&quot;myText&quot; /&gt;\n\n&lt;script setup&gt;// modelModifiers prop 包含了 capitalize 且其值为 true// 因为它在模板中的 v-model 绑定 v-model.capitalize=&quot;myText&quot; 上被使用了const props = defineProps(&#123;    modelValue: String,    modelModifiers: &#123;        default: () =&gt; (&#123;&#125;) // 默认值为空对象    &#125;,&#125;);defineEmits([&#x27;update:modelValue&#x27;]);// 将首字母大写function emitValue(e) &#123;    let value = e.target.value;    if(props.modelModifiers.captialize) &#123;        value = value.charAt(0).toUpperCase() + value.slice(1);    &#125;    emit(&#x27;update:modelValue&#x27;, value);&#125;&lt;/script&gt;&lt;template&gt;    &lt;!-- 每次 &lt;input /&gt; 元素触发 input 事件时触发 emitValue --&gt;    &lt;input        type=&quot;text&quot;        :value=&quot;modelValue&quot;        @input=&quot;emitValue&quot;    /&gt;&lt;/template&gt;\n\n带多个不同参数的 v-model 修饰符&lt;UserName    v-model:first-name.capitalize=&quot;first&quot;    v-model:last-name.uppercase=&quot;last&quot;/&gt;\n\n&lt;script setup&gt;const props = defineProps(&#123;    firstName: String,    lastName: String,    firstNameModifiers: &#123;  // firstName + Modifiers        default: () =&gt; (&#123;&#125;)     &#125;,    lastNameModifiers: &#123;  // lastName + Modifiers        default: () =&gt; (&#123;&#125;)    &#125;,&#125;);defineEmits([&#x27;update:firstName&#x27;, &#x27;update:lastName&#x27;]);console.log(props.firstNameModifiers); // &#123; calitalize: true &#125;console.log(props.lastNameModifiers); // &#123; uppercase: true &#125;&lt;/script&gt;\n","categories":["vue3 - 文档"],"tags":["vue3","vue"]},{"title":"vue3 继承 attributes","url":"/2023/12/21/18-vue3%E7%BB%A7%E6%89%BFattributes/","content":"禁用 attributes 继承如果不想一个组件自动继承 attribute，可在组件选项中设置 inheritAttrs: false\n&lt;script setup&gt;defineOptions(&#123;    inheritAttrs: false&#125;);&lt;/script&gt;\n\n透传进来的 attribute 可在模版的表达式中用 $attrs 访问：\n&lt;span&gt;attribute: &#123;&#123; $attrs &#125;&#125;&lt;/span&gt;\n\n示例常见的需要禁用 attribute 继承的场景是：attribute 需要应用在根节点以外的其他元素。\n比如：希望透传的 attribute 应用在内层的节点而非外层。\n&lt;div class=&#x27;btn-wrapper&#x27;&gt;    &lt;button class=&#x27;btn&#x27; v-bind=&quot;$attrs&quot;&gt;click me&lt;/button&gt;&lt;/div&gt;&lt;script setup&gt;defineOptions(&#123;    inheritAttrs: false&#125;);&lt;/script&gt;\n\n多根节点的 attributes 继承需要显示绑定 $attrs，否则会有警告\n&lt;header&gt;...&lt;/header&gt;&lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main&gt;&lt;footer&gt;...&lt;/footer&gt;\n\n在 JS 中访问透传的 attributes使用 useAttrs() API 访问组件的所有透传 attribute\n&lt;script setup&gt;import &#123; useAttrs &#125; from &#x27;vue&#x27;;const attrs = useAttrs();&lt;/script&gt;\n\n但是这里的 attrs 对象不具有响应式，如有需要：\n（1）可使用 prop；\n（2）可使用 onUpdated() 在每次更新时获取最新的 attrs。\n","categories":["vue3 - 文档"],"tags":["vue3","vue"]},{"title":"vue 插槽","url":"/2023/12/26/19-vue%E6%8F%92%E6%A7%BD/","content":"基础插槽内容可以为文本、模版、组件\n&lt;!-- 父组件 --&gt;&lt;FancyButton&gt;  Click me! &lt;!-- 插槽内容 --&gt;&lt;/FancyButton&gt;\n\n&lt;!-- 子组件 --&gt;&lt;button class=&quot;fancy-btn&quot;&gt;  &lt;slot&gt;&lt;/slot&gt; &lt;!-- 插槽出口 --&gt;&lt;/button&gt;\n\n渲染结果：\n&lt;button class=&quot;fancy-btn&quot;&gt;Click me!&lt;/button&gt;\n\n默认内容子组件的 &lt;slot&gt;&lt;/slot&gt; 标签之间是默认值\n&lt;button type=&quot;submit&quot;&gt;  &lt;slot&gt;Submit&lt;/slot&gt; &lt;!-- 默认内容 --&gt;&lt;/button&gt;\n\n具名插槽当一个组件包含多个插槽出口时，需要使用 name 来给各个插槽分配唯一的 ID，没有提供 name 的插槽会隐式地命名为“default”。\n&lt;!-- 子组件 --&gt;&lt;div class=&quot;container&quot;&gt;  &lt;header&gt;    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;  &lt;/header&gt;  &lt;main&gt;    &lt;slot&gt;&lt;/slot&gt; &lt;!-- name 为 default --&gt;  &lt;/main&gt;  &lt;footer&gt;    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;  &lt;/footer&gt;&lt;/div&gt;\n\n在父组件中，使用 v-slot 或者 # 加上插槽名，来指定插槽内容。\n&lt;!-- 父组件 --&gt;&lt;BaseLayout&gt;  &lt;template v-slot:header&gt;    &lt;!-- header 插槽的内容 --&gt;  &lt;/template&gt;  &lt;template #footer&gt;    &lt;!-- footer 插槽的内容 --&gt;  &lt;/template&gt;&lt;/BaseLayout&gt;\n\n动态插槽名可定义动态插槽名：\n&lt;base-layout&gt;  &lt;template v-slot:[dynamicSlotName]&gt;  &lt;/template&gt;  &lt;!-- 缩写 --&gt;  &lt;template #[dynamicSlotName]&gt;    ...  &lt;/template&gt;&lt;/base-layout&gt;\n\n作用域插槽可以向插槽出口传递 attributes\n默认插槽&lt;!-- 子组件 --&gt;&lt;div&gt;    &lt;slot :text=&quot;message&quot; :count=&quot;1&quot;&gt;&lt;/slot&gt;&lt;/div&gt;\n\n&lt;!-- 父组件 --&gt;&lt;MyComponent v-slot=&quot;slotProps&quot;&gt;    &#123;&#123; slotProps.text &#125;&#125; &#123;&#123; slotProps.count &#125;&#125;&lt;/MyComponent&gt;&lt;!-- 或者 --&gt;&lt;MyComponent v-slot=&quot;&#123; text, count &#125;&quot;&gt;    &#123;&#123; text &#125;&#125; &#123;&#123; count &#125;&#125;&lt;/MyComponent&gt;\n\n具名插槽&lt;!-- 父组件 --&gt;&lt;MyComponent&gt;  &lt;template #header=&quot;headerProps&quot;&gt;    &#123;&#123; headerProps &#125;&#125;  &lt;/template&gt;  &lt;!-- 不缩写 --&gt;  &lt;template v-slot:default=&quot;defaultProps&quot;&gt;    &#123;&#123; defaultProps &#125;&#125;  &lt;/template&gt;  &lt;template #footer=&quot;footerProps&quot;&gt;    &#123;&#123; footerProps &#125;&#125;  &lt;/template&gt;&lt;/MyComponent&gt;\n\n&lt;!-- 子组件 --&gt;&lt;slot name=&quot;header&quot; :msg1=&quot;hello1&quot;&gt;&lt;/slot&gt;&lt;slot :msg2=&quot;hello2&quot;&gt;&lt;/slot&gt; &lt;!-- name 为 default --&gt;&lt;slot name=&quot;header&quot; :msg3=&quot;hello3&quot;&gt;&lt;/slot&gt;\n","categories":["vue - 文档"],"tags":["vue"]},{"title":"vue3 依赖注入","url":"/2023/12/28/20-vue3%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/","content":"props 逐级透传深层子组件需要较远的祖先组件中的部分数据，使用 props 逐级传递很麻烦：\n\n\n\nprovide（提供）为组件后代提供数据，使用 provide() 函数：\n&lt;script setup&gt;import &#123; provide &#125; from &#x27;vue&#x27;;provide(/* 注入名 */&#x27;message&#x27;, /* 注入值 */&#x27;value&#x27;);&lt;/script&gt;\n\n","categories":["vue3 - 文档"],"tags":["vue3","vue"]},{"title":"浏览器输入url后发生了什么","url":"/2024/10/10/21-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/","content":"1. URL解析用户输入的URL（例如 https://www.example.com/index.html）首先被浏览器解析，该过程包括：\n\n提取协议（如HTTP或HTTPS）\n主机名（如www.example.com） \n端口\n路径（如&#x2F;index.html）\n查询参数\n锚点\n\n详见：\n\n浏览器解析url过程\n\n2. DNS 查询浏览器需要将域名转换为IP地址，以便进行网络通信。此时，浏览器会查找本地DNS缓存，如果没有找到，就会向系统的DNS服务器发送请求。DNS服务器将返回对应的IP地址。\n详见：\n\nDNS\nCDN\n\n3. TCP连接一旦获得了IP地址，浏览器通过TCP（传输控制协议）建立与目标服务器的连接。对于HTTPS请求，还需要进行SSL&#x2F;TLS握手，以确保安全性。这一过程包括：\n\n客户端向服务器发送连接请求\n服务器确认并建立连接\n进行SSL&#x2F;TLS证书验证以及协商加密算法\n\n4. 发送HTTP请求连接建立后，浏览器构建一个HTTP请求并发送到服务器。这个请求包含：\n\n请求行（例如 GET &#x2F;index.html HTTP&#x2F;1.1）\n请求头（例如用户代理、接受类型等信息）\n请求体（对于POST请求，可能包含数据）\n\n5. 服务器处理请求服务器接收到请求后，会根据请求的内容进行处理。它可能会查找文件、访问数据库或者执行其他逻辑，最终生成一个HTTP响应。\n6. 接收HTTP响应服务器发送回HTTP响应，包含状态码（如200表示成功，404表示未找到），响应头（如内容类型、内容长度等）和响应体（实际请求资源的内容，如HTML文档）。\n7. 渲染页面浏览器接收响应后，进行以下步骤：\n\n解析HTML文档，构建DOM树\n如果遇到CSS文件，发起请求以获取样式，并构建CSSOM树\n合并DOM和CSSOM，生成渲染树\n根据渲染树计算布局，决定每个元素的位置和大小\n绘制页面，将内容绘制到屏幕上\n\n8. 处理JavaScript如果HTML中包含JavaScript代码，浏览器会逐步执行这些脚本。JavaScript可以操作DOM，改变页面内容，进行AJAX请求等。\n9. 其它资源加载如果页面中包含其他资源（如图片、音频、视频），浏览器会并行请求这些资源，直至全部加载完成。\n案例说明假设用户在浏览器中输入https://www.example.com/index.html，整个过程如下： \n\n浏览器解析出协议为HTTPS，域名为www.example.com。 \n发送DNS请求，获得IP地址93.184.216.34。\n与该IP地址建立TCP连接，并进行TLS握手。\n发送GET请求，请求&#x2F;index.html资源。\n服务器处理请求，返回200状态及index.html内容。\n浏览器解析HTML，构建DOM树，并抓取相关的CSS和JavaScript文件。\n最终呈现完整的网页给用户。\n\n","categories":["计算机网络 - 综合"],"tags":["面经","计算机网络","url"]},{"title":"浏览器解析url过程","url":"/2024/10/14/22-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90url%E8%BF%87%E7%A8%8B/","content":"1. URL的格式协议表示浏览器应当使用的访问方法，包括：”http：””ftp：””file：””mailto：”。比如访问Web服务器使用HTTP协议，访问本地服务器使用FILE协议，访问FTP服务器使用FTP协议。\n图1 列举了常见的几种URL，访问自标不同，URL的写法也不同。例如在访问Web服务器和FTP服务器时，URL中包含服务器的域名和要访问的文件的路径名等，而发邮件的URL则包含收件人的邮件地址。此外，URL还可能包含用户名、密码、服务器端口号等信息。\n图1.1：URL的各种格式\n2. URL的组成元素图1.2：Web浏览器解析url的过程\n图1.3：路径名为&#x2F;dir&#x2F;file1.html的文件\n3. 省略文件名的情况(a) 以”&#x2F;“结尾：lab.glasscom.com/dir/以”&#x2F;dir&#x2F;“结尾代表&#x2F;dir&#x2F;后面本应该有的文件名被省略了。我们会在服务器上事先设置好文件名省略时要访问的默认文件名，大多情况下是index.html或者default.htm。因此，像前面这样省略文件名时，服务器就会访问其中的默认文件。\n(b) 域名+”&#x2F;“：lab.glasscom.com/以”域名+&#x2F;“结尾表示访问一个名叫”&#x2F;“的目录（根目录）；由于省略了文件名，会访问&#x2F;index.html之类的文件。\n(c) 域名：lab.glasscom.com以域名结尾时，就代表访问根目录下事先设置的默认文件，也就是&#x2F;index.html之类的文件。\n(d) 路径结尾无”&#x2F;“：lab.glasscom.com/whatisthis先文件，后目录。如果Web服务器上存在名为whatisthis的文件，则将whatisthis作为文件名来处理；如果存在名为whatisthis的目录，则将whatisthis作为目录名来处理。\n备注\nURL：Uniform Resource Locator，统一资源定位符。\nFTP：File Transfer Protocol，文件传送协议。是在上传、下载文件时使用的协议（也指使用FTP协议传送文件的程序）。\nHTTP：Hypertext Transfer Protocol，超文本传送协议。\n根目录：”&#x2F;“目录 表示最顶层的目录 “根目录”。\n\n","categories":["计算机网络 - url"],"tags":["面经","计算机网络","url"]},{"title":"投放链接防重定向","url":"/2024/10/14/23-%E6%8A%95%E6%94%BE%E9%93%BE%E6%8E%A5%E9%98%B2%E9%87%8D%E5%AE%9A%E5%90%91/","content":"为了防止浏览器进行多次重定向，影响页面性能，投放链接应该以 https 开头，以 ‘&#x2F;‘ 结尾不用：http://lc.jr.jd.com/finance/fund/fundinvest/investZone使用：https://lc.jr.jd.com/finance/fund/fundinvest/investZone/\n不正确投放链接访问http://lc.jr.jd.com/finance/fund/fundinvest/investZone的请求过程：\n一、有缓存1. 协议变为 https浏览器把协议从http替换为https（使用307重定向，保证不改变请求方法GET）\n\n2. 本地缓存获取IP浏览器在本地缓存中获取到IP（远端地址）；重定向到补充末尾”&#x2F;“的规范URL\n\n返回304响应码，该GET请求的request header中包含（与缓存相关的）条件参数\n使用path相对路径进行重定向，因为nginx在server中设置了absolute_redirect off\n\n\n请求头中的条件参数（If-xxx）：\n3. 请求资源浏览器使用上述请求从本地缓存中获取的IP，向远端服务器GET资源，并成功\n二、无缓存无缓存时，第2步变为使用301重定向\n\n正确投放链接访问https://lc.jr.jd.com/finance/fund/fundinvest/investZone/的请求过程：\n一、有缓存服务器返回304响应码，表示可以使用客户端中之前缓存的副本\n\n该请求的request header中包含「与缓存相关」的条件参数\n\n\n二、无缓存普通请求，响应码为200\n","categories":["计算机网络 - url"],"tags":["面经","计算机网络","url","实践问题"]},{"title":"浏览器缓存与304状态码","url":"/2024/10/16/24-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E4%B8%8E304%E7%8A%B6%E6%80%81%E7%A0%81/","content":"总结出现304状态码的条件\n\n不禁止缓存\n不检查本地缓存是否过期；或者检查本地缓存、且未过期\n响应头有Etag（则下次的请求头中有If-None-Match）；或者响应头有Last-Modified（则下次的请求头中有If-Modified-since）\n缓存有效\n\n注意：下图中的Etag和Last-Modified之间不存在先后顺序\n\n一、304请求的交互过程假设用户通过浏览器访问某静态资源（比如图片image.png），且该资源之前已被浏览器缓存，现在分析两次请求的交互过程。\n第一次请求（初始加载）1、浏览器发送请求用户在浏览器中输入 URL，浏览器向服务器发送 GET 请求，获取 image.png。请求头可能如下：\nGET /image.png HTTP/1.1Host: example.comUser-Agent: Mozilla/5.0 ...Accept: image/webp,image/apng,image/*,*/*;q=0.8\n\n2、服务器响应服务器处理请求，并返回 200 OK 响应，同时附带以下响应头：\nHTTP/1.1 200 OKContent-Type: image/pngContent-Length: 123456Last-Modified: Mon, 01 Jan 2023 12:00:00 GMTETag: &quot;abc123&quot;Cache-Control: max-age=31536000\n\n\nLast-Modified：表示资源最后修改的时间\nETag：资源的唯一标识符\nCache-Control：指示浏览器可以缓存该资源的时长\n\n3、浏览器缓存资源浏览器接收响应后，将image.png缓存到本地，并根据响应头信息（如Last-Modified和ETag）记录该资源的状态\n第二次请求（缓存验证）1、浏览器发送条件请求当用户再次访问同一资源，浏览器会检查缓存，如果该资源仍然有效，就发送一个带条件的 GET 请求到服务器，请求头如下：\nGET /image.png HTTP/1.1Host: example.comIf-Modified-Since: Mon, 01 Jan 2023 12:00:00 GMTIf-None-Match: &quot;abc123&quot;User-Agent: Mozilla/5.0 ...\n\n\nIf-Modified-Since：告诉服务器，如果在指定日期之后资源被修改，则返回新的资源\nIf-None-Match：告诉服务器，如果资源的ETag与提供的值不匹配，则返回新的资源\n\n2、服务器处理请求服务器接收到条件请求后，检查该资源的状态：如果资源自Last-Modified时间以来未被修改，且ETag匹配，那么服务器不会返回新的内容，而是返回 304 Not Modified。\n服务器返回如下响应：\nHTTP/1.1 304 Not ModifiedDate: Mon, 02 Jan 2023 12:00:00 GMT\n\n注意：304 响应没有消息体，通常只包含必要的状态码和一些响应头。\n3、浏览器处理304响应当浏览器接收到 304 Not Modified 响应时，了解到之前缓存的 image.png 仍然有效，因此直接使用缓存中的版本，而无需重新下载。\n二、详细讨论1、是否禁止缓存禁止缓存：缓存中不得存储任何关于客户端请求和服务端响应的内容，客户端每次发起的请求都会下载完整的响应内容\n在请求头中，Cache-Control: no-store 与 Pragma: no-cache 都可以禁止缓存\n\nPragma: no-cache 可用于 http 1.0 和 http 1.1\nCache-Control: no-store 只能用于 http 1.1\n\n2、是否检查本地副本是否过期由 Cache-Control 的 no-cache 和 must-revalidate 两个可选值控制\n\nno-cache：告诉浏览器、缓存服务器，不管本地副本是否过期，使用资源副本前，必须到源服务器进行副本有效性校验\nmust-revalidate：告诉浏览器、缓存服务器，本地副本过期前，可使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验（如果没有该属性，若发生网络问题等情况，客户端可能直接使用本地缓存，而不会向服务器发起校验）\n\n3、检查本地副本是否过期与「缓存的过期机制」相关的响应头字段（优先级依次降低）：\n（1）max-age=&lt;seconds&gt;表示资源能被缓存的最大时间，通常和 must-revalidate 一起使用。\n本地副本过期前，可使用本地副本，缓存时间为60秒；如果本地副本已过期，则重新向服务器请求（要求必须进行有效性校验）：\nCache-Control: max-age=60, must-revalidate\n\n共享缓存（如代理服务器）将在60秒后失效，而个人用户的缓存则在120秒后失效：\nCache-Control: max-age=120, smax-age=60\n\n（2）Expires表示资源的过期时间。如果无max-age但有Expires，通过比较Expires和Date的值来判断是否缓存有效：\n\n（3）Last-Modified表示资源的最后修改时间。如果无max-age和expires但有Last-Modified，缓存的时长等于\n(Date - Last-Modified) / 10\n\n\n如果都没有，浏览器将不会对该需求进行缓存。\n4、本地副本没过期直接从缓存中读取资源，并返回200状态码。\n\n5、本地副本已过期进行「源服务器进行有效性校验」的前期准备：\n（1）If-None-Match首先，在请求头里寻找If-None-Match字段（其值为服务器上次返回的ETag响应头的值）\n\n（2）If-Modified-Since如果没有If-None-Match，则在请求头中寻找If-Modified-Since字段（其值为服务器上次返回的Last-Modified响应头中的日期值）\n\n如果If-None-Match与If-Modified-Since都没有，则直接向服务器请求数据\n6、去源服务器进行有效性校验如果请求头中有If-None-Match或If-Modified-Since，则到源服务器进行有效性校验。如果源服务器资源没有变化，则返回304；如果有变化，则返回200。\n7、上述流程的总结图\n三、意义\n避免了不必要的数据传输，提高了网络效率和用户体验；\n在频繁访问相同资源的情况下，可以显著降低带宽消耗和服务器负载。\n\n四、补充私有缓存和公共缓存在Cache-Control还有两个值：private与public：\n\npublic 表示该响应可被任何中间人（比如中间代理、CDN等）缓存。\nprivate 表示该响应是专用于某单个用户的，不能被中间人缓存，应该用于浏览器的私有缓存中，比如：带有HTTP验证信息（帐号密码）的页面 或 某些特定影响状态码的页面*。\n\n“某些特定影响状态码的页面”指具有特殊语义的状态码，比如：\n（1）401 Unauthorized当访问受保护的资源时，如果用户未通过身份验证，服务器可能返回401状态码。此时通常只应允许客户端缓存该响应，因为该内容对其他用户是不适用的。\n（2）403 Forbidden表示服务器理解请求但拒绝执行它。在某些情况下，公共内容也可能出于安全考虑而不被中间缓存，因此可标记为 private。\n（2）404 Not Found如果某资源不存在，虽然它是公开的，但可能在某些应用场景下不希望被中间缓存。\n（3）500 Internal Server Error表示服务器出现了问题，返回的内容可能不稳定，因此不应被中间缓存。\nprivate 使用场景（1）用户特定数据如个性化推荐、用户历史记录等，仅对特定用户合适，其他用户无法访问，即便返回成功状态，为了保护用户隐私，建议使用 private。\n（2）临时性数据如操作结果、表单提交后给予反馈的信息等，这类信息通常只需当前用户知道，对其他用户无意义，适合标记为 private。\n","categories":["计算机网络 - 状态码","计算机网络 - 浏览器"],"tags":["面经","计算机网络","url","状态码","浏览器"]},{"title":"DNS","url":"/2024/10/18/25-DNS/","content":"一、定义DNS 是：\n\n一个使得主机能够查询分布式数据库的应用层协议\n一个由分层的 DNS 服务器实现的分布式数据库\n\n（1）DNS 是一个分布式数据库，整个 DNS 系统由分散在世界各地的很多 DNS 服务器组成，每台服务器上都保存了一些数据，可以让我们最终查到主机名对应的 IP。\n（2）DNS 是一个应用层协议，发送一个包含所查询主机名的请求，它会返回该主机名对应的 IP。\n分布式： 世界上没有一台 DNS 服务器拥有因特网上所有主机的映射，每台 DNS 只负责部分映射。\n二、层次DNS 服务器有 3 种类型：\n\n根 DNS 服务器\n顶级域（Top-Level Domain, TLD）\nDNS 服务器\n权威 DNS 服务器\n\n\n1、根 DNS 服务器比如 www.baidu.com，其完整写法是 www.baidu.com.，最后的这个 . 就是根域名。\n通过询问根 DNS 服务器，可以知道它的下一级，也就是顶级域 DNS 服务器的 IP 是多少，从而继续向顶级域 DNS 服务器发起查询请求。\n2、顶级域 DNS 服务器除了前面提到的 com 是顶级域名，常见的顶级域名还有 cn、org、edu 等。顶级域 DNS 服务器，也就是 TLD，提供了它的下一级，也就是权威 DNS 服务器的 IP 地址。\n3、权威 DNS 服务器权威 DNS 服务器可以返回主机和IP之间的最终映射。\n三、本地 DNS 服务器每个 ISP（Internet Server Provider, 网络服务提供商）都有一台本地 DNS 服务器，比如一个居民区的 ISP、一个大学的 ISP、一个机构的 ISP，都有一台或多台本地 DNS 服务器。\n当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，本地 DNS 服务器起着代理的作用，并负责将该请求转发到 DNS 服务器层次结构中。\n严格来说，本地 DNS 服务器不属于 DNS 的层次结构。\n四、递归查询、迭代查询如下图，假设主机 m.n.com 想要获取主机 a.b.com 的 IP 地址，会经过以下几个步骤：\n\n（1）首先，主机 m.n.com 向它的本地 DNS 服务器发送一个 DNS 查询报文，包含期待被转换的主机名 a.b.com；\n（2）本地 DNS 服务器将该报文转发到根 DNS 服务器；\n（3）该根 DNS 服务器注意到 com 前缀，向本地 DNS 服务器返回 com 对应的顶级域 DNS 服务器（TLD）的 IP 地址列表。\n（4）本地 DNS 服务器则向其中一台 TLD 服务器发送查询报文；\n（5）该 TLD 服务器注意到 b.com 前缀，向本地 DNS 服务器返回权威 DNS 服务器的 IP 地址。\n（6）本地 DNS 服务器又向其中一台权威服务器发送查询报文；\n（7）该权威服务器返回了 a.b.com 的 IP 地址；\n（8）本地 DNS 服务器将 a.b.com 跟 IP 地址的映射返回给主机 m.n.com，m.n.com 就可以用该 IP 向 a.b.com 发送请求了。\n1、递归主机 m.n.com 向本地 DNS 服务器 dns.n.com 发出的查询就是递归查询，这个查询是主机 m.n.com 以自己的名义向本地 DNS 服务器请求想要的 IP 映射，并且本地 DNS 服务器直接返回映射结果给到主机。\n2、迭代而后继的三个查询是迭代查询，包括本地 DNS 服务器向根 DNS 服务器发送查询请求、本地 DNS 服务器向 TLD 服务器发送查询请求、本地 DNS 服务器向权威 DNS 服务器发送查询请求，所有的请求都是由本地 DNS 服务器发出，所有的响应都是直接返回给本地 DNS 服务器。\n3、另一种 DNS 查询从理论上讲，任何 DNS 查询既可以是递归的，也可以是迭代的。下图的所有查询就都是递归的，不包含迭代。\n\nTLD 一定知道权威 DNS 服务器的 IP 地址吗？不一定，有时 TLD 只是知道中间的某个 DNS 服务器，再由这个中间 DNS 服务器去找到权威 DNS 服务器。\n这种情况不仅增加了延迟，还使得网络上需要传输更多的数据包，也会产生更多的 DNS 报文。\n五、DNS 优化1、DNS 缓存DNS 存在多级缓存，从离浏览器的距离排序，有以下几种：浏览器缓存，系统缓存，路由器缓存，IPS 服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。\n\n在chrome浏览器中输入 chrome://net-internals/#dns，可以看到chrome浏览器的DNS缓存\n系统缓存主要存在 /etc/hosts （Linux系统）中\n\n缓存并不是永久的，每一条映射记录都有对应的生存时间，一旦过了生存时间，该条记录就会从缓存移出。\n2、DNS 负载均衡访问某网站的时候，每次响应的很可能不是同一个服务器（IP 地址不同），因为一般公司都有多台服务器来支撑访问，而 DNS 会返回一个合适的机器的 IP 给用户（根据每台机器的负载量、该机器和用户地理位置的距离等），这就是 DNS 负载均衡。\n","categories":["计算机网络 - DNS"],"tags":["面经","计算机网络","DNS"]},{"title":"CDN","url":"/2024/10/29/26-CDN/","content":"一、概念CDN 全称为 “Content Delivery Network”，即内容分发网络。CDN 是一种特殊的 DNS服务器。\n二、原理当使用域名访问某一个网站时（比如访问 www.baidu.com），分为两步：\n\n首先解析出该域名所对应的 IP地址（DNS 域名解析）\n然后将 Http请求包 路由到 IP地址 所对应的服务器\n\n（注：IP地址和网卡相绑定，一个服务器可以有多个网卡，即可能有多个IP地址）\n1、域名解析域名解析分为两种：\n\n将域名解析为IP地址\n将域名解析为另一个域名（CNAME）\n\n购买一个域名之后，需要去映射一个 IP地址，用 Map 表示：{域名：IP}。也可以给某域名取一个别名，比如给 www.baidu.com 取一个别名 test.baidu.com，用 Map 表示：{域名：CNAME}，这里的CNAME就是别名。\n域名解析，实际上就是解析出指定域名所对应的 IP地址，或该域名的一个 CNAME。\n没有CNAME的情况：\n有CNAME的情况：\n特别注意：在有 CNAME 的情况下，CNAME 在域名解析的过程中承担了代理的角色，这是 CDN 实现的关键。\n2、资源分类服务器上的资源分为两种：\n\n静态资源：这种资源通常很少变动，比如图片，视频，css，js 等等\n动态资源：这种资源不同用户不同时刻访问通常是不一样的，比如 ftl，jsp 等等。\n\n（1）集群（动态资源）在全国各地部署服务器，每个服务器上都有相同的动态资源，并且还需配置相应的数据库，这就涉及到数据同步等问题。这种做法专业一点就是集群，目前集群架构最多是三地五中心，因为全国多地集群成本太高。\n（2）CDN服务器（静态资源）在每个服务器上只部署静态资源是成本较低的方式，因为静态资源通常不涉及数据库，也能提高用户访问速度。\n现在有很多 CDN供应商，只要把系统接入并将静态资源传给 CDN服务，这些静态资源将会自动分布到世界各地。\n在访问静态资源时，DNS系统 进行域名解析的过程中，如何解析出离用户最近的 IP地址？这就需要使用 CDN服务器，该服务器知道用户当前所在位置，和用户访问的域名对应哪些 IP地址，及这些 IP地址 分别在哪。\n这样，只要用户在通过某域名访问静态资源时，配置自己电脑的 DNS地址 为 CDN专用DNS服务器，就可以解决问题了，但不能要求所有用户都去修改自己电脑的 DNS地址，这时就要利用 DNS 中的 CNAME 了。\n3、负载均衡和缓存（1）负载均衡系统如果没有返回 IP地址，本地DNS服务器 会向对应的 CDN服务器 再次发送请求，通过 CDN负载均衡系统 进行智能调度：\n\n看用户的 IP 地址，查表得知地理位置，找相对最近的边缘节点\n看用户所在的运营商网络，找相同网络的边缘节点\n检查边缘节点的负载情况，找负载较轻的节点\n其他，比如节点的“健康状况”、服务能力、带宽、响应时间等\n\n结合以上因素，得到最合适的边缘节点，并把该节点返回给用户，用户就能就近访问 CDN 的缓存代理。\n整体流程如下：\n\n（2）缓存代理缓存系统是 CDN 的另一个关键组成部分，缓存系统会缓存最常用的资源，有两个衡量 CDN服务质量 的指标：\n\n命中率：用户访问的资源恰好在缓存系统里，可直接返回给用户，命中次数与所有访问次数之比\n回源率：缓存里没有，必须用代理的方式回源站取，回源次数与所有访问次数之比\n\n缓存系统可以划分层次为：一级缓存节点和二级缓存节点，一级缓存直连源站，二级缓存直连用户。在回源时，二级缓存首先找一级缓存，一级缓存没有才回源站，可有效减少真正的回源。\n\n现在的商业 CDN命中率都在 90% 以上，相当于把源站的服务能力放大了 10 倍以上\n补充域名解析有多种记录类型，最常用的有：\n\nA记录：一个域名对应一个IP地址\nCNAME：一个域名对应另外一个域名\nNS：将子域名指定其他DNS服务器解析\n\n","categories":["计算机网络 - CDN"],"tags":["面经","计算机网络","CDN"]},{"title":"interface & type","url":"/2024/11/05/28-interface&type/","content":"一、相同点1、都可以描述对象和函数的类型但语法不一样，type 使用 &#x3D; 赋值\ninterface User &#123;    name: string    age: number&#125;interface SetUser &#123;    (name: string, age: number): void&#125;\n\ntype User = &#123;    name: string    age: number&#125;type SetUser = (name: string, age: number) =&gt; void\n\n2、都允许扩展（extends）并且 interface 和 type 可以互相扩展\n（1）interface 扩展 interfaceinterface Name &#123;    name: string&#125;interface User extends Name &#123;    age: number&#125;\n\n（2）type 扩展 typetype Name = &#123;    name: string&#125;type User = Name &amp; &#123;    age: number&#125;\n\n（3）interface 扩展 typetype Name = &#123;    name: string&#125;interface User extends Name &#123;    age: number&#125;\n\n（4）type 扩展 interfaceinterface Name &#123;    name: string&#125;type User = Name &amp; &#123;    age: number&#125;\n\n二、不同点1、type 可以，但 interface 不行（1）基本类型别名type Name = string\n\n（2）联合类型interface Dog &#123;    dogName: string&#125;interface Cat &#123;    catName: string&#125;type Pet = Dog | Cattype StringOrNumber = string | numbertype Text = string | &#123; text: string &#125;\n\n（3）元组具体定义数组每个位置的类型\ntype PetList = [Dog, List]\n\n（4）使用 typeof 获取实例的类型 对 type 进行赋值let divEle = document.createElement(&#x27;div&#x27;)type Div = typeof divEle\n\n2、interface 可以，但 type 不行interface 能够声明合并interface User &#123;    name: string&#125;interface User &#123;    age: number&#125;/** * User 接口为 &#123; *     name: string *     age: number * &#125; */\n\n三、总结优先用 interface，无法实现再用 type，因为 interface 具有更直观和易于理解的特点，并且能够进行声明合并。\n"},{"title":"三次握手&四次挥手","url":"/2024/11/04/27-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B&%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/","content":"三次握手一、概念1、TCP 协议TCP（Transmission Control Protocol），即传输控制协议。TCP 协议是一个 面向连接的、可靠的、基于字节流 的 传输层协议。\nTCP 连接可以用于 保证可靠性 和 流量控制机制，包括 Socket、序列号及窗口大小。\n其中 Socket 是由 IP 加端口组成的，序列号是用来解决乱序问题的，而窗口大小则是用来做流量控制的。\n2、TCP 的特点\n面向连接：TCP 是通过服务端和客户端进行连接的协议。\n面向字节流：TCP 服务端和客户端之间的数据通讯是通过 字节流数据 传输的。\n可靠的：TCP 传输的可靠性得益于 TCP 会记录 信息的发送状态 和 数据的接收与否，对于丢包等发送不成功的情况，TCP 会重新发包，进而保证 TCP 的可靠性。\n\n3、TCP 三次握手\n\nSYN：Synchronize Sequence Numbers，同步序列号，表示发起一个新连接。\nACK：确认收到一个新连接。\nSEQ：序列号。\n\nTCP 三次握手执行过程：\n（1）第一次握手（在吗？）Client 将 SYN 发给 Server。Client 进入 SYN_SENT 状态，等待 Server 确认。\n（2）第二次握手（在的，有事？）Server 收到 SYN，将 SYN+ACK 发给 Client。Server 进入 SYN_RCVD 状态，等待 Client 确认。\n（3）第三次握手（需要数据传输）Client 收到 SYN+ACK，将 SYN 发给 Server。连接成功，Client 与 Server 进入 ESTABLISHED 状态，可以传输数据。\nTCP 为什么需要三次握手？为了防止已失效的请求报文段传送到服务端而产生连接的误判。\n假设是两次握手：\n当 A 发送一个连接请求给 B，但是该请求由于网络原因被阻塞了，一段时间后，A 未收到回复，会认为该消息丢失了，就会重新发送消息。\n当 A 和 B 通信完成后，这个被 A 认为已经丢失的请求到达了 B，B 会认为这是一个新的请求连接消息，就向 A 发送确认。\n但是 A 认为自己没有给 B 再次发送消息，所以不会理睬 B 的确认，但是 B 会一直等待 A 的消息，导致 B 的资源被浪费。\n这就是为什么不能两次握手。\n设计成三次握手的情况，客户端在接收到服务端 SEQ+1 的返回消息后，就会知道该连接是历史连接，接着发送报文告诉服务端。\n为了节省资源，也没必要设计成更多次的握手。\n四次挥手\n四次挥手的 6 种状态（1）FIN_WAIT_1主动方在 ESTABLISHED 状态的时候，想要主动关闭连接，向对方发送 FIN 报文，并进入 FIN_WAIT_1 状态。\n（2）FIN_WAIT_2当主动方收到被动方回复的 ACK 报文后，就进入了 FIN_WAIT_2 状态。\n当主动方进入 FIN_WAIT_2 时，表示半连接状态，即被动方还有数据要发过来。\n（3）CLOSE_WAIT当被动方接收到 FIN 时，会回复一个 ACK，并进入 CLOSE_WAIT 状态。\n在该状态中，被动方如果还有数据要发送，就继续发送，如果没有，就关闭连接，并发送一个 FIN 给对方。\n（4）TIME_WAIT当主动方接收到了 FIN 报文，就回复一个 ACK 报文，并进入 TIME_WAIT 状态。\n如果主动方在 FIN_WAIT_1 状态下，收到了对方的 FIN+ACK 报文，可以跳过 FIN_WAIT_2 直接进入 TIME_WAIT 状态。\n（5）LAST_ACK被动方发送了 FIN 报文后，最后等待对方的 ACK 报文时进入的状态。收到ACK报文后就可以进入CLOSED状态了。\n（6）CLOSED主动方进入 TIME_WAIT 状态后，再等待 2MSL 就会进入 CLOSED 状态。被动方在收到 ACK 报文后，立即进入 CLOSED 状态。\nTIME_WAIT 的意义如果没有 TIME-WAIT，主动方会直接进入 CLOSED 状态。此时如果因为网络原因最后一次 ACK 丢失了，服务端会重复发送 FIN 请求给客户端，所以就需要主动方发送最后一次 ACK 之后进入 TIME_WAIT 状态，等待 2MSL（两个报文最大生命周期），等待这段时间就是为了如果接收到了重发的 FIN 请求能够进行最后一次 ACK 回复。\n","categories":["计算机网络 - TCP"],"tags":["面经","计算机网络","TCP"]},{"title":"TCP","url":"/2024/11/05/29-TCP/","content":"\n一、TCP 和 UDP 的区别TCP 和 UDP 都是传输层协议，不同点在于：\n\nTCP 是 面向连接的、可靠的、面向字节流 的\nUDP 是 面向无连接 的\n\nTCP 的三大核心特性\n1、面向连接在客户端和服务器互相通信之前，TCP 需要三次握手建立连接，而 UDP 不需要\n2、可靠性TCP 的可靠性体现在有状态、可控制。\n（1）有状态TCP 会记录发送的数据，以及其中被接收和未被接收的数据，并保证数据包按序到达\n（2）可控制当意识到丢包或网络不佳，TCP 会根据情况调整自身行为，控制发送速度或者重发\n3、面向字节流UDP 的数据传输是基于数据报的，这仅仅继承了 IP 层的特性；而 TCP 为了维护状态，将 IP 包变成了字节流\n二、TCP 三次握手过程 &amp; 为什么是三次1、流程发送与接收方需要确认双方的两种能力：发送和接收，于是会有三次握手的过程:\n\n（1）服务器变为 LISTEN起初双方都处于 CLOSED 状态。服务端开始监听某个端口，进入 LISTEN 状态（2）客户端变为 SYN-SENT客户端主动发起连接，发送 SYN，并进入 SYN-SENT 状态其中 seq&#x3D;x，表示客户端告诉服务端，我发送的首个数据包 序列号从 x 开始\n（3）服务端变为 SYN-REVD服务端接收到，返回 SYN 和 ACK（对应客户端发来的 SYN），并进入 SYN-REVD 状态其中 seq&#x3D;y，ack&#x3D;x+1，seq&#x3D;y 表示服务端的初始序列号是 y ，ack&#x3D;x+1 表示服务端告诉客户端：已收到从序列号 x 开始的数据包，期望下次发送从序列号 x+1 开始的数据包\n（4）客户端变为 ESTABLISHED客户端再发送 ACK 给服务端，并进入 ESTABLISHED 状态其中 seq&#x3D;x+1 ，ack&#x3D;y+1 。seq&#x3D;x+1 表示客户端按照服务端的期望，从序列号 x+1 开始发送数据包，ack&#x3D;y+1 表示客户端告诉服务端：已收到从序列号 y 开始的数据包，期望下次发送从序列号 y+1 开始的数据包\n服务端收到 ACK 之后，也进入 ESTABLISHED 状态注意：凡是需要对端确认的，一定会消耗 TCP 报文的序列号。SYN 需要对端的确认，而 ACK 不需要，因此 SYN 消耗一个序列号，下次发送对应的 ACK 序列号要加 1，而 ACK 不需要。\n2、为什么不是两次握手根本原因：没有第三次握手，服务端无法确认客户端的接收能力\n如果是两次，客户端发送 SYN 报文试图和服务端建立连接，但是这个包发生了滞留；一段时间后，客户端未收到服务端响应，以为丢了包，于是重传，两次握手建立好了连接。\n但是在连接关闭后，如果滞留的包到达了服务端，这时由于是两次握手，服务端只要接收到、并给客户端发送了相应的数据包，就默认建立连接，但是此时客户端已经断开，这就带来了资源的浪费。\n3、三次握手过程中可以携带数据么第三次握手可以携带数据，前两次握手不能携带\n如果前两次握手能够携带数据，一旦有人想攻击服务器，只需要在第一次握手中的 SYN 报文中放大量数据，服务器势必会消耗更多的时间和内存空间去进行处理，增大了服务器被攻击的风险\n第三次握手时，客户端已处于 ESTABLISHED 状态，并且能够确认服务器的接收、发送能力正常，这时相对安全，可以携带数据\n三、TCP 四次挥手的过程","categories":["计算机网络 - TCP"],"tags":["面经","计算机网络","TCP"]},{"title":"北大-区块链技术与应用1-简介","url":"/2025/01/02/30-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-%E7%AE%80%E4%BB%8B/","content":"本课程主要讲：比特币和以太坊 两种加密货币\n视频链接：\nhttps://www.bilibili.com/video/BV1Vt411X7JF/?spm_id_from=333.337.search-card.all.click&amp;vd_source=69ac93649ea21c4726fe85f272b6d968 \n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3"]},{"title":"北大-区块链技术与应用2-密码学基础","url":"/2025/01/02/31-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/","content":"Crypto-currency（加密货币）\n区块链和比特币主要用到：哈希函数 和 数字签名\n一、Cryptographic Hash Function（哈希函数）区块链用到了哈希函数的 抗碰撞性 和 隐私性；比特币除了这两个性质，还要求 谜题友好性\n（1）Collision resistance（抗碰撞） x≠y, H(x)≠H(y) 给定一个x，没有高效的方法找到一个y，满足H(x)&#x3D;H(y)，可以用 brute-force（蛮力破解）\n Message digest（信息摘要）：给定一个消息m，用H(m)检测对消息的篡改 对m’≠m，H(m’)≠H(m)\n MD5已经可以被人为地制造碰撞\n（2）Hiding（隐私性）&#x2F; Not invertable（单向不可逆） x –&gt; H(x)，没有高效的方法从H(x)得到x，除了 brute-force\n（3）Puzzle friendly（谜题友好） 不知道如何选定x，使H(x)落在某个区间内，Exp. 00…0XXX…X（以k个0开始）\n 挖矿过程：找一个nonce，和区块块头中的其他信息和在一起作为输入，哈希过后的值要小于等于目标域值，即H(block header) ≤target 其谜题友好意味着，挖矿的过程不存在捷径，只能靠 brute-force，所以该过程才能作为 power of work（pow，工作量证明） 设置 mining puzzle 的原则：Difficult to solve, but easy to verify\nExample 1比特币中用到的哈希函数是 SHA-256（Secure Hash Algorithm），满足以上三个性质\nExample 2Digital commitment（数字承诺），又名 Digital Equivalent of a Sealed Envelope（密封信封的数字等价物），允许一方将某个值（秘密或消息）“承诺”给另一方（验证者）\n结合了哈希函数的抗碰撞和隐私性Hiding：公开m&#x3D;H(x)，给定x’，如果H(x’)&#x3D;m，即可保证x’&#x3D;x\n扩大输入空间的方法：选取nonce（number once）随机数，H(x||nonce)\n二、Digital Signature（数字签名）不同于银行的开户流程，比特币是去中心化的，只要在本地创建一个公私钥对（public key，private key），就代表一个比特币账户，来源于非对称加密体系（asymmetric encryption algorithm）\n在比特币系统中，公私钥用于签名：发布者用自己的私钥对交易进行签名，接受者通过发布者的公钥验签\n生成公私钥、以及签名 都需要 a good source of randomess\n总结在比特币系统中，通常对一个message取哈希，然后再对该哈希值进行签名\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","密码学"]},{"title":"北大-区块链技术与应用4-共识协议","url":"/2025/01/02/33-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE/","content":"一、Double spending attack（双花攻击）双花攻击指同一笔资金被重复支付的情况，也是数字货币面临的主要挑战\n中心化解决方案：数字货币上添加唯一编号，并由央行维护一个数据结构，展示每个编号的货币由谁持有；如果付费方的货币在表中对应的持有人与此人不符，则证明该货币已支付给其他人\n去中心化的解决方案：比特币\n关注：货币的发行（挖矿）、交易的有效性验证（防范双花攻击）\n二、交易的有效性验证通过一个由所有用户共同维护的数据结构——区块链 来实现\n三、区块链简易结构Note：以下为简易版的区块链，每个区块都只有一个交易，实际上每个区块的交易记录都构成一个 Merkle tree\n\n存在两种哈希指针：将区块串联成链表的指针，和指向前面某个交易的指针（为了说明币的来源，避免凭空捏造和重复交易）\n1、用户A 具有发行货币的权利（铸币权，mint 铸币），并发行了10个比特币（coin base transaction，铸币交易）\n2、用户A 分别给 用户B、用户C 5个比特币\n3、用户B 分别给 用户C 2个比特币、用户D 3个比特币\n4、用户C 转给 用户E 7个比特币\n5、假设用户B 继续给 用户F 5个比特币，通过区块的回溯，校验出其已经在先前的交易中支付过了，所以交易不合法（避免双花攻击）\n在 用户A 向 用户B 的交易中，需要记录 「输入」A的公钥、A的签名 和 「输出」B的地址（通过B的公钥取哈希等操作得到，可类比为银行卡账号）A 需要 B的公钥 知道向哪里转账，所有节点都 需要 A的公钥 来验签\nBitCoin Scripts交易中的A的公钥（该交易的输入脚本），需要与 币的来源的A的公钥的哈希（前一交易的输出脚本） 相符（两脚本拼在一起能顺利执行）；否则说明币的来源有问题，A被冒名顶替了\n四、区块结构1、Block header包含区块的宏信息，比如：version（协议版本）、hash of privious block header（前一区块头的哈希）、merkle root hash（Merkle树 根哈希），还有和挖矿相关的 target（挖矿的难度目标域值）、nonce（随机数）\nNote：\n（1）hash of privious block header 取的只是前一区块头的哈希，不包含块体\n（2）Merkle树 根哈希 保证了块体中的交易列表不会被篡改\n（3）target 满足 H(block header)≤target，块头中存的是该目标域值的编码 nBits（nBits 是用于表示难度的参数，用于判断区块头是否有效）\nnBitsnBits 是一个包含了目标值信息的编码，通常以十六进制形式存储并表示为一个 4 字节（32 位）的数该编码包含两个部分：\n\n难度指数（Exponent）：前 1 个字节（8 位）\n目标哈希的有效值（Coefficient）：后 3 个字节（24 位）目标值越小，挖掘新区块的难度就越大。这允许系统灵活地调整挖矿的难度，并以压缩的方式存储信息\n\n2、Block body包含 transaction list（交易列表）\n五、Distributed consensus（分布式共识）账本的内容要取得分布式的共识\n1、共识的例子：Distributed hash table（分布式哈希表）达成共识的是 key-value pairs（键值对）\n2、Impossibility result（不可能结论）Example：FLP impossibility result在 asynchronous system（异步系统）中，即使只有一个成员是 faulty（有故障的），那么也无法取得共识\nCAP Theorem\n（1）Consistency（一致性）\n（2）Availability（可用性）：即使某些节点不可用，系统仍然能够提供服务\n（3）Partition tolerance（分区容忍性）：分区是指在网络中，若干节点之间的通信链路发生故障时形成的网络割裂，这意味着某些节点无法与其他节点进行交互\n不可能三角：任何一个分布式系统，只能满足以上两个性质，不可能三个性质都满足\n3、分布式共识的著名协议：Paxos该协议能保证一致性，但是有可能一直达不成共识（可能性比较小）\n六、Consensus in BitCoin（比特币中的共识）1、基于投票的共识方案基于投票的方案需要确认投票权的 membership，比如联盟链的协议 hyperledger fabric（超分类账结构）。常规的投票方案会带来 sybil attack（女巫攻击），即通过超级计算机生成超半数的比特币账户以获取控制权\n2、验证过程H(block header) ≤ target，block header 中包含 4 bytes 的随机数 nonce，组装好区块后就开始尝试不同的 nonce，直到哈希值落在 target 内。如果某节点找到了符合要求的 nonce，即具备了记账权（在去中心化账本中写入&#x2F;发布下一个区块的权利），发布后即由其他区块进行验证：\n1、验证 block header 中的几项\n2、看 block body 中的交易列表，验证每个交易都是合法的：（1）要有合法的签名；（2）以前没有被交易过\n3、Forking attack（分叉攻击）但是不同的链上可能发生重复交易（forking attack），解决方案是以 longest valid chain（最长合法链）为准，因此只有扩展最长合法链的区块才是合法的\n\n当两个矿工同时创造新区块时，其他节点按照接收时间来选择接受哪个区块，等长的临时性的分叉会维持一段时间，直到其中一条链胜出（先找到下一个区块）；而另一条链就变成了 orphan block（孤儿区块） &#x2F; stale block，被丢弃掉，也就没有出块奖励\n4、Block reward（区&#x2F;出块奖励）获得记账权的节点，在发布的区块里可以进行 coinbase transaction（铸币交易），发布一定数量的比特币\n一开始，每个发布的区块可以产生 50 BTC；21万个区块以后，出块奖励会减半为 25 BTC；再过21万个区块，会变成 12.5 BTC（现在）\n平均出块时间为10分钟，出块奖励减半的时间：21w * 10min &#x2F; (60min * 24h * 365d) ≈ 4年\n5、基于 hash rate 的共识方案Hash rate（计算 nonce 哈希的速度）决定了投票的权重，hash rate 越高，获得记账权并得到出块奖励的概率越大\n避免 sybil attack（女巫攻击）：创建多个账户不会增加 hash rate，也不会增加投票权重\n七、类比挖矿：mining\n比特币：digital gold\n矿工（争夺记账权的节点）：minner\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","共识协议"]},{"title":"北大-区块链技术与应用3-数据结构","url":"/2025/01/02/32-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","content":"一、Hash Pointers（哈希指针）哈希指针除了地址之外，还要保存地址的哈希值，用于检测结构体的内容是否被篡改\nBlock chain is a linked list using hash pointers.\n\n区块链中的第一个区块叫 genesis block（创世区块），其 height（高度）为 0；最后一个区块叫 most recent block\n后一个区块中的哈希指针是对前一区块的整体取哈希（包含前一区块中储存的哈希指针），可以实现 tamper-evident log（篡改证明记录）\n修改一个区块，会导致其后所有区块的哈希发生改变。所以只需保存和比对最后一个哈希值，就能检测出对区块链中任何部位的修改\n二、Merkle Tree（默克尔树）Merkle tree 和 Binary tree 对比，就是把普通指针换成哈希指针\n\n只要记录并比对 root hash（根哈希值），就能检测出整个树中任何部位的修改\n区块结构每个区块包含 block header（块头） 和 block body（块身）\n1、块头：包含 该区块的所有交易组成的 Merkle tree 的根哈希值，但没有具体的交易内容2、块体：包含具体的交易列表\n比特币节点比特币中的节点分为：\n\nfull node, or fully validationg node（全节点）\nlight node, or light-weight node（轻节点）\n\n1、全节点：保存整个区块的内容，包括块头和块体（包含 tansaction list，即交易的具体信息）；会验证每一笔交易\n2、轻节点：比如手机上的比特币钱包的APP，只保存块头；无法独立验证交易的合法性\n\nMerkle proof 指从交易发生到根哈希值的路径，可以向轻节点证明某笔交易写入了区块链，流程如下：\n（1）轻节点向全节点请求图3中红色的哈希值\n（2）然后根据交易和红色的哈希值，自底向上算出绿色的哈希值，直至算出根哈希值\n（3）最后将算出的根哈希值，与轻节点块头中的哈希指针比较，一致则证明该交易发生在此区块\n上述方法也叫做 proof of membership 或 proof of inclusion假设最底层的交易数为n，验证交易存在的时间复杂度为：θ(log(n))\n对于无序的 Merkle tree，proof of non-membership（验证交易不存在）的时间复杂度为线性 θ(n)，即一个一个试对于 Sorted Merkle tree（对交易取哈希，并且按哈希值大小排序），上述验证的时间复杂度为 θ(log(n))，与二分法一致：只需要对其大小相邻的两个交易进行哈希值的校验，如果和根哈希一致，则证明该交易不存在\n由于区块链中不需要做不存在证明，所以比特币中的 Merkle tree 不要求排序\n除了区块链 和 Merkle tree，哈希指针还可以用在其他无环的链表中\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","数据结构"]},{"title":"北大-区块链技术与应用5-BTC系统的实现","url":"/2025/01/12/34-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-BTC%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/","content":"比特币采用 transaction-based ledger（基于交易的账本）模式，每个区块中记录交易信息（转账交易、铸币交易），系统上不记录交易信息\n一、UTXO比特币的全节点要维护一个数据结构 UTXO（Unspent Transaction Output，所有未被花出去的交易的输出 组成的集合）\n一个交易可能有多个输出，即用户可以在一次交易中同时向多人转账（可以节省手续费）\n比如：A 给 B 交易 5 BTC，B 将其交易出去；A 给 C 交易 3 BTC，但未交易出去。这是两个输出，但是只有 A 给 C 的交易在 UTXO 中\n\nUTXO 中的每个元素要给出产生这个输出的交易的哈希值（可理解为交易的ID），以及它在这个交易里是第几个输出，这两个信息可以定位一个 UTXO 中的输出\nUTXO 的用途：在交易发生前，检查即将花出去的币是否在 UTXO 中，在才是合法的，快速校验双花攻击和凭空捏造\n每笔交易会消耗掉 UTXO 中的一些输出，同时在 UTXO 中产生新的输出，total inputs &#x3D; total outputs（所有输入的金额 等于 所有输出的金额）\ntotal inputs ≈ total outputs    1 BTC         0.99 BTC\n\nTransaction fee（交易费）：发布区块的节点（矿工）之所以会把他人的交易打包到新区块里，是因为 BTC 系统的第二个激励机制——交易费。通过把他人的交易打包到区块里，矿工会收取一些交易费（费用高的交易优先级就更高）\n目前矿工挖矿、争夺记账权，主要目的还是为了获取出块奖励，但是随着出块奖励的减少；多年后，交易费可能会变成矿工的主要收益\n二、Account-based ledger（基于账户的账本）和比特币 transaction-based ledger（基于交易的账本）模式不同，以太坊采用 account-based ledger（基于账户的账本）模式，在这种模式中，系统需要显式地记录每个账户有多少币，查询更方便（不需要说明币的来源），但是隐私保护性不如比特币\n三、Block ExampleBlock header 的详细字段：https://developer.bitcoin.org/reference/block_chain.html \n其中，nonce 和 merkle root hash 是可以改变的，通过改变 coinbase message 来改变 merkle root hash（coinbase message 可以看做 extra nonce）\n\n在比特币的 POW（Power of work，工作量证明机制）中，矿工需要不断尝试不同的 nonce 和 coinbase message 组合，以找到一个满足目标哈希值的区块头，共有两层循环：\n外层循环调整 coinbase 域 的 extra nonce，算出 block header 里的根哈希值之后，内层循环再调整 header 里的 nonce\n\n在比特币系统中，验证交易的合法性，就是通过将交易的 input scripts 和 output scripts 配对后执行来完成的。注意：不是把同一个交易的输入脚本和输入脚本配对，而是把这个交易里的输入脚本 和 前一个提供币来源的交易里的输出脚本配对。如果拼接在一起可以顺利执行，那么该交易就是合法的\n四、挖矿概率分析Bernoulli trial（伯努利试验）：A random experiment with binary outcome，比如：掷硬币\nBernoulli process（伯努利过程）：A sequence of independent Bernoulli trials\nPorsson process（泊松过程）：试验次数很多，成功概率很小\n伯努利过程的性质之一是 memoryless（无记忆性）&#x2F; progress free（与过程无关）：前面的实验结果对后面的实验结果无影响。由于挖矿的成功概率很小，所以可以用泊松过程近似\n出块时间服从 Exponential distribution（指数分布），纵轴是 probability density（概率密度），横轴是 time to next block（出块时间）。注意这是整个系统的出块时间，不是每个具体矿工的出块时间，具体到每一个矿工，出块时间取决于矿工的算力占系统总算力的百分比\n\n如果不满足 progress free 这个性质，那么算力强的矿工会获得不成比例的优势，比如：A算力是B算力的10倍，但是A获得记账权的概率超过B的10倍。该性质正是挖矿公平性的保证\n五、比特币的总量产生的比特币数量构成一个 geometric series（几何序列）：21w * 50 + 21w * 25 + 21w* 12.5 + … &#x3D; 21w * 50 * (1 + 1&#x2F;2 + 1&#x2F;4 + …) &#x3D; 2100w\n挖矿的过程对于维护比特币系统的安全性是至关重要的：Bitcoin is secured by mining，对于一个去中心化的系统，挖矿提供了一个凭借算力投票的有效手段，只要大部分算力掌握在诚实的节点手里，系统的安全性就能得到保证\n六、比特币的安全性1、偷币偷币是不可能的，因为系统以最长链合法链为准，恶意节点产生的区块会变成孤儿区块被丢弃，并且恶意节点还会损失本应得的出块奖励\n2、双花攻击可以通过 forking attack（分叉攻击）实现。区块插入的位置在刚开始挖矿的时候就决定，因为设置的 block header 里需要填写前一个区块的哈希值。\n分叉攻击：首先制造等长的合法链，比如，M 向 A 转账交易，产生了不可逆的外部效果（如购买实体商品）；然后再将该交易回滚，留下 M 向自己转账的区块，则 M 可从中不当获利\n\n如何防范分叉攻击？多等几个区块 &#x2F; confirmation（确认），M 向 A 转账的交易刚写入区块的时候，叫 one confirmation，后面的区块类推。比特币协议中缺省的设置是：等待 6 个 confirmation 之后，才认为前面的交易是不可篡改的（大约1小时）\n\n区块链是 Irrevocable ledger（不可篡改的账本），这种不可篡改性只是一种概率上的保证，刚刚写入区块链的内容还是比较容易被改变的，随着后续 confirmation 的增加，被篡改的概率会指数级大幅度下降\nZero confirmation：转账交易发布出去了，但是还未被写入区块链中。这种方式在实际应用中比较普遍，因为（1）比特币协议缺省的设置是 节点接收最先听到的那个交易，所以上述例子中 M 转给自己的交易大概率不会被诚实的节点接受；（2）很多购物网站从支付成功到发货天然是有时间间隔的\n3、恶意节点故意不把合法交易写入因为总有诚实的节点愿意发布这些交易，所以合法交易总是可以被写到下一个区块里\n在正常工作的情况下，也可能出现合法交易未被包含进去的情况，比如近期交易的数目太多。比特币协议中规定，每个区块的大小是有限制的，最多不能超过一兆字节，如果交易的数目太多，可能就只能等到下一个区块再发布\nSelfish mining（自私挖矿）正常情况下，挖到一个区块就立即发布，防止别人发布后自己的区块作废、丧失出块奖励\nSelfish mining：挖到多个区块，但是都藏着不发布，攒够6个之后同时发布。这种攻击的前提是，有恶意的节点需要占据很大一部分算力（比如至少51%）\nSelfish mining 的好处：如果个人算力较强，可以减少挖后续区块的竞争\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","BTC"]},{"title":"北大-区块链技术与应用6-BTC网络","url":"/2025/01/13/35-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-BTC%E7%BD%91%E7%BB%9C/","content":"一、网络层级顶层是 application layer，运行着 BitCoin 和 Block chain 协议；底层是 network layer，运行着 P2P Overlay Network\n比特币的 P2P 网络很简单，所有节点都是平等的，不像有的网络有 super node &#x2F; master node\n二、加入&#x2F;离开网络加入网络前，需要和 seed node（种子节点）联系，它会告知网络中的其他节点，节点之间通过 PCP 通信，有利于穿透防火墙；离开时不需要做任何操作，只需退出应用程序，其他节点会将一段时间未接收到消息的节点删除\n比特币网络设计的原则是：simple, robust, but not efficient（简单、鲁棒，而不是高效）\n三、等待上链的集合每个节点维护一个邻居节点的集合，消息传播在网络中采取 flooding（泛洪）的方式。节点第一次听到某个消息的时候，把它传播给其他所有的邻居节点，并记录已收到该消息，下次再收到时就不会再次转发。邻居节点的选取是随机的，不考虑底层的拓扑结构，这样设计可以增强鲁棒性，但牺牲了效率\n比特币系统中，每个节点需要维护一个等待上链（写入区块链）的集合。第一次听到某个交易的时候，把交易加入该集合，并把该交易转发给邻居节点，下次就不再转发。转发的前提是交易是合法的：签名合法，之前未被花过\n如果同时有两个冲突的交易被广播到网络上，比如：A 转钱给 B，A 又转钱给 C（双花），以首先被写入到区块链上的交易为准，交易被写入到区块链中即被等待上链的集合删除\n四、Best effort比特币网络的传播属于 best effort（尽最大努力），一个交易发送到比特币网络上，不一定所有节点能收到，且顺序也不一定，节点也不一定按照规则传播\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","BTC"]},{"title":"北大-区块链技术与应用7-挖矿难度","url":"/2025/01/13/36-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6/","content":"一、挖矿难度和目标域值H(block header) ≤ target\n调整挖矿难度，就是调整目标空间 在整个输出空间中所占的比例，通俗地说，就是哈希值的前面有多少 0\n比特币使用的哈希算法是 SHA-256，整个输出空间是 2^256 个可能的取值\n挖矿难度和目标域值成反比：\n\ndifficulty_1_target：挖矿难度等于1时，对应的目标域值（挖矿难度最小就是1），此时的目标域值很大\n二、出块时间太短的后果系统的总算力越强，安全性就越高，因为发动 51% attack（考虑2个分叉）的成本就更高\n出块时间太短，但是传播速度较慢，很容易导致过多的 forking（分叉），系统的总算力就被分散了，更容易造成 forking attack，因为可以通过较小的算力（100%&#x2F;分叉数+1%）实现攻击\n以太坊的出块时间是15s，出块速度是比特币的40倍，因此以太坊设计了新的共识协议 ghost，其中产生的 orphan block 就不能简单的丢弃，而是要给一些奖励（uncle reward）\n三、调整挖矿难度比特币协议规定每个2016个区块，需要调整目标域值，2016*10/(60*24)≈14天\n调整目标域值的公式：\n\n其中，expected time（预期时间）是 2016*10，actual time（实际时间）是系统近期产生2016个区块所花费的时间。在实际代码中，上调和下调分别有4倍和1&#x2F;4的限度\n如何让所有的矿工同时调整域值？block header 中存储的 nBits 是目标域值编码的版本（将 target 的256字节 压缩到4字节）。如果有矿工不调整，那么校验就不会被通过\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","BTC"]},{"title":"北大-区块链技术与应用8-BTC挖矿","url":"/2025/01/13/37-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-BTC%E6%8C%96%E7%9F%BF/","content":"一、全节点1、一直在线2、在本地硬盘上维护完整的区块链信息3、在内存里维护 UTXO 集合，以便快速检验交易的正确性UTXO（unspent transaction output）\n4、监听比特币网络上的交易信息，验证每个交易的合法性（1）是否有合法的签名\n（2）是不是 double spending\n5、决定哪些交易会被打包到区块里缺省状态下，只要是合法交易、并且交易费符合要求，就会被打包\n6、 监听别的矿工挖出来的区块，验证其合法性（1）区块中的每个交易都要合法，包括铸币交易，比如是否篡改了出块奖励、发布的难度是否符合要求（block header 取哈希后，前面是否有足够多的 0；block header 里的难度目标域值是否设置正确）\n（2）全节点是否每两周调整挖矿难度\n（3）检查该区块是否在延伸最长合法链\n7、挖矿（1）决定沿着哪条链挖下去？缺省情况下沿着最长合法链挖下去\n（2）当出现等长的分叉的时候，选择哪一个分叉？缺省情况下选择最先听到的分叉\n二、轻节点轻节点也叫做 spv client（simplified payment verification）\n1、不是一直在线2、不用保存整个区块链，只要保存每个区块的块头大约是全节点的 1&#x2F;1000\n3、不用保存全部交易，只保存与自己相关的交易4、无法检验大多数交易的合法性，只能检验与自己相关 的那些交易的合法性5、无法检测网上发布的区块的正确性6、可以验证挖矿的难度因为挖矿的时候，计算哈希值只用到了块头的信息\n7、只能检测哪个是最长链，不知道哪个是最长合法链因为无法检测这条链上所包含的交易都是合法的（不过可以检测每个区块是否符合难度要求）\n三、挖矿的注意事项比特币网络中大部分节点都是轻节点，如果只想进行转账，而不进行挖矿，就不需要运行全节点、只需使用轻节点\n在挖矿过程中，如果监听到别人发布了一个区块，需要重新组装区块（block header 和 交易内容都有变化）、重新开始挖\n四、比特币的安全性保证1、密码学恶意节点拿不到私钥，就无法伪造签名，也就无法偷币\n2、好节点占大部分算力前提是系统中大部分算力的矿工是遵守协议的\n五、挖矿趋势一：设备从通用到专用1、CPU最早是用普通的 CPU &#x2F; 通用计算机 挖矿，但是这种方式无法充分利用内存\n2、GPUGPU 用于大规模的并行计算，比如深度学习大量的矩阵乘法，但也部分部件也无法充分利用（比如浮点数运算）\n3、ASIC 芯片ASIC（Application Specific Integrated Circuit，专用集成电路），ASIC 芯片是专门为比特币挖矿计算哈希值而设计，性价比最高\n但是同一个芯片只能用于一种币的挖矿，除非两种币使用同一个 mining puzzle。有些新开发的币会使用已有币的 mining puzzle，进而吸引更多矿工，这叫做 merge mining\n购买 ASIC 矿机的时机很重要，因为过时得很快，现在一般需要提前预定。不良厂商可能会在矿机生产后的黄金两个月先自己挖矿，然后才卖给用户\n有些新型货币，设计的是 alternative mining puzzle，出发点是 ASIC resistance，目的是让通用计算机也能参与挖矿过程\n六、挖矿趋势二：大型矿池的出现矿池的出现是为了解决单个矿工收入不稳定的问题。矿池把矿工组织起来作为一个整体，其架构是：一个全节点驱动多个矿机\n一个矿池一般有一个 pool manager（矿主），下面连着很多 minner（矿工），矿工只负责通过 ASIC 芯片计算哈希值，全节点的其他职责都由矿主承担（比如监听网络上的交易，并将其打包成一个候选区块，同时监听是否有其他节点抢先发布区块）\n矿池的收益分配矿池一般有两种组织形式：\n（1）类似大型数据中心，所有矿机属于同一个机构\n（2）分布式的，矿工和矿主不在同一个地方，矿工加入矿池，是通过矿池规定的通讯协议和矿主进行联系。矿主把要计算的哈希值的任务分配给矿工，矿工计算完成后把结果返回给矿主，有出块奖励时一起参与分红\n通过工作量证明，按照矿工的贡献大小分配收益：降低挖矿难度（减少目标域值前0的数量），符合条件的叫一个 share（almost valid block），挖到合法区块、得到出块奖励之后，矿主按照矿工 share 的数量来分配收益\n1、矿工是否能偷出块奖励？矿工不可能挖到一个合法区块自己偷偷发布，因为矿工的任务由矿主分配，矿主负责组装区块，并把不同的 coinbase parameter 所对应的 nonce，交给不同的矿工尝试，而 coinbase transaction 里的收款人地址填的是矿主的地址\n2、矿工是否能捣乱？是可以的，比如 矿工正常提交 share，但是挖到合法区块之后就丢弃掉\n3、矿池的弊端恶意方可能吸引到足够多的矿工（不明真相的群众）加入，然后发动 51% attack：\n（1）Forking attack：制造分叉，因为算力高，迟早能赶超6个区块；\n（2）Boycott：制裁对象一挖出区块，就分叉，因为算力高，更容易使制裁对象的区块作废\n类似于云计算中的 on demand computing，平时不用自己去维护很大的计算集群，需要用的时候可以随时召唤，对于矿池来说就是 on demand mining\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","BTC"]},{"title":"北大-区块链技术与应用10-BTC分叉","url":"/2025/01/14/39-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-BTC%E5%88%86%E5%8F%89/","content":"一、State fork（状态分叉）State fork：对比特币当前的状态有分歧造成的分叉，比如两个区块几乎同时生成，造成的分叉\nForking attack 也属于 state fork，但是是人为故意的，所以也叫做 deliberate fork（故意分叉）\n二、Protocol fork（协议分叉）Protocol fork：比特币的协议发生改变（通过软件升级），有些节点由于各种原因可能暂时没有升级，从而造成的分叉\n根据对协议修改的内容的不同，可以分为 hard fork（硬分叉）和 soft fork（软分叉）\n1、Hard fork新节点发布的区块，旧节点可能不认\n1个交易约为250字节，一个区块约有 1000,000字节&#x2F;250字节&#x3D;4000个交易，每秒约有 4000&#x2F;(60*10)≈7个交易，数量过少\n假设 Block size limit 从 1M 更新到 4M，大多数算力的节点更新了软件，但少部分未更新。只要仍有部分节点未更新软件，该分叉就不会消失\nExample：ETH &amp; ETC2016年，以太坊的 DAO（去中心化自治组织）遭到黑客攻击，导致大量ETH被盗。部分成员支持通过硬分叉回滚交易、恢复被盗资金，而另一些成员认为这会破坏区块链的不可篡改性\n最终社区实施硬分叉，恢复到攻击前的状态，这条新链称为 Ethereum（ETH）；而反对硬分叉的用户继续使用原链，称为 Ethereum Classic（ETC），从此两种货币独立发展（通过chain ID 区分两条链）\n2、Soft fork新节点发布的区块，旧节点仍会认可\n假设 Block size limit 从 1M 更新到 0.5M，大多数算力的节点更新了软件，但少部分未更新。如果有节点不更新软件，可能会经常产生孤儿区块，所以最终所有节点都会更新，分叉不会继续延展\nExample：P2SH（Pay to Script Hash）P2SH 的验证分为两步：（1）验证输入脚本给出的赎回脚本，和前一个交易的输出脚本给出的 赎回脚本的哈希值 对得上；（2）执行赎回脚本，验证输入脚本给出的签名是合法的\n对于旧节点来说，只会进行第一阶段的认证；所以新节点认为合法的区块，旧节点仍然会认可\n3、总结（1）Soft fork：只要系统有半数以上的节点更新，就不会有永久的分叉\n（2）Hard fork：如果不是所有的节点都更新了，就会有永久的分叉。根本原因是旧节点不认可新链（不是合法最长链），所以会按照旧链执行\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","BTC"]},{"title":"北大-区块链技术与应用11-课堂回答","url":"/2025/01/15/40-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-%E8%AF%BE%E5%A0%82%E5%9B%9E%E7%AD%94/","content":"略（基本没有新东西），详情可参考课程视频：\nhttps://www.bilibili.com/video/BV1Vt411X7JF?spm_id_from=333.788.videopod.episodes&amp;vd_source=69ac93649ea21c4726fe85f272b6d968&amp;p=11 \n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3"]},{"title":"北大-区块链技术与应用12-BTC的匿名性","url":"/2025/01/15/41-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-BTC%E5%8C%BF%E5%90%8D%E6%80%A7/","content":"一、比特币的匿名性anonimity（匿名性）、privacy（隐私性）\n比特币使用的是 pseudonymity（假名）\nExample：一个人通过自己的两个账户 addr1 和 addr2，向商家账户转账 addr3，然后把零钱转入自己的另一个账户 addr4\nInputs: addr1, addr2\nOutputs: addr3, addr4\n1、破坏比特币匿名性的方法：（1）比特币不同账户之间可以进行关联\n（2）比特币可以和实体世界相关联\n2、Silk road（丝路）Silk road 是一个非法交易平台，被称为 eBay for illegal drugs，支付手段采用比特币，底层路由采用 TOR（洋葱路由），提供匿名邮寄服务，后被封禁\n这说明比特币的匿名性并没有那么好\n3、如何提高自己比特币的匿名性？（1）Network layer采用多路由转发，比如 TOR（洋葱路由）\n（2）Application layerCoin mixing（混币交易），即把不同人的币混起来。交易所天然具有 coin mixing 的性质，前提是交易所不会泄露任何交易记录\n二、Zero-knowledge proof（零知识证明）零知识证明：指证明方向验证者证明一个陈述是正确的，而无需泄露额外的任何信息\n同态隐藏（1）不会碰撞：如果 x, y 不同，那么它们的加密函数值 E(x) 和 E(y) 也不相同，其逆否命题也成立（2）隐私性：给定 E(x) 的值，很难反推出 x 的值（3）给定 E(x) 和 E(y) 的值，我们可以很容易地计算出某些关于 x, y 的加密函数值\n同态加法：通过 E(x) 和 E(y) 计算出 E(x+y) 的值\n同态乘法：通过 E(x) 和 E(y) 计算出 E(xy) 的值\n扩展到多项式\n\n三、零币和零钞零币（zerocoin）和零钞（zerocash）融合了匿名化处理，但仍未解决与实体世界相关联导致的隐私泄露问题\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","BTC"]},{"title":"北大-区块链技术与应用9-BTC脚本","url":"/2025/01/14/38-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-BTC%E8%84%9A%E6%9C%AC/","content":"本节课较多用到 PPT 上的动画，视频链接如下：\nhttps://www.bilibili.com/video/BV1Vt411X7JF?spm_id_from=333.788.player.switch&amp;vd_source=69ac93649ea21c4726fe85f272b6d968&amp;p=9 \n比特币使用的编程语言很简单，内存空间只有一个通用的堆栈\n\n上述的输入脚本包含2个操作：分别把2个很长的数压入栈里\n输出脚本有2行，分别对应上面的2个输出，每个输出有自己单独的脚本\nBTC 脚本校验方式假设 A-&gt;B，B-&gt;C，下面对 B 交易时币的来源做校验，有两种校验方式\n\n1、P2PK（Pay to Public Key）input script:    PUSHDATA(Sig)output script:    PUSHDATA(PubKey)    CHECKSIG\n\n1、PUSHDATA(Sig)：把 B 的签名入栈——来自输入脚本\n2、PUSHDATA(PubKey)：把 B 的公钥入栈——来自输出脚本\n3、CHECKSIG：弹出栈顶的两个元素（公钥和签名），用公钥验签，通过则返回 TRUE\n2、P2PKH（Pay to Public Key Hash）——最常用P2PKH 与 P2PK 的区别是：输出脚本给出的不是公钥，而是公钥的哈希值；输入脚本除了签名外，还需要给出公钥\ninput script:    PUSHDATA(Sig)    PUSHDATA(PubKey)output script:    DUP    HASH160    PUSHDATA(PubKeyHash)    EQUALVERIFY    CHECKSIG\n\n1、PUSHDATA(Sig)：把 B 的签名入栈——来自输入脚本\n2、PUSHDATA(PubKey)：把 B 的公钥入栈——来自输入脚本\n3、DUP：把栈顶的元素复制一遍（即 B 的公钥）\n4、HASH160：把栈顶元素弹出，并取哈希（即对 B 的公钥取哈希），然后把得到的哈希再压入栈\n5、PUSHDATA(PubKeyHash)：把 B 的公钥哈希入栈——来自输出脚本\n6、EQUALVERIFY 是弹出栈顶的两个元素（哈希值），并比较它们是否相等\n7、CHECKSIG：弹出栈顶的两个元素（公钥和签名），用公钥验签，通过则返回 TRUE\n3、P2SH（Pay to Script Hash）——最复杂P2SH 的特点是 input script 要提供一个 redeem script（赎回脚本）\nP2SH 常见的应用场景是对 multiple signature（多重签名，即一个输出要求多个签名才能把钱取出，目前已不推荐）的支持\n验证分为两个阶段：第一阶段按照输入脚本和输出脚本的顺序执行；第二阶段执行赎回脚本\n具体略，有点复杂，可简单理解为把 P2PKH 中的 PUSHDATA(PubKey) 和 CHECKSIG 提取成一个赎回脚本\n4、Proof of Burnoutput script:    RETURN        [Zero or more ops or text]\n\n这种类型的输出被称为：Provably Unspendable（可证明不可花费） &#x2F; Prunable Outputs（可删减输出）\n这个脚本是证明销毁掉比特币的一种方法，有两种应用场景：（1）有些小的币种要求销毁一定数量的比特币才能够得到该币，这种币叫做 AltCoin（Alternative Coin）；（2）往区块链中写入一些内容，比如 digital commitment，把知识产权取哈希放在 return 后面，可以证明在某个时间点知道某个知识，任何用户都可以通过销毁少量比特币（将币转到不存在的地址）、换取向区块链写入的机会（不提倡，因为该交易会永久保留在 UTXO 中，浪费资源）\n注意：以上的 CHECKSIG 全称是 OP_CHECKSIG，DUP 全程是 OP_DUP\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","BTC"]},{"title":"北大-区块链技术与应用13-BTC引发的思考","url":"/2025/01/15/42-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-BTC%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/","content":"一、哈希指针指针保存的是本地的内存地址，区块链中的哈希指针是如何传递的？其实区块中保存的只有哈希，没有指针（只是形象化的说法）。全节点会把区块以 (key, value) 存储在数据库（level DB）中，且只保存最近的几千个区块\n二、区块恋双方把私钥截成两段，每方保存一段不可取，有两点问题：\n\n蛮力攻击更加容易\n永久占据 UTXO，浪费资源\n\n建议采取 MULTISIG（多重签名）\n三、比特币中的稀缺性比特币的总量是确定的，这种“稀缺”的东西不适合作为货币，一个好的货币需要有通货膨胀的功能；否则随着社会财富的增加，总量一定的货币会越来越值钱，先来者躺平，后来者买不起（类比国内房地产）\n四、量子计算量子计算技术离使用还差的很远，就算有一天量子计算能够破解现有的加密体系，首先冲击的是传统金融业；并且后面还会有量子加密算法\n比特币并没有直接暴露账户的公钥，而是把公钥取哈希得到一个地址。假设量子计算使得从公钥推出私钥变为可能，比特币还有另一层防护：使用的是公钥哈希，首先需要通过地址推出公钥，而取哈希是不可逆的，因为取哈希的过程中存在信息丢失（比如任意长度的公钥都能通过 SHA-256 压缩成 256位）\n从 安全性 和 隐私保护 的角度看，比特币的一个地址一旦用过后，就不要再用了，每次从一个地址取钱时，最好把所有钱都取走，除了支付的钱，剩下的转给自己的另外一个账户\n如果担心量子计算的威胁，即使是公钥也不要随意泄露\n","categories":["Web3 - 北大肖臻-区块链技术与应用"]},{"title":"北大-区块链技术与应用14-ETH概述","url":"/2025/01/15/43-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-ETH%E6%A6%82%E8%BF%B0/","content":"比特币被称为 区块链1.0，以太坊被称为 区块链2.0\n一、以太坊和区块链的对比1、出块时间以太坊的出块时间从比特币的 10分钟 降低到了十几秒\n2、共识机制以太坊设计了新的 ghost 共识机制\n3、mining puzzle以太坊设计了新的 mining puzzle：比特币的 mining puzzle 是计算型的，比拼的是算力；而以太坊的 mining puzzle 是 memory hard，对内存的要求很高，从而限制了 ASIC 芯片的使用（ASIC resistance）\n4、证明机制以太坊用 POS（proof of stake，权益证明） 来替代 POW（proof of work，工作量证明）\n5、智能合约以太坊增加了对 smart contract（智能合约）的支持\n（1）BitCoin：decentralized currency（去中心化货币）在跨国转账方面，fiat currency（法定货币）不如比特币\n（2）Etherem：decentralized contract（去中心化协议）类似的，在跨国协议方面，去中心化协议也有优势\n6、最小单位比特币的最小单位是 Satoshi（聪）；而以太坊的货币叫做 Ether（以太），最小单位是 Wei\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","ETH"]},{"title":"北大-区块链技术与应用15-ETH的账户","url":"/2025/01/15/44-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-ETH%E8%B4%A6%E6%88%B7/","content":"一、比特币——基于交易的账本比特币用的是 transaction-based ledger（基于交易的账本），系统没有显示地记录账户的金额，需要通过 UTXO 计算，这种方式隐私性好，但不便于使用\n二、以太坊——基于账户的账本以太坊用的是 account-based ledger（基于账户的账本），转账时不需要说明币的来源\n1、好处不会出现 double spending attack（双花攻击——花钱的人不诚实）\n2、缺点需要预防 replay attack（重放攻击——收钱的人不诚实），一次交易被恶意节点广播多次\n通过增加一个计数器 nonce，用来记录某账户交易的次数，转账时交易次数要成为交易内容的一部分，都受到发布交易者签名的保护；如果发起重放攻击，交易中 nonce 的值和计数器的值相等，会被校验为不合法（合法的应该比计数器大 1）\n\n三、以太坊的账户类型1、Extranally owned account（外部账户）外部账户类似于比特币的账户，通过公私钥控制，也叫做普通账户。一个外部账户的状态有 balance（账户余额）和 nonce（计数器）\n2、Smart contract account（合约账户）合约账户不是通过公私钥对控制，不能主动发起交易（只有外部账户可以）。合约账户除了 balance（账户余额），nonce（计数器），还有 code（代码） 和 storage（状态&#x2F;存储）\n合约账户如何调用？创建合约时，会返回一个地址，知道合约的地址，就能调用合约，调用过程中状态会发生变化，但是代码是不变的\n以太坊的创始人是 Vitalik。现在有人提出用智能合约生成一些 financial derivative（金融衍生品），比如：期权、期货\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","ETH"]},{"title":"北大-区块链技术与应用16-ETH中的状态树","url":"/2025/01/15/45-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-ETH%E7%8A%B6%E6%80%81%E6%A0%91/","content":"从账户地址到账户状态的映射：addr -&gt; state\n以太坊中的账户地址是 160 bits，也就是 20字节，一般表示为 40个 16进制的数；比特币和以太坊的地址格式、长度都不同，但是以太坊中的地址也是由公钥转换来的（公钥取哈希、进行截取，并只保留后面）\n在比特币中，merkle tree 除了证明账户上有多少钱之外，还可以维护各个全节点之间状态的一致性\n以太坊的状态树结构以太坊采用的数据结构是 MPT（‌Merkle Patricia Tree，默克尔前缀树&#x2F;压缩前缀树），基于 trie（单词查找树）\n一、Trie\n1、优点（1）Trie 每个节点的分支数目，取决于 key 每个元素的取值范围，以太坊的 branching factor 是 17（0~f，加结束位）\n（2）Trie 的查找效率取决于 key 的长度，越长查找次数越多，以太坊 key 值的长度都是 40\n（3）比起 key-value 对，trie 不会出现哈希碰撞\n（4）Trie 生成的树和插入顺序无关\n（5）Trie 中的更新操作具有局部性\n2、缺点一脉单传，存储浪费空间，于是就引入了 MPT\n二、MPT\nMPT 对树的高度进行压缩，访问内存的次数减少，提高效率。路径压缩在键值分布比较稀疏的情况下，效果比较好\n以太坊中的地址是 160 bits，地址空间为 2^160，因此以太坊账户地址的键值分布非常稀疏。地址这么长的原因是防止哈希碰撞（不同公钥哈希后的值相同）\nMerkle tree 比起 binary tree，把普通指针换成哈希指针；同样的，MPT 比起 PT，也是把普通指针换成哈希指针，最后计算出根哈希值\n1、根哈希值的作用（1）防止篡改\n（2）merkle proof，证明账户余额\n（3）和 sorted merkle tree 一样，可以证明账户是否存在\n2、Modified MPT以太坊用的是 modified MPT\n\n以太坊之所以会保留历史状态，是为了便于回滚\n\n三、状态树的数据结构\n\n\n四、状态树中的状态状态树中保存的是 (key, value)，value（账户的状态）是通过 RLP（Recursive Length Prefix，递归长度前缀，特点是极简）序列化之后存储在账户中的\nProtobuf（protocol buffer）是一个做数据序列化的常用库，只支持一种类型：nested array of bytes（嵌套字节数组）\n以太坊中的所有其它类型（整数、哈希），最终都要变成嵌套字节数组，实现 RLP 比嵌套字节数组容易很多\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","ETH"]},{"title":"北大-区块链技术与应用17-ETH中的交易树和收据树","url":"/2025/01/16/46-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-ETH%E4%BA%A4%E6%98%93%E6%A0%91&%E6%94%B6%E6%8D%AE%E6%A0%91/","content":"以太坊中的交易树和收据树也是 MPT，其好处是支持查找操作，查找的键值是交易在发布的区块中的序号（即排第几），其顺序由发布交易的区块确定\n交易树和收据树都是只把当前区块发布的交易组织起来，而状态树是把系统中所有账户的状态都包含进去（原因是：便于查找账户余额，尤其是很久没发生过交易的区块，更重要的是无法找到新账户）\n上节课讲到，多个区块的状态树是共享节点的；而每个区块的交易树和收据树是独立的\n交易树和收据树的用途是：提供 Merkle proof，交易树可以证明某个交易被打包到区块里，收据树的可以证明某个交易的执行结果\n1、Bloom filter（布隆过滤器）以太坊的收据树包含一个 Bloom filter\nBloom filter 可以支持高效的查找某元素是否在某个大的集合。通过将大的集合中的元素做哈希，映射到一个小的数组，该数组元素初始全为0，最终如果有元素映射到该位置，则置为1\n用 Bloom filter 检测元素是否在某个集合中，可能会出现 false positive（假阳性），即 实际不在、但是检测结果在，但检测结果在、实际一定在。且 Bloom filter 不支持删除元素\nBloom filter 在以太坊中的用途是支持复杂查询操作，比如：找到过去10天所有 和某个智能合约有关 &#x2F; 众筹 &#x2F; 发布新币的交易\n每个交易执行后会形成一个收据，收据里包含一个 Bloom filter，记录该交易的类型、地址和其他信息。发布的区块在块头里也有一个总的 Bloom filter，是区块里所有交易 Bloom filter 的并集\n轻节点只有块头信息，可以通过 Bloom filter 过滤掉很多区块，只保留符合条件的（即可能含有该交易的）区块，然后向全节点获取进一步的信息\n以太坊的运行过程，可以看做一个 transaction-driven state machine（交易驱动的状态机），状态是所有账户的状态，交易是每次发布的区块中的交易，执行交易会驱动系统转移到下一个状态\n比特币也可以看做一个交易驱动的状态机，其状态是 UTXO\n2、交易树、收据树、叔父数组 源码有点复杂，暂时没搞明白，详见以下课程链接（从29分开始）：\nhttps://www.bilibili.com/video/BV1Vt411X7JF?spm_id_from=333.788.player.switch&amp;vd_source=69ac93649ea21c4726fe85f272b6d968&amp;p=17 \n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","ETH"]},{"title":"北大-区块链技术与应用18-GHOST协议","url":"/2025/01/16/47-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-GHOST%E5%8D%8F%E8%AE%AE/","content":"以太坊出块时间的显著降低，使得更容易出现分叉（甚至多个分叉），大型矿池有优势，尤其对个体矿工不公平\n因为当出现分叉时，所有个体矿工的算力是分散的，而矿池中的所有算力会集中在其挖出的区块，导致矿池挖出的区块更容易成为最长合法链，造成 mining centralization，这种情况也叫做 centralization bias（中心化带来的不成比例的优势）；再加上矿池会在网络的多个地方有接口，所以其发布的区块可能更早被其他节点收到\n一、叔父区块GHOST 协议不是以太坊发明的，是以太坊对其做了改进。核心思想是给予孤儿区块（在以太坊中叫做 uncle block，叔父区块）一定的奖励（7&#x2F;8 的出块奖励），而打包叔父区块的区块可以获得额外的 1&#x2F;32 的出块奖励（一个区块最多包含 2 个叔父区块）\n以太坊一开始的出块奖励是 5个以太币，后来改为 3个以太币，现在变为 2个以太币（和挖矿难度相关）\n\nGHOST 的这种设计有利于鼓励系统中出现分叉后及时进行合并（解决系统中的临时性分叉）\n但是可能存在矿池恶意竞争，故意不包含叔父区块\n二、Uncle reward（叔父区块的奖励）最长合法链上的后续区块，仍然能包含前面区块未打包的叔父区块，但是叔父区块距离越远，奖励越小（7&#x2F;8, 6&#x2F;8, 5&#x2F;8, 4&#x2F;8, 3&#x2F;8, 2&#x2F;8），最长不能超过六代\n\n叔父区块的定义：必须和当前区块在七代以内有共同的祖先（at most seven generations）\n设计七代以内辈分的原因是：如果不限制备份，全节点需要维护的状态就太多了；七代以内辈分 uncle reward 逐级递减的原因是：有利于鼓励出现分叉后尽早进行合并\n在比特币和以太坊中，把 block reward 叫做 static reward（静态奖励）\n在比特币中，tx fee 叫做 dynamic reward（动态奖励）；而在以太坊中，在执行区块中包含的智能合约时，可以得到 gas fee（汽油费），叔父区块是得不到汽油费的\n比特币被比喻为数字黄金，是用来储值的；以太币被比喻为石油，是用来消耗的（不太恰当，因为以太币本身不会消失）\n打包叔父区块时不应该执行叔父区块中的交易，因为叔父区块中可能存在有冲突的交易（执行完父区块的交易，再执行叔父区块的交易就会非法）；而是会通过 block header 检查叔父区块是不是一个合法发布的区块（是否符合挖矿难度要求）\n叔父区块后面的节点不能给予奖励，否则分叉攻击就变得太简单了：如果成功，可以回滚交易；不成功，也可以合并获得 uncle reward\n\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","ETH"]},{"title":"北大-区块链技术与应用19-ETH挖矿算法","url":"/2025/01/18/48-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-ETH%E6%8C%96%E7%9F%BF%E7%AE%97%E6%B3%95/","content":"Block chain is secured by mining（挖矿保障了区块链的安全性），比特币的挖矿算法是一个天然的 bug bounty（悬赏找bug），如果能找到漏洞或挖矿的捷径（shortcut）就能获取很大的利益\n很多人认为，挖矿设备的专业化 和比特币的去中心化理念是相违背的（one cpu, one vote），普通人能够参与挖矿有利于分散算力，预防 51% attack。所以后续的加密货币设计 mining puzzle 的一个理念是 ASIC resistance\n设计 ASIC resistance 的 mining puzzle 的常用做法是：增加 puzzle 对内存访问的需求，即 memory hard mining puzzle，因为 ASIC 芯片计算能力强，但是在内存访问的性能上没有很大的优势\n一、LiteCoin &amp; Scrypt一个早期的例子是 LiteCoin（莱特币），曾经是市值仅次于比特币的加密货币，其 mining puzzle 基于 scrypt\nScrypt 是一个对内存要求很高的哈希函数，设计思想是：开设一个很大的数组，按照顺序填充一些伪随机数；具体过程是：按照一个 seed 的值，运算出一个数填在第一个位置，后面每个位置都是前一个位置取哈希得到的；其特点是里面的取值是有前后依赖关系的；求解 puzzle 时，按照伪随机的顺序从数组中读取一些数（通过对当前数运算得到下一个读取顺序，模拟随机）；好处是：如果数组开得足够大，对于矿工来说就是 memory hard 的，有的矿工可能保存一部分内存区域的内容，比如只保留奇数位置的数，需要读取到偶数再算，这也叫做 time-memory trade off（时间换空间）\n其坏处是：对于轻节点验证来说也是 memory hard，不符合 difficult to solve, but easy to verify。所以其实际使用过程中，数组只有 128k，不足以对 ASIC 芯片造成遏制，但该理念对其冷启动有很大帮助（需要冷启动是因为，参与挖矿的人太少很容易遭受恶意攻击），所以莱特币现在仍然是主流货币\n莱特币的出块时间是两分半，速度是比特币的四倍，其他部分和比特币基本相同\n二、以太坊 memory hard以太坊的挖矿算法叫做 ethash，矿工挖矿需要 1G 的内存，和莱特币的 128k 比，大了 8000 多倍，光是 cashe 就大了 100 多倍；更别说现在内存要求还在增长\n以太坊使用一大一小两个数据集：16M 的 cache 和 1G 的dataset，轻节点只要保存 cache，矿工才需要保存 1G 的大数据集\n1、具体算法算法太复杂了，没完全搞明白，具体算法的伪代码可参考课程视频（28分）：\nhttps://www.bilibili.com/video/BV1Vt411X7JF?spm_id_from=333.788.player.switch&amp;vd_source=69ac93649ea21c4726fe85f272b6d968&amp;p=19 \ncache 的生成方式和 scrypt 类似，但是不同于莱特币从数组中按照伪随机的顺序读取并进行运算，以太坊是需要先生成一个更大的数组（dataset 要大得多），而且 cache 和 dataset 是定期增长的，因为计算机的内存容量也在增长\ndataset 中的每个元素都是从 cache 中按照伪随机的顺序读取一些元素（和莱特币类似），一共读 256 次，用这 256 个数算出一个数，作为 dataset 的第一个元素，后续元素也一样\n求解 puzzle 时只使用 dataset 中的数，按照伪随机的顺序，从大数据集中读取 128 个数：一开始根据区块的块头、包括其中的 nonce 值，算出一个初始的哈希，然后根据该哈希映射到这个大数据集中的某个位置，将其中的数读取出来（同时将其相邻的元素读取出来），然后进行一些运算算出下一个位置，总共进行 64 次循环，共读取 128 个数。最后算出一个哈希值，和挖矿难度的目标域值比较，看是否符合要求，如果不符合，更换 nonce 之后再重新计算\n2、矿工保存 dataset 的原因由于矿工需要验证非常多的 nonce，如果每次都从 16M 的 cache 中重新生成，挖矿的效率就太低了，并且其中有大量的重复计算（因为随机选取的 dataset 的元素中有很多是重复的，可能是之前尝试别的 nonce 时用过的）。所以矿工采取空间换时间的策略，保存整个 dataset\n3、轻节点只保存 cache 的原因轻节点由于只验证一个 nonce，验证时直接生成要用到的 dataset 中的元素即可\n和比特币相比，以太坊中验证一个 nonce 的计算量要大很多，但也在可接受范围内\n目前以太坊挖矿还是以 GPU 为主，所以起到了 ASIC resistance\n三、以太坊 POS以太坊没有出现 ASIC 矿机的另一个原因是，以太坊2.0（或以太坊合并）已经于 2022年 从 POW 转向 POS（Power of Stake，权益证明），即按照所占的权益进行投票从而形成共识，而不是挖矿，类似于股份制公司按照股份多少来投票\n这对于 ASIC 厂商是很大的威胁，因为其研发周期很长（1年都算快的），并且研发成本也很高，如果后续不挖矿了，那么所有投入都白费了\n四、预挖矿以太坊采用了 pre-mining（预挖矿），在当初发行货币的时候，预留一部分货币给以太坊的开发者，类似创业公司留一部分股票给创始人和早期员工；而比特币没有采用 pre-mining 的模式，都是挖矿挖出来的\nPre-sale（预售） 就是把 pre-mining 中预留的币，通过出售的方法来换取一些资产，用于加密货币的开发工作\n但有一些人认为，让通用计算设备参与挖矿反而是不安全的，用 ASIC 芯片挖矿才是最安全的，因为购买矿机需要大量的资金，并且只能用于一种加密货币，成本较高\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","ETH"]},{"title":"北大-区块链技术与应用20-ETH挖矿难度调整","url":"/2025/01/18/49-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-ETH%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6%E8%B0%83%E6%95%B4/","content":"比特币是每隔 2016 个区块会调整挖矿难度，目标是维持出块时间在十分钟左右；以太坊是每个区块都可以修改挖矿难度\n一、难度调整公式\n基础部分的作用是维持出块时间在 15秒 左右\nε 是难度炸弹，为了以太坊从 POW 逐步过渡到 POS\n1、基础部分\nx 是难度调整的力度，为父区块的难度除以 2048，再向下取整\n一次性下调难度最多是父区块难度的 99&#x2F;2048\n\n2、难度炸弹\n二、以太坊发展的四个阶段Frontier（前沿）、Homestead（家园）、Metropolis（大都会）和 Serenity（宁静）\n其中 Metropolis 分为 两个子阶段：Byzantium（拜占庭） 和 Constantinople（君士坦丁堡），难度炸弹的回调发生在 Byzantium 阶段\nSerenity（宁静）即以太坊2.0，从 POW 转向 POS\n\nEIP（Ethereum Improvement Proposal）：以太坊改进提案\nBitCoin Improvement Proposal）：比特币改进提案\n三、具体代码实现略，没特别明白，可以参考课程视频（20分）：\nhttps://www.bilibili.com/video/BV1Vt411X7JF?spm_id_from=333.788.player.switch&amp;vd_source=69ac93649ea21c4726fe85f272b6d968&amp;p=20\n比特币中讲过最长合法链，而对于以太坊来说是最难合法链\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","ETH"]},{"title":"北大-区块链技术与应用21-权益证明","url":"/2025/01/19/50-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-POS/","content":"POW（Proof of work，工作量证明）受到的普遍批评是浪费电\n以太坊交易的能耗比比特币低，是因为出块时间更短\n一、POS 基本思想POS（Proof of Stake，权益证明）的基本思想是：按照每个人投入资金的多少来决定收益的分配，这也叫做 virtual mining（虚拟挖矿）\n采用权益证明的货币，在发行前一般会预留一部分货币给开发者，也会出售一部分货币来换取开发所需的资金。将来按照的权益证明的共识机制，按照每个人持有货币的数量进行投票\n二、POS 的好处（1）省去了挖矿的过程，也避免了由此带来的能耗和对环境的影响\n（2）如果有人想发动恶意攻击，需要设法获得该币种一半以上的份额，即发动攻击的资源只能从加密系统内部获得，形成一个闭环。如果有人在初期大量买入，币价大涨，早期投资者可能会跑卖出路（类似于股份制公司遭受恶意收购）\n基于 POW 的共识系统，从某种意义上来说，维护区块链安全的资源不是一个闭环，因为 Block chain is secured by mining. 而 mining 所需的 equipment 是由法币买来的（即加密货币的生态系统之外得到的），这就带来一个问题：虽然加密货币的总市值有了很大的增长，但是和世界经济总量相比仍然是微乎其微的，也就是说发动 51% attack 攻击的资源可以从外界得到、并且是有可能达到的，尤其对于刚发行的小的币种 AltCoin（Alternative coin），这叫做 AltCoin Infanticide（杀婴）\n有些加密货币采用的是一种混合模型，即仍然需要挖矿，但是挖矿难度和占有权益（持有币的数量）相关。这样会导致，系统中持有币数量最多的人，每次挖矿都最容易，所以有些加密货币要求，投入的币会被锁定一段时间，不能重复使用（比如：挖矿时投入一些币降低挖矿难度，等区块发布出来后，投入的币就会被锁定一段时间，下次再挖就不能用了，过一定区块才能继续用），这叫做 Proof of Deposit（存款证明）\n三、早期 POS 遭遇的问题Nothing at stake（两边下注）：参与者通过持有并锁定一定数量的加密货币、而不需要消耗资源（如算力）来生成区块，因此可以同时支持多个分叉上的区块而没有损失\n四、Casper 协议Casper 是以太坊采用的 POS 协议\nCasper the Friendly Finality Gadget（CFG，Casper 友好的最终性工具）：在过渡阶段，需要和工作量证明混合使用，为工作量证明提供 finality，它是一种最终的状态，包含在其中的交易不会被取消\n单纯基于挖矿的交易时可能被回滚的，比如某个交易被写入区块链里，但是有人从前面的区块开始分叉，挖出一条更长的分叉链\nCasper 引入了 validator（验证者）的概念，validator 必须投入一定数量的以太币作为保证金，保证金会被锁定。Validator 的作用是推动系统达成共识，投票决定哪条链是最长合法链，投票权重取决于保证金的数目大小\n具体做法类似于数据库中的 two-phase commit（两阶段提交），第一阶段是 prepare message，第二阶段是 commit message\n每挖出 100个 区块，就作为一个 epoch（纪元），要决定其能否成为 finality 需要进行投票，Casper 规定每一轮投票都要得到 2&#x2F;3 以上验证者（按照保证金金额大小）同意才能通过\n\n实际系统中不区分 prepare message 和 commit message，而且把 epoch 从原来的 100个 区块，减少到了 50个 区块就作为一个 epoch，每个 epoch 只需要一轮投票，投票结果对于上一个区块是 commit message，对于下一个区块是 prepare message，需要连续两轮投票（2个 epoch）都得到 2&#x2F;3 以上的通过，才算有效\n\n验证者参与该过程的好处是，如果其履行职责，可以得到相应的奖励；相反，如果验证者有不良行为被发现，会受到相应的处罚，比如：该投票时不投票，导致系统迟迟无法达成共识，这种情况会扣除其一部分保证金；比如乱投票，给两个有冲突的分叉都投票（两边下注），这种情况会没收其所有保证金（所有扣除或没收都是销毁的模式）\n每个验证者有一定的任期，任期满后会有一个等待期，该等待期是为了让其他节点检举或揭发其是否有不良行为。如果等待期过了，验证者就可以取回当初的保证金和应得的奖励\n五、关于 Casper 的思考Casper 在挖矿的过程中，对其状态做一个 check point（检查点），这是否安全；或者说通过验证者投票达成的 finality 是否可能被推翻？\n假设某个有恶意的组织想发动攻击，如果组织仅仅是矿工，那么就无法推翻已经达成的 finality，因为它是验证者投票的结果；如果组织是验证者，由于需要连续两轮投票都得到 2&#x2F;3 以上的通过才算有效，那么至少有 1&#x2F;3 的验证者两边下注了：正常链得到至少 2&#x2F;3 的票数，非法链也得到至少 2&#x2F;3 的票数，那么至少一共是 2&#x2F;3+2&#x2F;3&#x3D;4&#x2F;3 的票数，即至少 4&#x2F;3-1&#x3D;1&#x2F;3 的验证者都参与了两条链的投票。这 1&#x2F;3 的验证者被发现后，会被没收所有的保证金\nEOS 加密货币（俗称柚子），采用的是 DPOS（Delegated Proof of Stake）协议，先用投票的方式选出 21个 超级节点，再由这些超级节点产生区块，现在已经凉了\n六、POW 的争论很多人认为 POW 挖矿的好处是，提供了把多余电能转化为钱的一种手段，可以有效地化解过剩产能，带动当地经济的发展。因为电能是很难存储、很难传输的，很多大型数据中心要建在电比较便宜的地方，就是因为传输数据比传输电容易，很多比特币的矿场都是建在电力资源丰富的地方\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","ETH","POS"]},{"title":"北大-区块链技术与应用22-智能合约","url":"/2025/01/19/51-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/","content":"一、智能合约概念Smart contract（智能合约）是运行在区块链上的一段代码，代码的逻辑定义了合约的内容\n智能合约的账户保存了合约当前的运行状态\n\nbalance 当前余额\nnonce 交易次数\ncode 合约代码\nstorage 存储，数据结构是一颗 MPT\n\nSodility 是智能合约最常用的语言，语法上与 JavaScript 很接近\n二、Sodility 数据结构\n其中，bid() 后面的 payable 说明该合约账户能接受外部转账。该函数是用来进行竞拍出价的，在出价时需要把以太币发送并存储到合约里，锁定到拍卖结束，因此该函数需要有能接受外部转账的能力\nwithdraw() 函数是在拍卖结束后，未中标的账户可调用该函数，把出价时锁定在智能合约中的以太币取回来\n三、智能合约调用1、一个账户调用一个智能合约外部账户调用智能合约，和转账类似：假设 A 发起一个交易转账给 B，如果 B 是普通用户，则为普通交易；如果 B 是合约账户，那么该调用实际是对 B 合约的调用，具体调用函数是在 data 域中进行说明\n2、一个合约调用另一个合约以太坊中规定，一个交易只有外部账户才能发起，一个合约账户不能主动发起交易。所以在实际中，有两种调用方式\n（1）直接调用通过一个普通账户调用合约 B 中的函数，然后这个函数再调用合约 A 中的函数\n\n（2）使用 address 类型的 call() 函数这种调用和上述不同的是：对于错误处理的不同。在直接调用中，如果被调用的合约执行发生错误，会导致发起调用的合约也跟着一起回滚；而 addr.call() 的方法，如果被调用的合约发生异常，addr.call() 会返回 flase，但发起调用的合约不会抛出异常，而是会继续执行\n\n（3）代理使用 delegatecall()和 call() 很像，区别是 delegatecall() 不需要切换到被调用的合约的环境中去执行，而是在当前合约的环境中执行\n\n3、fallback() 函数\nA 调用 B 的合约，要在转账交易里的 data 域说明调用的是 B 中的哪个函数。如果 A 给合约 B 转了一笔钱，没有说明掉的是哪个函数（或者调的函数在 data 域中不存在），此时缺省就调用 fallback() 函数\n在交易中，转账金额可以为 0，但是汽油费不能为 0，因为没有汽油费，发布该区块的矿工就不会将该笔交易打包进去\n四、智能合约的创建和运行智能合约是由某个外部账户发起一个转账交易，转给 0X0 地址，转账金额为 0，然后把要发布的合约的代码放到 data 域里\n\nJVM 的目的是增强可移植性，EVM 也是类似的思想，通过加一层虚拟机，对智能合约的运行提供一个一致性的平台，所以 EVM 有时叫做 world wide computer，EVM 的寻址空间非常大，为 256 位\n五、汽油费比特币的设计理念很简单，功能有限（比如不支持循环）；而以太坊需要提供一个 Turing-complete Programming Model（图灵完备的编程模型），包含条件控制、循环和递归、数据存储、基本的算术运算功能，但也可能带来问题，比如出现死循环\n一个全节点收到一个对智能合约的调用，不知道该调用执行起来是否会导致死循环，这叫做 Halting Problem（停机问题），这个问题是不可解的，不是 NPC 问题（Non-deterministic Polynomial 的问题，即多项式复杂程度的非确定性问题，NPC 是可解的，只是没有多项式时间的解法）\n以太坊引入了汽油费机制，发起一个对智能合约的调用，就要支付相应的汽油费\n\n当一个全节点收到一个对智能合约的调用时，先按照调用中给出的 gasLimit，算出可能花掉的最大汽油费，然后一次性把汽油费从发起调用的账户上扣除，然后再根据实际执行的情况，算出实际花了多少汽油费（多退）\n不同的指令消耗的汽油费不同，简单的指令（比如加减法），消耗的汽油费是很少的，复杂的指令消耗的汽油费就比较多（比如取哈希）；除了计算量，需要存储状态的指令消耗的汽油费也比较大；只需读取公共指令的命令是免费的\n六、错误处理以太坊中的交易执行起来具有原子性，一个交易要么全部执行、要么完全不执行，不会只执行一部分，既包含普通的转账交易，也包含对智能合约的调用。所以如果在执行智能合约的过程中，出现任何错误，会导致整个交易的执行回滚，退回到开始执行前的状态\n1、出现错误的情况（1）交易执行结束后，没有达到当初的 gas limit，多余的汽油费会被退回到这个账户里；相反的，如果执行一半，gas limit 已经都用完了，这时合约的执行会退回到开始执行之前的状态，且已经消耗掉的汽油费是不退的\n（2）抛出错误的语句 assert（通常判断内部条件），require（通常判断外部条件，比如函数输入是否符合要求），revert（无条件抛出异常，原来是 throw）。sodility 当中没有 try catch 这种结构\n2、嵌套调用如果嵌套调用，一个智能合约调用另外一个智能合约，被调用的智能合约出现错误，不一定会导致发起调用的智能合约也跟着一起回滚，即连锁式回滚\n这取决于调用智能合约的方式，如果这个智能合约是直接调用，就会触发连锁式回滚；如果用 call() 的方式，就不会连锁回滚，而是返回一个 false\n如果只是向一个账户里转账，但该账户为合约账户，该操作就有可能触发对函数的调用，因为如果没有指明哪个函数，仍会调用 fallback() 函数\n七、Block headergasUsed 是该区块里所有交易所消耗的汽油费的总和\n发布区块需要消耗一定的资源，需要对消耗的资源有一个限制（类似比特币区块大小不能超过一兆），gasLimit 是该区块里所有交易实际能够消耗汽油的上限\n比特币区块一兆大小的限制是固定的，但是以太坊的 gasLimit 也有一个上限，但是每个矿工发布区块时，可以对 gasLimit 进行微调，即在上一个区块 gasLimit 的基础上 上调或下调 1&#x2F;1024\n八、思考1、先挖矿还是先执行前置知识：任何对状态的修改，都是在改本地的数据结构，只有当合约执行完了，发布到区块链之后，这些本地的修改才会变成外部可见的、变成区块链上的共识\n假设某个全节点要打包一些交易到一个区块里，这些交易里有一些是对智能合约的调用，那么全节点是先把这些智能合约都执行完再去挖矿，还是应该先挖矿、获得记账权之后，再执行合约？\n答案是先执行智能合约，因为不先执行，更新三颗树（状态、交易、收据），就无法得到三颗树的根哈希，也就无法通过 block header 去挖矿\n2、是否会存在故意不验证的全节点汽油费的设置是对于矿工执行智能合约所消耗资源的一种补偿，但是这种补偿只有最终挖到矿的矿工才能得到\n如果某个区块不验证新发布的交易，不去执行新发布的区块，也就没办法更新本地的三棵树，以后就没办法再发布区块\n3、合约执行错误能否上链如果智能合约执行的过程中出现了错误，也要发布到区块链上，否则汽油费扣不掉。也就是说发布到区块链上的交易不一定都是成功执行的\n4、智能合约是否支持多线程多核处理器很普遍，但是智能合约不支持多核并行处理，sodility 没有支持多线程的语句，原因是：以太坊是一个交易驱动的状态机，状态机必须是完全确认性的，给定同一组输入，产生的输出&#x2F;转移到的下一个状态必须是完全确定的。因为所有的全节点都得执行同一组操作，达到同一个状态，如果不确定的话，三个树的根哈希值根本对不上。多线程的问题是多个核对内存访问顺序不同的话，执行结果有可能不确定\n除了多线程之外，其他可能造成执行结果不确定的操作也都不支持，比如：产生随机数，所以以太坊中的智能合约没办法产生真正意义下的随机数，只能用伪随机数\n九、收据树下面是 Receipt 的数据结构：\n\n每个交易执行完之后会形成一个收据，status 表示交易的执行情况\n十、智能合约可以获得的信息1、智能合约可以获得的区块信息\n2、智能合约可以获得的调用信息\nmsg.data 说明了调用哪个函数，和该函数的参数取值\nmsg.gas 是剩余的汽油费，决定了还能做那些操作，想要再调用其他合约，前提是有足够的汽油费剩余\nmsg.sig 是 msg.data 的前四个字节，即函数标识符，表示调用的是哪个函数\nnow 是当前区块的时间戳，等同于图区块信息中的 block.timestamp\n消息发送者 msg.sender 和 交易发起者 tx.origin 是不一样的\n\n比如上述交易，对于 f2，msg.sender 是 C1，但是 tx.origin 是 A\n3、地址类型\naddr.balance 是成员变量，剩余的都是成员函数\naddr.transfer(amount) 是当前合约往地址 addr 转入 amount 以太币，转入的地址是 addr，转出的地址是该合约地址\naddr.call() 合约账户发起对 addr 这个合约的调用\n4、三种发送 ETH 的方式addr.transfer(amount)addr.send(amount) return (bool)addr.call.value(amount)()\n\n（1）transfer 会导致连锁性的回滚；失败时抛出异常；为要调用的合约提供 2300 汽油费（少量）\n（2）send 在失败时会返回一个 false；不会导致连锁式回滚；为要调用的合约提供 2300 汽油费（少量）\n（3）call 在失败时会返回一个 false；不会导致连锁式回滚；会将当前调用剩下的所有汽油都发送给要调用的合约，合约后续会执行什么操作当前账户无法控制\n十一、智能合约拍卖实例这部分结合智能合约拍卖实例，讲述可能存在的安全漏洞（比如重组攻击），代码截图较多，视频链接如下（1小时31分25秒）：\nhttps://www.bilibili.com/video/BV1Vt411X7JF/?spm_id_from=333.788.player.switch&amp;vd_source=69ac93649ea21c4726fe85f272b6d968&amp;p=22\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","ETH","智能合约"]},{"title":"北大-区块链技术与应用23-The DAO","url":"/2025/01/21/52-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-The%20DAO/","content":"\nDAO（Decentralized Autonomous Organization）\nDAC（Decentralized Autonomous Corporation）\n\nThe DAO 事件是以太坊历史上一个重要的里程碑，涉及到智能合约的漏洞、重组攻击、以及随后的硬分叉。这一事件导致以太坊网络分裂成了两个不同的区块链：以太坊（ETH）和以太坊经典（ETC）\n1、背景The DAO 是一个基于以太坊的去中心化投资基金，旨在为各种项目提供资金，在 2016年4月 成功筹集了超过 1.5亿美元 的以太币，成为当时最大的众筹项目。然而，其智能合约存在一个安全漏洞，并终导致了黑客的攻击\n拆分（splitDAO），用于建立子基金（childDAO），一般用于小众项目，会将这些账户中的代币全部换回以太币、并打入子基金中。极端情况下，单个投资者可以成立一个子基金，用于取回个人的收益（注意：成立的子基金具有 28天 的锁定期）\n2、漏洞与重组攻击有问题的代码段如下所示：\n\n正确的操作顺序是先把账户清零 balance[msg.sender]=0，然后再把钱还给调用该函数的人 withdrawRewardFor(msg.sender)，并对 The DAO 中的总金额减少相应的数量 totalSupply -= balances[msg.sender]\n攻击者利用该漏洞进行了重组攻击，通过递归调用（Reentrancy）的机制，在第一次调用合约未完成之前 再次调用原合约，从而重复提取资金，导致约 5000万美元 被转移到攻击者的合约账户中\n3、尝试修复：软分叉在 28天 的锁定期内尝试修复，第一步锁定黑客的账户，第二步清退 The DAO 基金上的钱\n以太坊发布了软件升级，新增了一条规则：凡是和 The DAO 基金上的账户相关的，不许做任何交易。大多数矿工都升级了该软件\n这属于软分叉，因为新节点不认（包含和 The DAO 基金账户相关的交易）旧节点，而旧节点认可新节点\n但是升级后的软件存在另一个 bug：判断和 The DAO 基金上的账户相关的交易都是非法交易，不予执行，此时没有收取汽油费。这导致了 Denial-of-service Attack（DOS 攻击）：造成大量恶意攻击者不断发放非法交易，浪费矿工的资源\n4、硬分叉的实施以太坊发布了软件升级，把 The DAO 上的所有基金强行转到另一个新的智能合约上，该智能合约的唯一功能就是退钱（将代币退回为以太币）\n这属于硬分叉，因为本来转账需要有合法的签名，但是用该合约规定，挖到第 192万 个区块时，自动执行该转账交易，不需要任何签名。因此旧矿工不会认可该区块，因为没有合法签名属于非法交易\n5、分裂成 ETH 和 ETC硬分叉之后的新链仍然称作 ETH，旧链上挖出的币叫做 ETC（Etherum Classic）\n后来由于新旧链并行会引发重放攻击，在两条链上分别加上了不同的 Chain ID 用于区分\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","ETH","智能合约"]},{"title":"北大-区块链技术与应用24-反思","url":"/2025/01/21/53-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%8F%8D%E6%80%9D/","content":"一、智能合约Is smart contract really smart?\nSmart contract is anything but smart.\n有人认为应该把智能合约叫做自动合约，ATM 就是一种自动合约，实际上来说，智能合约是一种代码合同\n二、不可篡改性Irrevocability is a double edged sword（区块链的不可篡改性是一把双刃剑）\n三、真的不可篡改不存在Nothing is irrevocable.\n四、Sodility 语言Is sodility the right programming language?\n有人建议使用函数式编程语言，杜绝 fallback() 函数的问题\n五、开源Many eyeball fallacy（错误认识），表示开源代码仍然存在安全漏洞\n六、去中心化What does decentralization mean?\n以太坊的硬分叉能够实现，不是因为团队强迫，而是因为绝大多数矿工升级了软件；并且还有少部分矿工留在旧链，这也是他们的自由\n所以去中心化不是全自动化，也不是说制定的规则不能修改，而是说对规则的修改要用去中心化的方法来完成，在区块链的世界里是用挖矿进行投票\n七、分叉分叉不一定是坏事，分叉是去中心化和民主的一种体现\n八、decentralized ≠ distributed\n一个去中心化的系统一定是分布式的，但是分布式的系统不一定是去中心化的，比如：Google 的 search engine 背后有几十万台服务器。在一个分布式的平台上，可以运行中心化的应用，也可以运行去中心化的应用\n比特币和以太坊都是交易驱动的状态机（state machine），其特点是，让系统中几千台机器重复做同一套动作、付出很大的代价，来维持状态的一致性\n这并不是分布式系统常用的工作模式，大多数分布式系统是让每台机器做不同的事情，再把各台机器的工作结果汇总、得到最后的结果，目的是使处理速度更快\n而 state machine 的目的不是为了处理速度快，而是为了容错。状态机最早的应用场景是 mission critical application（关键任务应用，比如：airtraffic control, stock exchange, space shuttle），代价是效率很低\n不要把以太坊上的智能合约、EVM 平台 当作是大规模计算或存储的服务，这么做不仅速度很慢，而且汽油费很贵。智能合约是编写控制逻辑的，只有那些需要在互不信任的实体中间建立共识的操作，才需要写在智能合约里\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","ETH","智能合约"]},{"title":"北大-区块链技术与应用25-美链","url":"/2025/01/21/54-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-%E7%BE%8E%E9%93%BE/","content":"BeautyChain（美链）\nIPO（Initial Public Offering）\nICO（Initial Coin Offering，首次发行的货币），它们没有自己的区块链，而是以智能合约的形式运行在以太坊的 EVM 平台上。以太坊平台的出现，为各种代币的发行提供了很大的方便\n发行代币的智能合约对应的是以太坊状态树中的一个节点，该节点有其账户余额，相当于该智能合约一共有多少个以太币；该账户中有多少代币，保存为智能合约账户的存储树上的变量，账户中代币的发行、转让、销毁都是通过调用智能合约中的函数实现的。它不像以太坊那样需要通过挖矿来维护一个底层的基础链，每种代币可以制定自己的发行规则\nERC 20（Ethereum Request for Comments，以太坊征求意见）是以太坊上发行代币的一个标准，规范了所有发行代币的合约应该实现的功能和遵循的接口\n美链被攻击的示例，告诉我们：在计算时，一定要考虑溢出的问题，sodility 有一个专门的 safeMath 库，计算时会检测是否溢出\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","ETH"]},{"title":"北大-区块链技术与应用26-课程总结","url":"/2025/01/22/55-%E5%8C%97%E5%A4%A7%E5%8C%BA%E5%9D%97%E9%93%BE-%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/","content":"Information can flow freely on the Internet, but payment cannot.\nSoftware is eating the world.\nDemocracy is the worst form of Government except for all those other forms that have been tried from time to time.\nDecentralization isn’t always a good thing.\nIf the business model is bad, it’s still bad on the Internet.\n","categories":["Web3 - 北大肖臻-区块链技术与应用"],"tags":["web3","ETH"]},{"title":"React1","url":"/2025/01/22/56-React1/","content":"一、项目的创建1、创建方式（1）使用官方的脚手架npx create-react-app &lt;projectname&gt;\n\n只做 React 基本的搭建和构建，没有路由和状态管理，项目使用 Webpack 构建\n（2）使用一些市场上的集成脚手架官方脚手架提供的项目模板非常简单，因此也有很多集成的脚手架，比如：umi\n这类脚手架创建的项目会集成很多功能，比如：路由、mock\n2、两个核心库（1）React创建一个 React 对象，提供 React 的各个功能\n（2）React-dom提供一些 DOM 操作方法，用于把 React 创建出来的 React 对象 挂载到真正的 html DOM 中，或者从 HTML DOM 中卸载，作用类似于 Vue 的 mount\n二、React 组件 和 JSX1、组件分类（1）函数组件function Hello() &#123;    return &lt;div&gt;hello&lt;/div&gt;&#125;\n\nclass 组件（老版本）class Hello extends React.Component &#123;    render () &#123;        return &lt;div&gt;hello&lt;/div&gt;    &#125;&#125;\n\n2、JSX 特点（1）直接在 JS 中混用React 项目利用 Babel 做了对 JS 的编译，所以能直接在 JS 里写 JSX\n（2）写法接近 JSJSX 几乎和 JS 一样，不同点在于，可以在 JS 里写 HTML，且写在 JS 里的 HTML 最后会被编译成一个 JS 对象，也可以用 React 自带 createElement 创建这个对象\nfunction FnHello() &#123;  // return &lt;div&gt;hello&lt;/div&gt;  return React.createElement(&quot;div&quot;, [], &quot;Hello&quot;)&#125;\n\n3、JSX 里面渲染不同内容的区别（1）字符串、数字：直接渲染\n（2）对象：只能渲染 element 对象，否则会报错\n（3）数组：把数组中的每一项单独渲染\n（4）表达式：运行表达式\n（5）方法：无法渲染\n（6）布尔值，undifined, null：不渲染\nimport React from &#x27;react&#x27;;function App() &#123;  // 新版本 - vue3 组合式 API  // 首字母一定要大写，区分组件和方法  function FnHello() &#123;    // return &lt;div&gt;hello&lt;/div&gt;    return React.createElement(&quot;div&quot;, [], &quot;Hello&quot;)  &#125;  // 老版本 - vue2 选项式 API  class ClassHello extends React.Component &#123;    constructor(props) &#123;      super(props)    &#125;    render() &#123;      return &lt;div&gt;hello class&lt;/div&gt;    &#125;  &#125;  console.log(&quot;FnHello&quot;, FnHello) // 方法  console.log(&quot;&lt;FnHello/&gt;&quot;, &lt;FnHello/&gt;) // React element（虚拟 DOM）    let eleObj = FnHello()  let com1 = &lt;ClassHello&gt;&lt;/ClassHello&gt;    let obj = &#123; a: 123 &#125;  let arr = [com1, 5, &#x27;abc&#x27;]  return (    &lt;div className=&quot;App&quot;&gt;      &lt;FnHello&gt;&lt;/FnHello&gt;      &lt;ClassHello&gt;&lt;/ClassHello&gt;      -------      &#123;eleObj&#125;      &#123;com1&#125;      -------      &#123;&quot;Hello Str&quot;&#125;      &#123;123&#125;      &#123;/* &#123;obj&#125; 报错 */&#125;      &#123;/* &#123;FnHello&#125; 报错 */&#125;      &#123;arr&#125;      &#123;1+2+3+4&#125;      &#123;true?&lt;FnHello&gt;&lt;/FnHello&gt;:&#x27;123&#x27;&#125;      &#123;/* &#123;false&#125; 不展示 */&#125;      &#123;/* &#123;undefined&#125; 不展示 */&#125;      &#123;/* &#123;null&#125; 不展示 */&#125;    &lt;/div&gt;  );&#125;export default App;\n\n三、React 的时事件绑定1、规则模式（1）类似于原生，on+方法名（首字母大写，为了和原生区分）\n（2）一定要赋值给事件一个方法\n2、特别注意的问题（1）不作处理的情况下，this 会指向 undefined\n（2）事件绑定的必须是一个方法，不要直接调用方法，否则只会在页面初次渲染时执行\n3、事件绑定其他操作（1）传递参数\n（2）获取事件对象\n（3）阻止默认行为，冒泡等\nimport React from &#x27;react&#x27;;class App extends React.Component &#123;  /**   * 1、方法调用使用 bind 规定 this（可以）   * 2、写成一个匿名箭头函数   * 3、方法本身写成箭头函数（可以）   */  f1() &#123;    console.log(&quot;this&quot;, this) // 不用 bind 的话，默认指向 undefined  &#125;  f2 = () =&gt; &#123;    console.log(&quot;this&quot;, this) // 使用箭头函数  &#125;  f3(a, b) &#123;    console.log(&quot;a + b =&quot;, a + b)  &#125;  f4 = (a, b) =&gt; &#123;    console.log(&quot;a + b =&quot;, a + b)  &#125;  f5(a) &#123;    console.log(&quot;a&quot;, a)  &#125;  f6(a, b, e) &#123;    // 不是原生的事件对象（在 nativeEvent 中），而是合成的事件对象    console.log(&quot;e&quot;, e)    /**     *     event.stopPropagation(); // 原生阻止冒泡     *     event.preventDefault(); // 原生阻止默认     */    e.stopPropagation(); // 阻止冒泡    e.preventDefault(); // 阻止默认  &#125;  render() &#123;    return &lt;div className=&quot;App&quot;&gt;      &lt;div onClick=&#123;() =&gt; &#123;        console.log(1)      &#125;&#125;&gt;123&lt;/div&gt;      &lt;div onClick=&#123;this.f1.bind(this)&#125;&gt;456&lt;/div&gt;      &lt;div onClick=&#123;this.f2&#125;&gt;789&lt;/div&gt;      &#123;/* 不能传方法的调用 */&#125;      &lt;div onClick=&#123;this.f2()&#125;&gt;error&lt;/div&gt;      &#123;/* 箭头函数改变 this 指向 */&#125;      &lt;div onClick=&#123;() =&gt; &#123;        console.log(&quot;this&quot;, this)      &#125;&#125;&gt;匿名1&lt;/div&gt;            &#123;/* 普通函数不行 */&#125;      &lt;div onClick=&#123;function () &#123;        console.log(&quot;this&quot;, this)      &#125;&#125;&gt;匿名2&lt;/div&gt;      &#123;/* 事件传参 */&#125;      &#123;/* 1、普通函数.bind() + 普通函数 */&#125;      &lt;div onClick=&#123;this.f3.bind(this, 1, 2)&#125;&gt;传参1&lt;/div&gt;      &#123;/* 2、箭头函数 + 箭头函数 */&#125;      &lt;div onClick=&#123;() =&gt; this.f4(1, 2)&#125;&gt;传参2&lt;/div&gt;      &#123;/* 获取事件对象 */&#125;      &#123;/* 1、不传参 */&#125;      &lt;div onClick=&#123;this.f5.bind(this)&#125;&gt;事件1&lt;/div&gt;      &#123;/* 2、传参 */&#125;      &lt;div onClick=&#123;this.f6.bind(this, 1, 2)&#125;&gt;事件2&lt;/div&gt;    &lt;/div&gt;  &#125;&#125;export default App;\n\n四、React 中的响应式数据1、类组件响应式数据响应式数据定义在类的 state 属性中\nclass ClassState extends React.Component &#123;    constructor(props) &#123;        super(props)        this.state = &#123;            // 这里写响应式数据，类似 vue 的 data 方法返回的对象            a: 123        &#125;    &#125;&#125;\n\n2、React 响应式原理（1）React 不能像 Vue 一样直接修改触发更新\n（2）React 修改能改值，但无法触发更新，因为 React 不像 Vue 监听了 get 和 set，而是在调用 setState 时调用 React 的更新操作\n3、setState 关键点（1）通过浅合并来修改数据\n（2）调用 setState 方法会触发更新，修改 state 不会触发更新\n（3）setState 方法是异步的，如果要获取修改后的值，需要在 setState 的第二个参数里获取\n（4）setState 方法多次修改，会合并为一次，统一更新\n（5）setState 返回会触发更新，不管是否有修改，这导致：重复修改为相同的值也会让组件更新\n（6）一定不要在 render 里直接 setState\n4、PureComponent 下对于对象和数组的修改PureComponent 会根据 state 是否改变来决定是否更新，而对于对象、数组这种引用类型判断是否改变的原理是看内存地址，而不是内容\n因此在 PureComponent 下修改对象和数组，需要声明一个新对象赋值。所以一般不直接操作原对象，而是先拷贝一份，再进行操作\nimport React from &#x27;react&#x27;;// 解决了普通 component 的一些问题，比如：更新为同一个值仍然重新渲染class App extends React.PureComponent &#123;  // 老写法  // constructor(props) &#123;  //   super(props)  //   this.state = &#123;  //     ...  //   &#125;  // &#125;  // 新写法  state = &#123;    a: 0,    b: 1,    c: &#123;      c1: 123,      c2: 999    &#125;,    arr: [1, 2, 3]  &#125;  addA = () =&gt; &#123;    // 常用    this.setState(&#123;      a: this.state.a + 1    &#125;)    // 也可以更新    // this.state.a += 1    // this.setState(&#123;&#125;)    // 函数形式，不常用    // this.setState((state) =&gt; &#123;    //   return &#123;    //     a: state.a + 1    //   &#125;    // &#125;)    this.setState(&#123;      a: this.state.a + 1    &#125;)    console.log(&quot;this.state.a&quot;, this.state.a)  &#125;  merge = () =&gt; &#123;    // 浅合并，只合并外层    // 为异步操作    this.setState(&#123;      a: 1,      b: 2,      c: &#123;        ...this.state.c,        c1: 9      &#125;    &#125;, () =&gt; &#123;      // 回调中才能获取更新后的值      console.log(&quot;this.state0&quot;, this.state)    &#125;)    console.log(&quot;this.state1&quot;, this.state)  &#125;  refresh = () =&gt; &#123;    this.setState(&#123;      a: 1    &#125;)    this.setState(&#123;      b: 2    &#125;)    // 以上等同于    // Object.assign(this.state, &#123;a: 1&#125;, &#123;b: 2&#125;)  &#125;  // 数组和对象，是通过内存地址判断是否改变的  addArr = () =&gt; &#123;    let arr_ = [...this.state.arr]    arr_.push(4)    this.setState(&#123;      // arr: this.state.arr      arr: arr_    &#125;, () =&gt; &#123;      console.log(&quot;this.state.arr&quot;, this.state.arr)    &#125;)    this.setState(&#123;      c: &#123;        ...this.state.c,        c1: 8888      &#125;    &#125;, () =&gt; &#123;      console.log(&quot;this.state.c&quot;, this.state.c)    &#125;)  &#125;  render() &#123;    console.log(123)    // 不能在 render 中使用 this.setState，会死循环    return &lt;div className=&quot;App&quot;&gt;      &#123;this.state.a&#125;      &lt;button onClick=&#123;() =&gt; this.addA()&#125;&gt;加1&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; this.merge()&#125;&gt;合并&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; this.refresh()&#125;&gt;更新&lt;/button&gt;      &#123;this.state.arr&#125;      &lt;button onClick=&#123;() =&gt; this.addArr()&#125;&gt;数组增加&lt;/button&gt;    &lt;/div&gt;  &#125;&#125;export default App;\n\n五、条件渲染和列表循环React 没有 Vue 一样的指令，一切操作本质上是通过运算生成不同的内容，再渲染得到不同的页面\nimport React from &#x27;react&#x27;;class App extends React.PureComponent &#123;  state = &#123;    show: true,    originArr: [1, 2, 3] // [1, 2, 3] =&gt; [&lt;div&gt;1&lt;/div&gt;, &lt;div&gt;2&lt;/div&gt;, &lt;div&gt;3&lt;/div&gt;]  &#125;  f1() &#123;    if(this.state.show) &#123;      return &lt;div&gt;div1&lt;/div&gt;    &#125;    return &quot;&quot;  &#125;  getArr() &#123;    let newArr = []    this.state.originArr.forEach((item) =&gt; &#123;      newArr.push(&lt;div&gt;&#123;item&#125;&lt;/div&gt;)    &#125;)    console.log(&#x27;newArr&#x27;, newArr)    return newArr  &#125;  addData = () =&gt; &#123;    let _arr = [...this.state.originArr]    _arr.push(Math.random() * 10)    this.setState(&#123;      originArr: _arr    &#125;)  &#125;  render() &#123;    return &lt;div className=&quot;App&quot;&gt;      &lt;div&gt;条件渲染&lt;/div&gt;      &#123;/* &#123;this.state.show ? &lt;div&gt;div1&lt;/div&gt;: &quot;&quot;&#125; */&#125;      &#123;this.f1()&#125;      &lt;button onClick=&#123;() =&gt; &#123;        this.setState(&#123;          show: !this.state.show        &#125;)      &#125;&#125;&gt;&#123;this.state.show ? &quot;隐藏&quot; : &quot;显示&quot;&#125;&lt;/button&gt;      &lt;div&gt;列表渲染&lt;/div&gt;      &#123;/* &#123; this.getArr() &#125; */&#125;      &#123;        this.state.originArr.map((item) =&gt; &#123;          return &lt;div key=&#123;item&#125;&gt;&#123;item&#125;&lt;/div&gt;        &#125;)      &#125;      &lt;button onClick=&#123;() =&gt; this.addData()&#125;&gt;添加&lt;/button&gt;    &lt;/div&gt;  &#125;&#125;export default App;\n\n六、表单绑定React 中很多思路都是按原生的操作去做的，表单绑定也是如此\n原生表单获取表单输入值，可以通过监听 input、change 等事件，然后获取 e.target.value\n如果要设置表单的值，通常设置 value 属性，如果是选择框则是 checked 属性\nimport React from &#x27;react&#x27;;class App extends React.PureComponent &#123;  state = &#123;    inputValue: &quot;&quot;,    checkedArr: [&quot;c2&quot;]  &#125;  handleChecked = (e) =&gt; &#123;    let arr = [...this.state.checkedArr]    if(e.target.checked) &#123;      arr.push(e.target.value)    &#125;    else &#123;      arr.splice(arr.indexOf(e.target.value), 1)    &#125;    this.setState(&#123;      checkedArr: arr    &#125;)  &#125;    render() &#123;    return &lt;div className=&quot;App&quot;&gt;      &#123;/* &lt;input onBlur=&#123;&#125; /&gt; */&#125;      &#123;/* &lt;input onChange=&#123;&#125; /&gt; */&#125;      &lt;input value=&#123;this.state.inputValue&#125; onInput=&#123;(e) =&gt; &#123;        this.setState(&#123;          inputValue: e.target.value        &#125;)      &#125;&#125; /&gt;      &#123; this.state.inputValue &#125;      &#123;/* checkbox */&#125;      &lt;input checked=&#123;this.state.checkedArr.indexOf(&quot;c1&quot;)!==-1&#125; type=&quot;checkbox&quot; value=&quot;c1&quot; name=&quot;choose&quot; onChange=&#123;this.handleChecked&#125; /&gt;      &lt;input checked=&#123;this.state.checkedArr.indexOf(&quot;c2&quot;)!==-1&#125; type=&quot;checkbox&quot; value=&quot;c2&quot; name=&quot;choose&quot; onChange=&#123;this.handleChecked&#125; /&gt;      &lt;input checked=&#123;this.state.checkedArr.indexOf(&quot;c3&quot;)!==-1&#125; type=&quot;checkbox&quot; value=&quot;c3&quot; name=&quot;choose&quot; onChange=&#123;this.handleChecked&#125; /&gt;      &#123; this.state.checkedArr &#125;    &lt;/div&gt;  &#125;&#125;export default App;\n\n七、props 和组件间传值、插槽props 是 React 中的核心，一切写在组件上的属性和子节点都被划为 props\nReact 父子传值，插槽全都基于 props，不像 Vue 有事件监听、emit、专门的插槽 这类东西\n/* App.js */import React from &#x27;react&#x27;;import Son from &#x27;./Son&#x27;;class App extends React.PureComponent &#123;  state = &#123;    // msg: 123 // 抛出类型错误    msg: &quot;app message&quot;  &#125;  changeMsg = (sonMsg) =&gt; &#123;    console.log(&quot;sonMsg&quot;, sonMsg)    this.setState(&#123;      msg: sonMsg    &#125;)  &#125;    render() &#123;    return &lt;div className=&quot;App&quot;&gt;      I&#x27;m App.      &lt;br&gt;&lt;/br&gt;      &#123;/* 具名插槽 */&#125;      &#123;/* 在插槽中显示子组件内容 */&#125;      &#123;/* &lt;Son msg=&#123;this.state.msg&#125; a=&#123;&lt;div&gt;I&#x27;m slot2&lt;/div&gt;&#125; scopeslot=&#123;(scope) =&gt; &#123;        return &lt;div&gt;scope: &#123;scope&#125;&lt;/div&gt;      &#125;&#125;&gt;        &lt;div&gt;I&#x27;m slot&lt;/div&gt;      &lt;/Son&gt; */&#125;      &lt;Son msg=&#123;this.state.msg&#125; changeMsg=&#123;this.changeMsg&#125;&gt;      &lt;/Son&gt;    &lt;/div&gt;  &#125;&#125;export default App;\n\n/* Son.js */import React from &quot;react&quot;import proptypes from &quot;proptypes&quot;class Son extends React.PureComponent &#123;    // constructor(props) &#123;    //     super(props)    //     this.state = &#123;    //         sonMsg: &quot;hello&quot;    //     &#125;    // &#125;    state = &#123;        sonMsg: &quot;son message&quot;    &#125;    render() &#123;        // console.log(&quot;this.props&quot;, this.props)        // return &lt;div&gt;        //     &#123;/* 具名插槽 */&#125;        //     &#123;this.props.a&#125;        //     &#123;&quot;this.props.msg: &quot; + this.props.msg&#125;        //     &lt;br&gt;&lt;/br&gt;        //     &#123;&quot;this.state.sonMsg: &quot; + this.state.sonMsg&#125;        //     &lt;br&gt;&lt;/br&gt;        //     I&#x27;m Son.        //     &#123;this.props.children&#125;        //     &#123;/* 在插槽中显示子组件内容 */&#125;        //     &#123;this.props.scopeslot(this.state.sonMsg)&#125;        // &lt;/div&gt;        return &lt;div&gt;            &#123;this.props.msg&#125;            &lt;button onClick=&#123;() =&gt; this.props.changeMsg(&quot;hello, father&quot;)&#125;&gt;修改&lt;/button&gt;        &lt;/div&gt;    &#125;&#125;// Son.propTypes = &#123;//     msg: function(props) &#123;//         if (typeof props.msg !== &quot;string&quot;) &#123;//             throw new Error(&quot;msg must be a string&quot;)//         &#125;//     &#125;// &#125;// proptypes 库Son.propTypes = &#123;    msg: proptypes.string&#125;Son.defaultProps = &#123;    msg: &quot;default&quot;&#125;export default Son;\n\n八、React 样式设置1、class 类名设置（1）必须写为 className\n（2）类名和样式写在 css 文件里\n（3）必须接受一个字符串\n2、style 内联不能像原生一样写成字符串，必须写成对象\n/* App.js */import &#x27;./App.css&#x27;;import React from &#x27;react&#x27;;import Son from &#x27;./Son&#x27;;class App extends React.PureComponent &#123;  state = &#123;    msg: &quot;app message&quot;  &#125;    render() &#123;    return &lt;div&gt;      &lt;div className=&quot;father&quot; style=&#123;        &#123;          background: &quot;yellow&quot;,          fontSize: &quot;25px&quot;        &#125;      &#125;&gt;father&lt;/div&gt;      &lt;Son&gt;&lt;/Son&gt;    &lt;/div&gt;  &#125;&#125;export default App;\n\n/* Son.js */import React from &quot;react&quot;import proptypes from &quot;proptypes&quot;// import &quot;./Son.css&quot;import sonStyle from &quot;./Son.module.css&quot;// console.log(&quot;sonStyle&quot;, sonStyle)// 组件名 - .module.css// vue style scoped// import classnames from &quot;classnames&quot; // 非模块化import classnames from &quot;classnames/bind&quot; // 模块化let bindClassnames = classnames.bind(sonStyle) // 模块化方法let str = classnames(&#123;    son: true,    son1: true&#125;)console.log(&quot;str&quot;, str)// 更方便操作类名的库 - classnames// 本质是生成一个字符串class Son extends React.PureComponent &#123;    state = &#123;        sonMsg: &quot;son message&quot;,        hasSon1: false    &#125;    render() &#123;        return &lt;div&gt;            &#123;/* 取出新的 class 名 */&#125;            &lt;div className=&#123;sonStyle.son + &quot; &quot; + sonStyle.son1&#125;&gt;son1&lt;/div&gt;                        &#123;/* classnames 库 */&#125;            &#123;/* 非模块化 */&#125;            &lt;div className=&#123;classnames(&#123;                son: true,                son1: this.state.hasSon1            &#125;)&#125;&gt;son2&lt;/div&gt;            &#123;/* 模块化 */&#125;            &lt;div className=&#123;bindClassnames(&#123;                son: true,                son1: this.state.hasSon1            &#125;)&#125;&gt;son3&lt;/div&gt;        &lt;/div&gt;    &#125;&#125;// proptypes 库Son.propTypes = &#123;    msg: proptypes.string&#125;Son.defaultProps = &#123;    msg: &quot;default&quot;&#125;export default Son;\n\n/* App.css */.father &#123;  color: red&#125;\n\n/* Son.module.css */.son &#123;    color: blue&#125;.son1 &#123;    background-color: bisque;&#125;\n\n九、React 生命周期1、生命周期图示\n2、严格模式严格模式只在开发模式下生效，生产上线时会去除，作用如下：\n（1）检测危险操作（比如：使用已经废弃 api 和不推荐的 api）\n（2）把生命周期执行两次，来检测额外副作用（比如：render）\n/* index.js */const root = ReactDOM.createRoot(document.getElementById(&#x27;root&#x27;));root.render(  // 严格模式  &lt;React.StrictMode&gt;    &lt;App /&gt;  &lt;/React.StrictMode&gt;);\n\n3、React 和 Vue 更新（1）VueVue 是在 get 和 set 里触发更新，在 get 部分会进行依赖收集的操作\n在更改数据后，只会更新用到该数据的地方，做到最小的更新范围\n（2）ReactReact 的更新是调用方法时触发的，没有依赖收集的过程\n所以会更新整个组件树、同时更新子组件，即使更新的数据和子组件没有关系\n/* App.js */import &#x27;./App.css&#x27;;import React from &#x27;react&#x27;;import Son from &#x27;./Son&#x27;;class App extends React.Component &#123;  constructor(props) &#123;    super(props)    this.state = &#123;      msg: &quot;app message&quot;    &#125;    console.log(&quot;constructor&quot;)  &#125;  // derived 派生的  static getDerivedStateFromProps(props, state) &#123;    console.log(&quot;derived&quot;)    console.log(&quot;derived-props&quot;, props)    console.log(&quot;derived-state&quot;, state)    return null  &#125;  // 优化生命周期（只能在 React.Component 中使用，因为 PureComponent 已经实现了）  shouldComponentUpdate(props, state) &#123;    console.log(&quot;shouldUpdate&quot;)    // console.log(&quot;shouldUpdate-props&quot;, props)    console.log(&quot;shouldUpdate-this.state 修改前&quot;, this.state)    console.log(&quot;shouldUpdate-state 修改后&quot;, state)    // 实现 PureComponent 优化    for(let item in this.state) &#123;      if(this.state[item] != state[item]) &#123;        return true      &#125;    &#125;    return false  &#125;    // 一定不要修改数据  render() &#123;    console.log(&quot;render&quot;)    return &lt;div&gt;      &lt;div className=&quot;father&quot;&gt;        &lt;div&gt;&#123;this.state.msg&#125;&lt;/div&gt;        &lt;button onClick=&#123;() =&gt; &#123;          this.setState(&#123;            msg: &quot;hello&quot;          &#125;)        &#125;&#125;&gt;修改msg&lt;/button&gt;        &lt;Son&gt;&lt;/Son&gt;      &lt;/div&gt;    &lt;/div&gt;  &#125;  // 类似 Vue mounted  componentDidMount() &#123;    console.log(&quot;didMount&quot;)  &#125;  // 类似 Vue updated  componentDidUpdate() &#123;    console.log(&quot;didUpdate&quot;)  &#125;  // 类似 Vue unmounted  componentWillUnmount() &#123;    console.log(&quot;willUnmount&quot;)  &#125;&#125;export default App;\n\n/* Son.js */import React from &quot;react&quot;import proptypes from &quot;proptypes&quot;// 如果使用 Component，父组件更新会导致子组件更新，即使子组件数组没变化class Son extends React.Component &#123;    state = &#123;        sonMsg: &quot;son message&quot;,        hasSon1: false    &#125;    render() &#123;        console.log(&quot;son render&quot;)        return &lt;div&gt;        &lt;/div&gt;    &#125;&#125;// proptypes 库Son.propTypes = &#123;    msg: proptypes.string&#125;Son.defaultProps = &#123;    msg: &quot;default&quot;&#125;export default Son;\n","categories":["React - 基础课程"],"tags":["React"]},{"title":"React2","url":"/2025/01/24/57-React2/","content":"十、实战-制作一个增删改查列表/* App.js */import &quot;./App.css&quot;;import React from &quot;react&quot;;import axios from &quot;axios&quot;;import Pop from &quot;./Pop&quot;;// 状态列表let arr = [  &#123;    text: &quot;进行中&quot;,    color: &quot;blue&quot;,  &#125;,  &#123;    text: &quot;已完成&quot;,    color: &quot;green&quot;,  &#125;,  &#123;    text: &quot;已延期&quot;,    color: &quot;red&quot;,  &#125;,];class App extends React.Component &#123;  state = &#123;    tableArr: [],    searchParams: &#123;      dateValue: &quot;&quot;,      nameValue: &quot;&quot;,      statusValue: 0,    &#125;,    popForm: &#123;      dateValue: &quot;&quot;,      nameValue: &quot;&quot;,      statusValue: 0,    &#125;,    popShow: false,    popTitle: undefined,    // confirmFn: undefined,  &#125;;  componentDidMount() &#123;    this.getList();  &#125;  // 查询列表  getList(params) &#123;    axios(&#123;      url: &quot;http://localhost:8000/list&quot;,      method: &quot;get&quot;,      params,    &#125;).then((res) =&gt; &#123;      console.log(&quot;res&quot;, res);      this.setState(&#123;        tableArr: res.data.data,      &#125;);    &#125;);  &#125;  // 展示状态文字  showStatus(status) &#123;    return (      &lt;span        style=&#123;&#123;          color: arr[status]?.color,        &#125;&#125;      &gt;        &#123;arr[status]?.text&#125;      &lt;/span&gt;    );  &#125;  // 搜索  searchData() &#123;    this.getList(&#123;      date: this.state.searchParams.dateValue,      name: this.state.searchParams.nameValue,      status: this.state.searchParams.statusValue,    &#125;);  &#125;  // 重置  resetData() &#123;    this.setState(      &#123;        searchParams: &#123;          dateValue: &quot;&quot;,          nameValue: &quot;&quot;,          statusValue: 0,        &#125;,      &#125;,      () =&gt; &#123;        this.getList();      &#125;    );  &#125;  // 新增  addFn() &#123;    axios(&#123;      url: &quot;http://localhost:8000/addOrder&quot;,      method: &quot;post&quot;,      data: this.state.popForm,    &#125;).then((res) =&gt; &#123;      console.log(&quot;addFn res&quot;, res);      this.setState(&#123;        popShow: false,      &#125;);      this.getList();    &#125;);  &#125;  // 编辑  updateFn() &#123;    axios(&#123;      url: &quot;http://localhost:8000/updateOrder&quot;,      method: &quot;post&quot;,      data: this.state.popForm,    &#125;).then((res) =&gt; &#123;      console.log(&quot;updateFn res&quot;, res);      this.setState(&#123;        popShow: false,        popForm: &#123;          dateValue: &quot;&quot;,          nameValue: &quot;&quot;,          statusValue: 0,        &#125;,      &#125;);      this.getList();    &#125;);  &#125;  // 删除  deleteFn(id) &#123;    axios(&#123;      url: &quot;http://localhost:8000/updateOrder&quot;,      method: &quot;post&quot;,      data: &#123;        id      &#125;,    &#125;).then((res) =&gt; &#123;      console.log(&quot;deleteFn res&quot;, res);      this.getList();    &#125;);  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;div&gt;          &lt;label&gt;日期&lt;/label&gt;          &lt;input            value=&#123;this.state.searchParams.dateValue&#125;            onInput=&#123;(e) =&gt; &#123;              this.setState(&#123;                searchParams: &#123;                  ...this.state.searchParams,                  dateValue: e.target.value,                &#125;,              &#125;);            &#125;&#125;          /&gt;          &lt;label&gt;订单名&lt;/label&gt;          &lt;input            value=&#123;this.state.searchParams.nameValue&#125;            onInput=&#123;(e) =&gt; &#123;              this.setState(&#123;                searchParams: &#123;                  ...this.state.searchParams,                  nameValue: e.target.value,                &#125;,              &#125;);            &#125;&#125;          /&gt;          &lt;label&gt;订单状态&lt;/label&gt;          &lt;select            value=&#123;this.state.searchParams.statusValue&#125;            onChange=&#123;(e) =&gt; &#123;              this.setState(&#123;                searchParams: &#123;                  ...this.state.searchParams,                  statusValue: e.target.value,                &#125;,              &#125;);            &#125;&#125;          &gt;            &#123;arr.map((item, index) =&gt; &#123;              return (                &lt;option value=&#123;index&#125; key=&#123;index&#125;&gt;                  &#123;item.text&#125;                &lt;/option&gt;              );            &#125;)&#125;          &lt;/select&gt;          &lt;button onClick=&#123;() =&gt; this.searchData()&#125;&gt;搜索&lt;/button&gt;          &lt;button onClick=&#123;() =&gt; this.resetData()&#125;&gt;重置&lt;/button&gt;        &lt;/div&gt;        &#123;/* 新增按钮 */&#125;        &lt;div&gt;          &lt;button            onClick=&#123;() =&gt; &#123;              this.setState(&#123;                popShow: true,                popTitle: &quot;新增&quot;,                // confirmFn: this.addFn.bind(this),              &#125;);            &#125;&#125;          &gt;            新增          &lt;/button&gt;        &lt;/div&gt;        &#123;/* 表格 */&#125;        &lt;table&gt;          &lt;thead&gt;            &lt;tr&gt;              &lt;td&gt;日期&lt;/td&gt;              &lt;td&gt;订单名&lt;/td&gt;              &lt;td&gt;订单状态&lt;/td&gt;              &lt;td&gt;操作&lt;/td&gt;            &lt;/tr&gt;          &lt;/thead&gt;          &lt;tbody&gt;            &#123;this.state.tableArr.map((item) =&gt; &#123;              return (                &lt;tr key=&#123;item.id&#125;&gt;                  &lt;td&gt;&#123;item.date&#125;&lt;/td&gt;                  &lt;td&gt;&#123;item.name&#125;&lt;/td&gt;                  &lt;td&gt;&#123;this.showStatus(item.status)&#125;&lt;/td&gt;                  &lt;td&gt;                    &lt;button                      onClick=&#123;() =&gt; &#123;                        this.setState(&#123;                          popShow: true,                          popTitle: &quot;编辑&quot;,                          popForm: &#123;                            dateValue: item.date,                            nameValue: item.name,                            statusValue: item.status,                          &#125;,                          // confirmFn: this.updateFn.bind(this)                        &#125;);                      &#125;&#125;                    &gt;                      编辑                    &lt;/button&gt;                    &lt;button onClick=&#123;() =&gt; this.deleteFn(item.id)&#125;&gt;删除&lt;/button&gt;                  &lt;/td&gt;                &lt;/tr&gt;              );            &#125;)&#125;          &lt;/tbody&gt;        &lt;/table&gt;        &#123;/* 弹窗 */&#125;        &#123;this.state.popShow ? (          &lt;Pop            title=&#123;this.state.popTitle&#125;            confirm=&#123;              this.state.popTitle === &quot;新增&quot;                ? this.addFn.bind(this)                : this.updateFn.bind(this)            &#125;            cancel=&#123;() =&gt; &#123;              this.setState(&#123;                popShow: false,              &#125;);            &#125;&#125;          &gt;            &lt;div&gt;              &lt;div&gt;                &lt;label&gt;日期&lt;/label&gt;                &lt;input                  value=&#123;this.state.popForm.dateValue&#125;                  onInput=&#123;(e) =&gt; &#123;                    this.setState(&#123;                      popForm: &#123;                        ...this.state.popForm,                        dateValue: e.target.value,                      &#125;,                    &#125;);                  &#125;&#125;                /&gt;              &lt;/div&gt;              &lt;div&gt;                &lt;label&gt;订单名&lt;/label&gt;                &lt;input                  value=&#123;this.state.popForm.nameValue&#125;                  onInput=&#123;(e) =&gt; &#123;                    this.setState(&#123;                      popForm: &#123;                        ...this.state.popForm,                        nameValue: e.target.value,                      &#125;,                    &#125;);                  &#125;&#125;                /&gt;              &lt;/div&gt;              &lt;div&gt;                &lt;label&gt;状态&lt;/label&gt;                &lt;select                  value=&#123;this.state.popForm.statusValue&#125;                  onChange=&#123;(e) =&gt; &#123;                    this.setState(&#123;                      popForm: &#123;                        ...this.state.popForm,                        statusValue: e.target.value,                      &#125;,                    &#125;);                  &#125;&#125;                &gt;                  &#123;arr.map((item, index) =&gt; &#123;                    return (                      &lt;option value=&#123;index&#125; key=&#123;index&#125;&gt;                        &#123;item.text&#125;                      &lt;/option&gt;                    );                  &#125;)&#125;                &lt;/select&gt;              &lt;/div&gt;            &lt;/div&gt;          &lt;/Pop&gt;        ) : null&#125;      &lt;/div&gt;    );  &#125;&#125;export default App;\n\n/* Pop.js */import React from &quot;react&quot;;import popStyle from &quot;./Pop.module.css&quot;;class Pop extends React.PureComponent &#123;  render() &#123;    return (      &lt;div className=&#123;popStyle.cover&#125;&gt;        &lt;div className=&#123;popStyle.content&#125;&gt;          &lt;div className=&#123;popStyle.title&#125;&gt;            &#123;/* &#123;this.props.title ? this.props.title : &quot;标题&quot;&#125; */&#125;            &#123;this.props.title&#125;          &lt;/div&gt;          &#123;/* &lt;div&gt;&#123;this.props.content&#125;&lt;/div&gt; */&#125;          &lt;div&gt;&#123;this.props.children&#125;&lt;/div&gt;          &lt;div&gt;            &lt;button onClick=&#123;() =&gt; this.props.confirm()&#125;&gt;确定&lt;/button&gt;            &lt;button onClick=&#123;() =&gt; this.props.cancel()&#125;&gt;取消&lt;/button&gt;          &lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;    );  &#125;&#125;Pop.defaultProps = &#123;  title: &quot;标题&quot;,&#125;;export default Pop;\n\n/* Pop.module.css */.cover &#123;    position: fixed;    top: 0;    bottom: 0;    left: 0;    right: 0;    background-color: rgba(0, 0, 0, 0.6);&#125;.content &#123;    width: 500px;    margin: 200px auto;    background-color: #fff;&#125;.title &#123;    padding: 30px;    border-bottom: 1px solid #000;&#125;\n\n十一、ref 和 context1、ref用于获取真实 DOM，和 Vue 中的 ref 类似，注意：\n（1）ref 必须在挂载后才能获取，通常在 componentDidMount\n（2）ref 只能获取类组件，不能获取函数组件\n2、context类似 Vue 的 provider 和 injected，用于嵌套很深的爷孙组件之间传值，注意：\n子组件使用父组件创建的 context 对象，不能自己创建\n/* App.js */import React from &quot;react&quot;;import Son from &quot;./Son&quot;;let div1 = React.createRef()let sonComp = React.createRef();// 是一个组件export let Context1 = React.createContext();class App extends React.PureComponent &#123;  state = &#123;    msg: &quot;父组件&quot;,    passMsg: &quot;传递消息&quot;  &#125;  // div1 = React.createRef()  componentDidMount() &#123;    // 真实 DOM    console.log(&quot;div1.current&quot;, div1.current)    //     console.log(&quot;sonComp.current&quot;, sonComp.current)  &#125;  render() &#123;    return (      // 类似 Vue 中的 template      &lt;&gt;        &lt;div className=&quot;App&quot; ref=&#123;div1&#125;&gt;&#123;this.state.msg&#125;&lt;/div&gt;                &#123;/* 只能使用 value 这一个 props */&#125;        &lt;Context1.Provider value=&#123;this.state.passMsg&#125;&gt;          &lt;Son ref=&#123;sonComp&#125;&gt;&lt;/Son&gt;        &lt;/Context1.Provider&gt;      &lt;/&gt;    );  &#125;&#125;export default App;\n\n/* Son.js */import React from &quot;react&quot;;import GrandSon from &quot;./GrandSon&quot;;class Son extends React.PureComponent &#123;  state = &#123;    sonMsg: &quot;子组件&quot;,  &#125;;  render() &#123;    return (      &lt;&gt;        &lt;div className=&quot;Son&quot;&gt;&#123;this.state.sonMsg&#125;&lt;/div&gt;        &lt;GrandSon&gt;&lt;/GrandSon&gt;      &lt;/&gt;    );  &#125;&#125;export default Son;\n\n/* GrandSon.js */import React from &quot;react&quot;;import &#123; Context1 &#125; from &quot;./App&quot;;class GrandSon extends React.PureComponent &#123;  state = &#123;    grandsonMsg: &quot;孙子组件&quot;,  &#125;;  render() &#123;    return (      &lt;&gt;        &lt;div className=&quot;Son&quot;&gt;&#123;this.state.grandsonMsg&#125;&lt;/div&gt;        &lt;Context1.Consumer&gt;          &#123;            (value) =&gt; &#123;              console.log(value);              return &lt;div&gt;&#123;value&#125;&lt;/div&gt;            &#125;          &#125;        &lt;/Context1.Consumer&gt;      &lt;/&gt;    );  &#125;&#125;export default GrandSon;\n\n十二、函数组件 和 hook1、函数组件和类组件的区别（1）函数组件没有生命周期\n（2）函数组件没有 this\n（3）函数组件通过 hook 来完成各种操作\n（4）函数组件本身的函数体相当于 render 函数\n（5）props 在函数的第一个参数接受\n2、useEffect()不传第二个参数 &#x3D; componentDidMount 和 componentDidUpdate\n第二个参数传空数组 &#x3D; componentDidMount\n第二个参数数组里放某个数据 &#x3D; watch 监听\n3、useMemo()让一段计算在开始运行一次，后续只有依赖的数据发生变化时才重新运算，作用：\n（1）类似于 Vue 的一个计算属性的效果\n（2）缓存一个数据，让其不会重新创建\n4、 useCallback()缓存一个方法，让方法不会每次更新都重新创建\n5、其他 hooksuseRef：函数组件中使用 ref\nuseContext：更方便解析 context 的 provider 的数据\n/* App.js */import Son from &quot;./Son&quot;;// vue3 - ref, reactiveimport &#123; useState, useEffect, useMemo, useCallback, useRef, createContext &#125; from &quot;react&quot;;export let Context1 = createContext();function App() &#123;  // 相当于 render  // return 的内容相当于组件的 html  let [msg, setMsg] = useState(&quot;hello&quot;);  let [msg2, setMsg2] = useState(&quot;hello2&quot;);  let [arr, setArr] = useState([1, 2, 3]);  let dom1 = useRef();  // 想要第二次更新不会运行，第二个参数需要传监听的数组  let all = useMemo(() =&gt; &#123;    console.log(&quot;recount&quot;);    let _all = 0;    arr.forEach((item) =&gt; &#123;      _all += item;    &#125;);    return _all;  &#125;, [arr]);  // useEffect, useMemo, useCallback 第二个参数的作用一样  let changeMsg = useCallback(() =&gt; &#123;    setMsg(&quot;1&quot;);  &#125;, []);  function changeArr() &#123;    let _arr = [...arr];    _arr.push(4);    setArr(_arr);  &#125;  // // 第一个参数是回调函数 - 必填  // // 不传第二个参数 = componentDidMount 和 componentDidUpdate  // useEffect(() =&gt; &#123;  //   console.log(&quot;effect&quot;)  // &#125;)  // // 第二个参数传空数组 = componentDidMount  // useEffect(() =&gt; &#123;  //   console.log(&quot;effect&quot;)  // &#125;, [])  // 第二个参数传非空数组 = watch 监听  // 一开始就会执行  useEffect(() =&gt; &#123;    console.log(&quot;effect&quot;);  &#125;, [msg]);  useEffect(() =&gt; &#123;    console.log(&quot;dom1&quot;, dom1);  &#125;, []);  return (    &lt;&gt;      &lt;div&gt;this is App&lt;/div&gt;      &lt;div&gt;&#123;msg&#125;&lt;/div&gt;      &lt;div&gt;&#123;msg2&#125;&lt;/div&gt;      &lt;div&gt;&#123;all&#125;&lt;/div&gt;      &lt;div&gt;&#123;arr&#125;&lt;/div&gt;      &lt;button ref=&#123;dom1&#125; onClick=&#123;changeMsg&#125;&gt;        修改msg      &lt;/button&gt;      &lt;button        onClick=&#123;() =&gt; &#123;          setMsg2(&quot;2&quot;);        &#125;&#125;      &gt;        修改msg2      &lt;/button&gt;      &lt;button onClick=&#123;changeArr&#125;&gt;修改arr&lt;/button&gt;      &lt;Context1.Provider value=&quot;I&#x27;m context msg&quot;&gt;        &lt;Son fatherMsg=&quot;I&#x27;m father&quot;&gt;&lt;/Son&gt;      &lt;/Context1.Provider&gt;    &lt;/&gt;  );&#125;export default App;\n\n/* Son.js */import &#123; useContext &#125; from &quot;react&quot;;import &#123; Context1 &#125; from &quot;./App&quot;;function Son(props) &#123;  console.log(&quot;props&quot;, props);  let value = useContext(Context1);  console.log(&quot;value&quot;, value);  return &lt;div&gt;this is son&lt;/div&gt;;&#125;export default Son;\n\n十三、高阶组件如果是 UI 内容和操作的复用是使用组件，但如果是单纯逻辑的复用，可以使用高阶组件\n可以类比于 Vue 中的 Mixin 和自定义指令\n什么时候用高阶组件（1）组件组件既包含了 UI 界面的复用，也包含了逻辑的复用\n（2）高阶组件高阶组件只是复用操作逻辑、运算。类似 Vue 中 Mixin 的用途\n/* App.js */import &#123; useState &#125; from &quot;react&quot;;import Son from &quot;./Son&quot;;// import TestHoc from &quot;./TestHoc&quot;;import MemoHoc from &quot;./MemoHoc&quot;;// let HocSon = TestHoc(Son);let MemoSon = MemoHoc(Son);function App() &#123;  let [num, setNum] = useState(0);  return (    &lt;&gt;      &#123;/* 鼠标位置监听 */&#125;      &#123;/* &lt;HocSon&gt;&lt;/HocSon&gt; */&#125;      &lt;MemoSon&gt;&lt;/MemoSon&gt;      &lt;div&gt;num: &#123;num&#125;&lt;/div&gt;      &lt;button        onClick=&#123;() =&gt; &#123;          setNum(1);        &#125;&#125;      &gt;        修改数字      &lt;/button&gt;    &lt;/&gt;  );&#125;export default App;\n\n/* TestHoc.js */import React from &quot;react&quot;;// 抛出一个 返回匿名类组件的方法// 复用了其中的 state 数据 和 fn1 方法export default function TestHoc(UserComp) &#123;  return class extends React.PureComponent &#123;    state = &#123;    //   a: 123,      x: 0,      y: 0,    &#125;;    // fn1 = () =&gt; &#123;    //     console.log(&quot;this.state.a&quot;, this.state.a)    // &#125;    componentDidMount() &#123;      window.addEventListener(&quot;mousemove&quot;, (e) =&gt; &#123;        let x = e.clientX;        let y = e.clientY;        this.setState(&#123;          x,          y,        &#125;);      &#125;);    &#125;    render() &#123;      return (        &lt;&gt;          &#123;/* &lt;UserComp f1=&#123;this.fn1&#125; &#123;...this.props&#125; /&gt; */&#125;          &#123;/* 鼠标位置监听 */&#125;          &lt;UserComp x=&#123;this.state.x&#125; y=&#123;this.state.y&#125; &#123;...this.props&#125; /&gt;        &lt;/&gt;      );    &#125;  &#125;;&#125;\n\n/* MemoHoc.js */import React from &quot;react&quot;;export default function MemoHoc(UserComp) &#123;  return class extends React.Component &#123;    shouldComponentUpdate(props, state) &#123;        for(let item in props) &#123;            if(this.props[item] !== props[item]) &#123;                return true;            &#125;        &#125;        for(let item in state) &#123;            if(this.state[item] !== state[item]) &#123;                return true;            &#125;        &#125;        return false    &#125;    render() &#123;      return (        &lt;&gt;          &lt;UserComp &#123;...this.props&#125;&gt;&lt;/UserComp&gt;        &lt;/&gt;      );    &#125;  &#125;;&#125;\n\n/* Son.js */function Son(props) &#123;  // props.f1()  console.log(&quot;son render&quot;);  return (    &lt;&gt;      &lt;div&gt;高阶组件的使用&lt;/div&gt;      &#123;/* 鼠标位置监听 */&#125;      &#123;/* &lt;div&gt;x: &#123;props.x&#125;&lt;/div&gt;      &lt;div&gt;y: &#123;props.y&#125;&lt;/div&gt; */&#125;    &lt;/&gt;  );&#125;export default Son;\n\n十四、React 性能优化1、React 性能问题React 最大的性能问题就是：某个组件的更新 会连带其子组件一起更新，所以需要：\n（1）源码层面上尽量弥补这个问题\n（2）让子组件只做合理的更新\n2、React 时间切片Vue 有依赖收集，做到了最小的更新范围\n而 React 没有，所以 React 要更新，会有大量的 diff 算法比对和计算工作，可能会阻塞浏览器的工作，导致页面长时间白屏\nReact 为解决该问题选择了一种策略——时间切片，也就是先计算一部分更新，接着让渡给渲染进程渲染，然后再进行下一步更新\n\n为支持这种切片，React 设计了数据结构 fiber\n每个组件会被转化为一个 fiber 结构的对象，组成一个个单元，并且能够恢复上次中断的计算进度\n\n3、减少无意义的组件更新（1）避免父组件数据更改导致子组件更新\n类组件：PureComponent，函数组件：React.memo\n（2）避免 state 的导致的无畏更新\n类组件：PureComponent，函数组件：本来就会判断\n（3）props\n如果组件使用了 PureComponent 或者 React.Memo，已经做到了如果父组件传的 props 没变，就不会更新\n但需要特别注意父组件传入的引用数据类型：方法、对象、数组\n\n用 useCallback 包裹传给子组件的方法\n非 state 对象、数组数据，要用 useMemo 包裹\n\n/* App.js */import &#123; useMemo, useCallback &#125; from &quot;react&quot;;import Son from &quot;./Son&quot;;// React.memo 也是一种高阶函数let MemoSon = React.memo(Son);function App() &#123;  // 内部数据更新 -&gt; App 组件更新 -&gt; 重新执行 App 函数 -&gt; 重新定义 obj 和 f1 -&gt; 更新 MemoSon 子组件  // let obj = &#123;  //     a: 1  // &#125;  let obj = useMemo(() =&gt; &#123;    return &#123;      a: 1,    &#125;;  &#125;, []);  // function f1() &#123;  //     console.log(123)  // &#125;  let f1 = useCallback(() =&gt; &#123;    console.log(123);  &#125;, []);  return (    &lt;&gt;      &lt;MemoSon obj=&#123;obj&#125; f1=&#123;f1&#125;&gt;&lt;/MemoSon&gt;    &lt;/&gt;  );&#125;\n","categories":["React - 基础课程"],"tags":["React"]},{"title":"React3","url":"/2025/01/25/58-React3/","content":"十五、React-router 使用1、React-router 的三个版本（1）React-router服务端渲染使用\n（2）React-router-dom浏览器端渲染使用（常用）\n（3）React-router-nativeReact-native 混合开发使用\n2、React-router 使用步骤（1）通过 BrowserRouter 或者 HashRouter 包裹要使用路由的根组件\n（2）使用 Routes 组件，定义路由显示区域\n（3）使用 Route 组件，定义具体路由规则\n（4）使用 NavLink 或者 Link 组件，定义跳转链接\n3、React-router 其他组件（1）Navigate：路由重定向\n（2）Outlet：嵌套路由的子路由显示处\n4、获取路由参数（1）Params 参数\nV5：useParams\nV6：this.props.match.params\n\n（2）Query 参数\nV5：useSearchParams\nV6：this.props.location.search\n\n（3）Location 信息\nV5：useLocation\nV6：this.props.location.state\n\n5、js 控制跳转地址\nV6：useNavigate 创建跳转方法、然后跳转\nV5：this.props.history.push()\n\n6、React 异步路由React 做异步路由，要配合 React 的方法 lazy 和 组件 suspense\n/* index.js */import React from &quot;react&quot;;import ReactDOM from &quot;react-dom/client&quot;;import &quot;./index.css&quot;;import App from &quot;./App&quot;;import reportWebVitals from &quot;./reportWebVitals&quot;;import &#123; BrowserRouter, HashRouter &#125; from &quot;react-router-dom&quot;;const root = ReactDOM.createRoot(document.getElementById(&quot;root&quot;));root.render(  &lt;React.StrictMode&gt;    &#123;/* history 模式，路径为 .../page1 */&#125;    &lt;BrowserRouter&gt;      &#123;/* hash 模式，路径为 .../#/page1 */&#125;      &#123;/* &lt;HashRouter&gt; */&#125;      &lt;App /&gt;      &#123;/* &lt;/HashRouter&gt; */&#125;    &lt;/BrowserRouter&gt;  &lt;/React.StrictMode&gt;);reportWebVitals();\n\n/* App.js */import &quot;./App.css&quot;;import &#123; Routes, Route, NavLink, Link, Navigate &#125; from &quot;react-router-dom&quot;;import Page1 from &quot;./Page1&quot;;import Page2 from &quot;./Page2&quot;;import Page3 from &quot;./Page3&quot;;import Page4 from &quot;./Page4&quot;;import Page2Son1 from &quot;./Page2Son1&quot;;import Page2Son2 from &quot;./Page2Son2&quot;;// 异步路由（懒加载）import &#123; lazy, Suspense &#125; from &quot;react&quot;;let LazyPage4 = lazy(() =&gt; &#123;  return import(&quot;./Page4&quot;);&#125;);function App() &#123;  let _token = localStorage.getItem(&quot;token&quot;);  return (    &lt;&gt;      &#123;/* 菜单 */&#125;      &lt;div&gt;        &#123;/* NavLink 有 active 类 */&#125;        &lt;NavLink to=&quot;/page1&quot;&gt;page1&lt;/NavLink&gt;        &lt;NavLink to=&quot;/page2&quot;&gt;page2&lt;/NavLink&gt;        &lt;NavLink to=&quot;/page3&quot;&gt;page3&lt;/NavLink&gt;        &lt;NavLink to=&quot;/page4&quot;&gt;page4&lt;/NavLink&gt;        &lt;NavLink to=&quot;/lazyPage4&quot;&gt;lazyPage4&lt;/NavLink&gt;        &#123;/* Link 没有 active 类 */&#125;        &#123;/* &lt;Link to=&quot;/page1&quot;&gt;page1&lt;/Link&gt;        &lt;Link to=&quot;/page2&quot;&gt;page2&lt;/Link&gt;        &lt;Link to=&quot;/page3&quot;&gt;page3&lt;/Link&gt;        &lt;Link to=&quot;/page4&quot;&gt;page4&lt;/Link&gt; */&#125;      &lt;/div&gt;      &#123;/* React v5 和 v6 有较大的区别 */&#125;      &#123;/* v5 是 switch，只有 Component */&#125;      &#123;/* Routes 里只能放 Route，Route 也只能放到 Routes 里 */&#125;      &lt;Suspense fallback=&#123;&lt;h2&gt;加载中&lt;/h2&gt;&#125;&gt;        &lt;Routes&gt;          &#123;/* 控制访问权限1：通过 navigate 跳转到其他页面 */&#125;          &#123;/* &lt;Route          path=&quot;/page1&quot;          element=&#123;_token ? &lt;Page1&gt;&lt;/Page1&gt; : &lt;Navigate to=&quot;/page4&quot;&gt;&lt;/Navigate&gt;&#125;        &gt;&lt;/Route&gt; */&#125;          &#123;/* 控制访问权限2：直接不生成 */&#125;          &lt;Route path=&quot;/page1&quot; element=&#123;_token ? &lt;Page1&gt;&lt;/Page1&gt; : &quot;&quot;&#125;&gt;&lt;/Route&gt;          &lt;Route path=&quot;/page2&quot; Component=&#123;Page2&#125;&gt;            &lt;Route path=&quot;son1&quot; Component=&#123;Page2Son1&#125;&gt;&lt;/Route&gt;            &lt;Route path=&quot;son2&quot; Component=&#123;Page2Son2&#125;&gt;&lt;/Route&gt;          &lt;/Route&gt;          &lt;Route path=&quot;/page3/:id&quot; Component=&#123;Page3&#125;&gt;&lt;/Route&gt;          &lt;Route path=&quot;/page4&quot; Component=&#123;Page4&#125;&gt;&lt;/Route&gt;          &lt;Route path=&quot;/lazyPage4&quot; Component=&#123;LazyPage4&#125;&gt;&lt;/Route&gt;        &lt;/Routes&gt;      &lt;/Suspense&gt;    &lt;/&gt;  );&#125;export default App;\n\n/* Page1.js */// location 路径信息import &#123; useLocation &#125; from &quot;react-router-dom&quot;;function Page1() &#123;  let location = useLocation();  console.log(&quot;location&quot;, location);  return &lt;div&gt;this is page1&lt;/div&gt;;&#125;export default Page1;\n\n/* Page2.js */import &#123; Outlet, useNavigate &#125; from &quot;react-router-dom&quot;;function Page2() &#123;  let nav = useNavigate()  return (    &lt;&gt;      &lt;div&gt;this is page2&lt;/div&gt;      &lt;button onClick=&#123;() =&gt; &#123;        nav(&quot;/page1?a=12345&quot;, &#123;          state: &#123;            msg: &quot;state msg&quot;          &#125;        &#125;)      &#125;&#125;&gt;跳转到 page1&lt;/button&gt;      &#123;/* 嵌套路由 */&#125;      &lt;Outlet&gt;&lt;/Outlet&gt;    &lt;/&gt;  );&#125;export default Page2;\n\n/* Page2Son1.js */function Page2Son1() &#123;  return &lt;div&gt;this is page2son1&lt;/div&gt;;&#125;export default Page2Son1;\n\n/* Page2Son2.js */function Page2Son2() &#123;  return &lt;div&gt;this is page2son2&lt;/div&gt;;&#125;export default Page2Son2;\n\n/* Page3.js */// ../page3?a=1&amp;b=2 - Query 参数// ../page3/123 - Param 参数import &#123; useParams &#125; from &quot;react-router-dom&quot;;function Page3() &#123;  let params = useParams()  console.log(&quot;params&quot;, params)  return &lt;div&gt;this is page3&lt;/div&gt;;&#125;export default Page3;\n\n/* Page4.js */import &#123; useSearchParams &#125; from &quot;react-router-dom&quot;;function Page4() &#123;  let [searchParams, setSearchParams] = useSearchParams();  console.log(&quot;searchParams.get(&#x27;a&#x27;)&quot;, searchParams.get(&quot;a&quot;));  // console.log(&quot;setSearchParams&quot;, setSearchParams)  return (    &lt;&gt;      &lt;div&gt;this is page4&lt;/div&gt;      &lt;button        onClick=&#123;() =&gt; &#123;          setSearchParams(&#123;            a: 888,            b: 666,          &#125;);        &#125;&#125;      &gt;        改变 search      &lt;/button&gt;    &lt;/&gt;  );&#125;export default Page4;\n\n十六、React 状态管理1、状态管理（1）React 没有专门的状态管理库，只有通用的 JS 状态管理库，所以首先创建一个全局的数据储存和管理工具\n（2）通过其他工具，数据修改能触发 React 页面更新\n2、React 状态管理库\n3、Redux/* index.js */import React from &quot;react&quot;;import ReactDOM from &quot;react-dom/client&quot;;import &quot;./index.css&quot;;import App from &quot;./App&quot;;import reportWebVitals from &quot;./reportWebVitals&quot;;import &#123; Provider &#125; from &quot;react-redux&quot;;import store from &quot;./store/index&quot;;const root = ReactDOM.createRoot(document.getElementById(&quot;root&quot;));// store.subscribe(() =&gt; &#123;//   root.render(//     &lt;React.StrictMode&gt;//       &lt;App /&gt;//     &lt;/React.StrictMode&gt;//   );// &#125;);root.render(  &lt;React.StrictMode&gt;    &lt;Provider store=&#123;store&#125;&gt;      &lt;App /&gt;    &lt;/Provider&gt;  &lt;/React.StrictMode&gt;);reportWebVitals();\n\n/* App.js */import store from &quot;./store/index&quot;;// let state = store.getState();import &#123; connect &#125; from &quot;react-redux&quot;;function App(props) &#123;  console.log(&quot;props&quot;, props);  // console.log(&quot;state1&quot;, state);  return (    &lt;&gt;      &#123;/* &lt;div&gt;&#123;state.msg&#125;&lt;/div&gt;      &lt;button        onClick=&#123;() =&gt; &#123;          store.dispatch(&#123;            type: &quot;changeMsg&quot;,            payload: &quot;world&quot;,          &#125;);          console.log(&quot;state2&quot;, state);        &#125;&#125;      &gt;        修改 state      &lt;/button&gt; */&#125;      &lt;div&gt;&#123;props.msg&#125;&lt;/div&gt;      &lt;button        onClick=&#123;() =&gt; &#123;          console.log(&quot;store.getState()&quot;, store.getState());          // props.dispatch(&#123;          //   type: &quot;changeMsg&quot;,          //   payload: &quot;world&quot;,          // &#125;);          props.changeMsg();        &#125;&#125;      &gt;        修改 state      &lt;/button&gt;    &lt;/&gt;  );&#125;// connect 第一个参数是 state 的映射，即需要把哪些 state 映射到该组件的 props 里// connect 第二个参数是方法的映射，即需要给 props 加入的方法let ReduxApp = connect(  (state) =&gt; &#123;    console.log(&quot;state&quot;, state);    // return state;    return &#123;      msg: state.msgReducer.msg,    &#125;;  &#125;,  (dispatch) =&gt; &#123;    return &#123;      // 把 dispatch 封装成 changeMsg      changeMsg() &#123;        dispatch(&#123;          type: &quot;changeMsg&quot;,          payload: &quot;world&quot;,        &#125;);      &#125;,    &#125;;  &#125;)(App);export default ReduxApp;\n\n/* store/index.js */import &#123; legacy_createStore as createStore, combineReducers &#125; from &quot;redux&quot;;function msgReducer(state = &#123; msg: &quot;hello&quot; &#125;, action) &#123;  // 具体修改数据的行为  // 通常约定叫 type  switch (action.type) &#123;    case &quot;changeMsg&quot;:      // 通常约定叫 payload      state.msg = action.payload;      // 最后一定要 return 并展开，解除引用      return &#123; ...state &#125;;    case &quot;resetMsg&quot;:      state.msg = &quot;hello&quot;;      return &#123; ...state &#125;;    default:      return state;  &#125;&#125;function numReducer(state = &#123; num: 0 &#125;, action) &#123;  switch (action.type) &#123;    case &quot;addNum&quot;:      state.num++;      return &#123; ...state &#125;;    default:      return state;  &#125;&#125;let reducer = combineReducers(&#123;  msgReducer,  numReducer,&#125;);let store = createStore(reducer);export default store;\n\n4、Redux-toolkit（1）connect 方式/* index.js */import React from &quot;react&quot;;import ReactDOM from &quot;react-dom/client&quot;;import &quot;./index.css&quot;;import App from &quot;./App&quot;;import reportWebVitals from &quot;./reportWebVitals&quot;;import &#123; Provider &#125; from &quot;react-redux&quot;;import store from &quot;./store/toolkitIndex&quot;;const root = ReactDOM.createRoot(document.getElementById(&quot;root&quot;));root.render(  &lt;React.StrictMode&gt;    &lt;Provider store=&#123;store&#125;&gt;      &lt;App /&gt;    &lt;/Provider&gt;  &lt;/React.StrictMode&gt;);reportWebVitals();\n\n/* App.js */import store from &quot;./store/toolkitIndex&quot;;import &#123; connect &#125; from &quot;react-redux&quot;;import &#123; changeMsg, addNum &#125; from &quot;./store/toolkitIndex&quot;;function App(props) &#123;  console.log(&quot;props&quot;, props);  return (    &lt;&gt;      &lt;div&gt;&#123;props.msg&#125;&lt;/div&gt;      &lt;div&gt;&#123;props.num&#125;&lt;/div&gt;      &lt;button        onClick=&#123;() =&gt; &#123;          console.log(&quot;store.getState()&quot;, store.getState());          props.changeMsg();        &#125;&#125;      &gt;        修改 state      &lt;/button&gt;      &lt;button        onClick=&#123;() =&gt; &#123;          console.log(&quot;store.getState()&quot;, store.getState());          props.addNum();        &#125;&#125;      &gt;        增加 num      &lt;/button&gt;    &lt;/&gt;  );&#125;// connect 第一个参数是 state 的映射，即需要把哪些 state 映射到该组件的 props 里// connect 第二个参数是方法的映射，即需要给 props 加入的方法let ReduxApp = connect(  (state) =&gt; &#123;    console.log(&quot;state&quot;, state);    return &#123;      msg: state.msgReducer.msg,      num: state.numReducer.num,    &#125;;  &#125;,  (dispatch) =&gt; &#123;    return &#123;      changeMsg() &#123;        // dispatch(&#123;        //   type: &quot;changeMsg&quot;,        //   payload: &quot;world&quot;,        // &#125;);        // toolkit 的触发方法        dispatch(changeMsg(&quot;world&quot;))      &#125;,      addNum() &#123;        // dispatch(&#123;        //   type: &quot;addNum&quot;,        // &#125;);        dispatch(addNum())      &#125;,    &#125;;  &#125;)(App);export default ReduxApp;\n\n（2）hook 方式/* App2.js */// hook 方式只能用于 toolkit，只能用于 函数组件import &#123; useSelector, useDispatch &#125; from &quot;react-redux&quot;;import &#123; addNum &#125; from &quot;./store/toolkitIndex&quot;;function App2() &#123;  // 取出 state  let num = useSelector((state) =&gt; &#123;    console.log(&quot;state&quot;, state);    return state.numReducer.num;  &#125;);  let dispatch = useDispatch()  return (    &lt;&gt;      &lt;div&gt;&#123;num&#125;&lt;/div&gt;      &lt;button onClick=&#123;()=&gt; &#123;        // dispatch(&#123;        //   type: &quot;numSlice/addNum&quot;        // &#125;)        dispatch(addNum())      &#125;&#125;&gt;增加&lt;/button&gt;    &lt;/&gt;  );&#125;export default App2;\n\n5、异步操作/* toolkitIndex.js */import &#123;  createSlice,  configureStore,  createAsyncThunk,&#125; from &quot;@reduxjs/toolkit&quot;;// 异步操作// 第一个参数名字// 第二个参数好似具体的异步操作export let changeNumThunk = createAsyncThunk(  &quot;numSlice/changeNum&quot;,  async (params) =&gt; &#123;    let res = await new Promise((resolve) =&gt; &#123;      console.log(&quot;params&quot;, params);      setTimeout((state, action) =&gt; &#123;        resolve(999);      &#125;, 1000);    &#125;);    return res;  &#125;);let msgSlice = createSlice(&#123;  name: &quot;msgSlice&quot;,  initialState: &#123;    msg: &quot;hello&quot;,  &#125;,  reducers: &#123;    changeMsg(state, action) &#123;      state.msg = action.payload;    &#125;,  &#125;,&#125;);let numSlice = createSlice(&#123;  name: &quot;numSlice&quot;,  initialState: &#123;    num: 0,  &#125;,  reducers: &#123;    addNum(state) &#123;      state.num++;    &#125;,  &#125;,    extraReducers: (chunk) =&gt; &#123;      chunk        .addCase(changeNumThunk.pending, () =&gt; &#123;          console.log(&quot;pending&quot;);        &#125;)        .addCase(changeNumThunk.fulfilled, (state, action) =&gt; &#123;          console.log(&quot;fulfilled&quot;);          state.num = action.payload;        &#125;);    &#125;,&#125;);export let &#123; changeMsg &#125; = msgSlice.actions;export let &#123; addNum &#125; = numSlice.actions;let store = configureStore(&#123;  reducer: &#123;    msgReducer: msgSlice.reducer,    numReducer: numSlice.reducer,  &#125;,&#125;);export default store;\n\n/* App.js */import store from &quot;./store/toolkitIndex&quot;;import &#123; connect &#125; from &quot;react-redux&quot;;import &#123; changeMsg, addNum, changeNumThunk &#125; from &quot;./store/toolkitIndex&quot;;function App(props) &#123;  console.log(&quot;props&quot;, props);  return (    &lt;&gt;      &lt;div&gt;&#123;props.msg&#125;&lt;/div&gt;      &lt;div&gt;&#123;props.num&#125;&lt;/div&gt;      &lt;button        onClick=&#123;() =&gt; &#123;          console.log(&quot;store.getState()&quot;, store.getState());          props.changeMsg();        &#125;&#125;      &gt;        修改 state      &lt;/button&gt;      &lt;button        onClick=&#123;() =&gt; &#123;          console.log(&quot;store.getState()&quot;, store.getState());          props.addNum();        &#125;&#125;      &gt;        增加 num      &lt;/button&gt;      &lt;button        onClick=&#123;() =&gt; &#123;          props.changeNumThunk();        &#125;&#125;      &gt;        异步修改      &lt;/button&gt;    &lt;/&gt;  );&#125;// connect 第一个参数是 state 的映射，即需要把哪些 state 映射到该组件的 props 里// connect 第二个参数是方法的映射，即需要给 props 加入的方法let ReduxApp = connect(  (state) =&gt; &#123;    console.log(&quot;state&quot;, state);    return &#123;      msg: state.msgReducer.msg,      num: state.numReducer.num,    &#125;;  &#125;,  (dispatch) =&gt; &#123;    return &#123;      changeMsg() &#123;        // dispatch(&#123;        //   type: &quot;changeMsg&quot;,        //   payload: &quot;world&quot;,        // &#125;);        // toolkit 的触发方法        dispatch(changeMsg(&quot;world&quot;));      &#125;,      addNum() &#123;        // dispatch(&#123;        //   type: &quot;addNum&quot;,        // &#125;);        dispatch(addNum());      &#125;,      changeNumThunk() &#123;        dispatch(changeNumThunk(1));      &#125;,    &#125;;  &#125;)(App);export default ReduxApp;\n\n十七、React 路由权限控制/* index.js */import React from &quot;react&quot;;import ReactDOM from &quot;react-dom/client&quot;;import &quot;./index.css&quot;;import App from &quot;./App&quot;;import reportWebVitals from &quot;./reportWebVitals&quot;;import &#123; BrowserRouter &#125; from &quot;react-router-dom&quot;;const root = ReactDOM.createRoot(document.getElementById(&quot;root&quot;));root.render(  // &lt;React.StrictMode&gt;  &lt;BrowserRouter&gt;    &lt;App /&gt;  &lt;/BrowserRouter&gt;  // &lt;/React.StrictMode&gt;);reportWebVitals();\n\n/* App.js */import &#123; Routes &#125; from &quot;react-router-dom&quot;;import &#123; createRoute &#125; from &quot;./router/createRoute&quot;;import routerArr from &quot;./router/routerArr&quot;;function App() &#123;  console.log(&quot;createRoute(routerArr)&quot;, createRoute(routerArr));  return (    &lt;&gt;      &lt;Routes&gt;&#123;createRoute(routerArr)&#125;&lt;/Routes&gt;    &lt;/&gt;  );&#125;export default App;\n\n/* createRoute.js */import &#123; Route &#125; from &quot;react-router-dom&quot;;export function createRoute(routerArr, parentPath = &quot;&quot;) &#123;  return routerArr.map((item) =&gt; &#123;    // 生成唯一的 key    const uniqueKey = parentPath ? `$&#123;parentPath&#125;-$&#123;item.path&#125;` : item.path;    if (item.children &amp;&amp; item.children.length &gt; 0) &#123;      return (        &lt;Route key=&#123;uniqueKey&#125; path=&#123;item.path&#125; element=&#123;&lt;item.component /&gt;&#125;&gt;          &#123;createRoute(item.children, item.path)&#125;        &lt;/Route&gt;      );    &#125; else &#123;      return (        &lt;Route key=&#123;uniqueKey&#125; path=&#123;item.path&#125; element=&#123;&lt;item.component /&gt;&#125; /&gt;      );    &#125;  &#125;);&#125;\n\n/* routerArr.js */import Page1 from &quot;../Page1&quot;;import Page2 from &quot;../Page2&quot;;import Page3 from &quot;../Page3&quot;;import Page2Son1 from &quot;../Page2Son1&quot;;import Page2Son2 from &quot;../Page2Son2&quot;;export default [  &#123;    path: &quot;/page1&quot;,    component: Page1,  &#125;,  &#123;    path: &quot;/page2&quot;,    component: Page2,    children: [      &#123;        path: &quot;son1&quot;,        component: Page2Son1,      &#125;,      &#123;        path: &quot;son2&quot;,        component: Page2Son2,      &#125;,    ],  &#125;,  &#123;    path: &quot;/page3&quot;,    component: Page3,  &#125;,];\n\n十八、组件库等相关生态1、React 组件库最常用：PC 端 - Ant Design，移动端 - Ant Design Mobile\n/* index.js */import React from &quot;react&quot;;import ReactDOM from &quot;react-dom/client&quot;;import &quot;./index.css&quot;;import App from &quot;./App&quot;;import reportWebVitals from &quot;./reportWebVitals&quot;;import &#123; ConfigProvider &#125; from &quot;antd&quot;;const root = ReactDOM.createRoot(document.getElementById(&quot;root&quot;));root.render(  &lt;React.StrictMode&gt;    &lt;ConfigProvider      theme=&#123;&#123;        token: &#123;          colorPrimary: &quot;#666&quot;,        &#125;,      &#125;&#125;    &gt;      &lt;App /&gt;    &lt;/ConfigProvider&gt;  &lt;/React.StrictMode&gt;);reportWebVitals();\n\n/* App.js */import &#123; Button &#125; from &quot;antd&quot;;import &#123; Table &#125; from &quot;antd&quot;;import &#123; useMemo &#125; from &quot;react&quot;;function App() &#123;  let arr = [    &#123;      id: 0,      name: &quot;name1&quot;,      status: 0,    &#125;,    &#123;      id: 1,      name: &quot;name2&quot;,      status: 1,    &#125;,    &#123;      id: 2,      name: &quot;name3&quot;,      status: 0,    &#125;,  ];  let columns = useMemo(() =&gt; &#123;    return [      &#123;        title: &quot;名字&quot;,        dataIndex: &quot;name&quot;,      &#125;,      &#123;        title: &quot;状态&quot;,        dataIndex: &quot;status&quot;,        render(status) &#123;          console.log(&quot;status1&quot;, status); // 0 1 2          return &lt;&gt;&#123;status === 0 ? &lt;span&gt;在校&lt;/span&gt; : &lt;span&gt;已休学&lt;/span&gt;&#125;&lt;/&gt;;        &#125;,      &#125;,      &#123;        title: &quot;操作&quot;,        render(status) &#123;          console.log(&quot;status2&quot;, status); // 没有 dataIndex，整列数据          return (            &lt;&gt;              &lt;Button type=&quot;primary&quot;&gt;增加&lt;/Button&gt;              &lt;Button&gt;删除&lt;/Button&gt;            &lt;/&gt;          );        &#125;,      &#125;,    ];  &#125;);  return (    &lt;&gt;      &lt;Button&gt;按钮&lt;/Button&gt;      &lt;Table columns=&#123;columns&#125; dataSource=&#123;arr&#125; rowKey=&quot;id&quot;&gt;&lt;/Table&gt;    &lt;/&gt;  );&#125;export default App;\n\n2、应用框架最常用：umi\nnpm i pnpm -gpnpm dix create-umi@latest\n","categories":["React - 基础课程"],"tags":["React"]},{"title":"IB-Rust1-环境搭建","url":"/2025/05/20/59-IB-Rust1/","content":"一、Rust 介绍1、内存安全不允许空指针和悬空指针，可预防 C++ 中的许多类型错误\n2、静态类型编译器必须在编译期知道所有变量的类型\n在编译器能推导变量类型的情况下，不需要手动为变量指定类型\n3、并发编程使开发者能编写高效、安全的多线程程序，避免数据竞争等并发问题\n二、环境搭建1、安装通过 rustup 下载 Rust\ncurl --proto &#x27;=https&#x27; --tlsv1.2 -sSf https://sh.rustup.rs | sh\n\n检查是否正确安装 Rust\n$ rustc --version\n\n2、rustup 命令（1）升级 rust 工具链和 rustup 本身rustup update\n（2）卸载 rustrustup self uninstall\n（3）打开离线文档rustup doc\n三、vscode 配置1、rust-analyzer\n2、even-better-toml\n3、crates（已无法使用，换成了 Dependi）\n四、hello worldrust 文件以 .rs 结尾，如 main.rs\nfn main() &#123;    println!(&quot;Hello, world!&quot;);&#125;\n\n1、编译rustc main.rs\n\n编译成功后输出一个二进制可执行文件 main\n2、运行rust 是 预编译静态类型（ahead-of-time compiled）语言，即一旦拥有了编译后的可执行文件，不需要安装 Rust 即可运行\n./main\n\n五、cargo1、初始化项目cargo new hello_cargocd hello_cargo\n\n其中的 Cargo.toml 文件包含：\n[package]name = &quot;hello_cargo&quot;version = &quot;0.1.0&quot;edition = &quot;2024&quot;[dependencies]\n\n[package]\n\n项目名称\n项目版本\nRust 版本\n\n[dependencies]\n项目依赖，Rust 中的代码包为 crates\n2、构建并运行（1）构建cargo build\n\n创建可执行文件 target&#x2F;debug&#x2F;hello_cargo\n（2）运行./target/debug/hello_cargo\n\n（3）构建并运行cargo run\n\n同时编译并运行生成的可执行文件，更方便\n（4）发布构建cargo build --release\n\n在 target&#x2F;release 下生成可执行文件，编译优化让 Rust 代码运行的更快，但消耗更长的编译时间\n两种构建对比：\n\ncargo build 用于开发，因为经常需要重新构建\n\ncargo build --release 用于为用户构建最终程序，不会经常重新构建，并希望程序运行得更快\n\n\n3、添加依赖crate 是一个 Rust 代码库，可以包含任意能被其他程序使用的代码，但不能自执行\n添加一个随机数的库（crate）：\n[dependencies]rand = &quot;0.8.5&quot;\n\n然后重新构建项目\n\n当增加了新依赖，Cargo 会从 Crates.io 获取依赖，并将指定的依赖版本写入 Cargo.lock 文件\n\nCargo.lock 文件\n确保任何人在任何时候重新构建代码，都会产生相同的结果，因为 Cargo 只会使用指定的依赖版本（类似 package-lock.json）\n\n\n如需升级 crate，cargo update 会忽略 Cargo.lock 文件，并计算出所有符合 Cargo.toml 声明的最新版本，接着将其写入 Cargo.lock。\n但是 Cargo 只会寻找 0.8.x 的版本，假设 rand crate 发布了 0.8.6 和 0.9.0 两个新版本，运行 cargo update 后会升级到 0.8.6 而不是 0.9.0。这是因为 0.9.0 相对于 0.8.5 主版本发生了变化。\n如需升级到 0.9.x 版本，更新 Cargo.toml 文件：\n[dependencies]rand = &quot;0.9.0&quot;\n\n4、配置国内镜像为了使用 crates.io 之外的注册服务，需要对 $HOME/.cargo/config.toml 文件进行配置，添加新的服务提供商\n\ncargo v1.68 开始支持稀疏索引：不需要完整克隆 crates.io-index 仓库，加快获取包的速度\n\n\n协议推荐使用 git，如配置 git 协议后无法正常获取和编译 crate，可以换 https 协议试试\n\n两种实现方式：增加新的镜像地址 和 覆盖默认的镜像地址\n（1）增加新的镜像地址如果支持稀疏索引：\n### https，任选一种即可[registries]ustc = &#123; index = &quot;sparse+https://mirrors.ustc.edu.cn/crates.io-index/&quot; &#125;[registries.ustc]index = &quot;sparse+https://mirrors.ustc.edu.cn/crates.io-index/&quot;### git，任选一种即可[registries]ustc = &#123; index = &quot;sparse+git://mirrors.ustc.edu.cn/crates.io-index/&quot; &#125;[registries.ustc]index = &quot;sparse+git://mirrors.ustc.edu.cn/crates.io-index/&quot;\n\n\n这种方式只会新增一个新的镜像地址，因此在引入依赖的时候，需要指定该地址，例如在项目中引入 time 包，你需要在 Cargo.toml 中使用以下方式引入:\n[dependencies]rand = &#123;  registry = &quot;ustc&quot; &#125;\n\n（2）【推荐】覆盖默认的镜像地址这种方式不需要修改 Cargo.toml 文件，因为它会直接使用新注册服务替代默认的 crates.io。\n在 $HOME/.cargo/config.toml 添加以下内容：\n[source.crates-io]replace-with = &#x27;ustc&#x27;[source.ustc]registry = &quot;https://mirrors.ustc.edu.cn/crates.io-index/&quot;\n\n创建一个新的镜像源 [source.ustc]，然后将默认的 crates-io 替换成新的镜像源：replace-with = &#39;ustc&#39;\n\n可用镜像列表：\n# 中科大&quot;https://mirrors.ustc.edu.cn/crates.io-index/&quot;&quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;# 清华&quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git/&quot;# 字节&quot;https://rsproxy.cn/crates.io-index/&quot;\n","categories":["Rust - IB课程"],"tags":["Rust"]}]